// Copyright 2021, OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// OpAMP: Open Agent Management Protocol (https://github.com/open-telemetry/opamp-spec)

// @generated by protoc-gen-es v1.9.0
// @generated from file opamp.proto (package opamp.proto, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { KeyValue } from "./anyvalue_pb.js";

/**
 * @generated from enum opamp.proto.AgentToServerFlags
 */
export declare enum AgentToServerFlags {
  /**
   * @generated from enum value: AgentToServerFlags_Unspecified = 0;
   */
  AgentToServerFlags_Unspecified = 0,

  /**
   * The Agent requests Server go generate a new instance_uid, which will
   * be sent back in ServerToAgent message
   *
   * @generated from enum value: AgentToServerFlags_RequestInstanceUid = 1;
   */
  AgentToServerFlags_RequestInstanceUid = 1,
}

/**
 * @generated from enum opamp.proto.ServerToAgentFlags
 */
export declare enum ServerToAgentFlags {
  /**
   * @generated from enum value: ServerToAgentFlags_Unspecified = 0;
   */
  ServerToAgentFlags_Unspecified = 0,

  /**
   * ReportFullState flag can be used by the Server if the Agent did not include the
   * particular bit of information in the last status report (which is an allowed
   * optimization) but the Server detects that it does not have it (e.g. was
   * restarted and lost state). The detection happens using
   * AgentToServer.sequence_num values.
   * The Server asks the Agent to report full status.
   *
   * @generated from enum value: ServerToAgentFlags_ReportFullState = 1;
   */
  ServerToAgentFlags_ReportFullState = 1,
}

/**
 * @generated from enum opamp.proto.ServerCapabilities
 */
export declare enum ServerCapabilities {
  /**
   * The capabilities field is unspecified.
   *
   * @generated from enum value: ServerCapabilities_Unspecified = 0;
   */
  ServerCapabilities_Unspecified = 0,

  /**
   * The Server can accept status reports. This bit MUST be set, since all Server
   * MUST be able to accept status reports.
   *
   * @generated from enum value: ServerCapabilities_AcceptsStatus = 1;
   */
  ServerCapabilities_AcceptsStatus = 1,

  /**
   * The Server can offer remote configuration to the Agent.
   *
   * @generated from enum value: ServerCapabilities_OffersRemoteConfig = 2;
   */
  ServerCapabilities_OffersRemoteConfig = 2,

  /**
   * The Server can accept EffectiveConfig in AgentToServer.
   *
   * @generated from enum value: ServerCapabilities_AcceptsEffectiveConfig = 4;
   */
  ServerCapabilities_AcceptsEffectiveConfig = 4,

  /**
   * The Server can offer Packages.
   * Status: [Beta]
   *
   * @generated from enum value: ServerCapabilities_OffersPackages = 8;
   */
  ServerCapabilities_OffersPackages = 8,

  /**
   * The Server can accept Packages status.
   * Status: [Beta]
   *
   * @generated from enum value: ServerCapabilities_AcceptsPackagesStatus = 16;
   */
  ServerCapabilities_AcceptsPackagesStatus = 16,

  /**
   * The Server can offer connection settings.
   * Status: [Beta]
   *
   * @generated from enum value: ServerCapabilities_OffersConnectionSettings = 32;
   */
  ServerCapabilities_OffersConnectionSettings = 32,

  /**
   * The Server can accept ConnectionSettingsRequest and respond with an offer.
   * Status: [Development]
   *
   * @generated from enum value: ServerCapabilities_AcceptsConnectionSettingsRequest = 64;
   */
  ServerCapabilities_AcceptsConnectionSettingsRequest = 64,
}

/**
 * The type of the package, either an addon or a top-level package.
 * Status: [Beta]
 *
 * @generated from enum opamp.proto.PackageType
 */
export declare enum PackageType {
  /**
   * @generated from enum value: PackageType_TopLevel = 0;
   */
  PackageType_TopLevel = 0,

  /**
   * @generated from enum value: PackageType_Addon = 1;
   */
  PackageType_Addon = 1,
}

/**
 * @generated from enum opamp.proto.ServerErrorResponseType
 */
export declare enum ServerErrorResponseType {
  /**
   * Unknown error. Something went wrong, but it is not known what exactly.
   * The Agent SHOULD NOT retry the message.
   * The error_message field may contain a description of the problem.
   *
   * @generated from enum value: ServerErrorResponseType_Unknown = 0;
   */
  ServerErrorResponseType_Unknown = 0,

  /**
   * The AgentToServer message was malformed. The Agent SHOULD NOT retry
   * the message.
   *
   * @generated from enum value: ServerErrorResponseType_BadRequest = 1;
   */
  ServerErrorResponseType_BadRequest = 1,

  /**
   * The Server is overloaded and unable to process the request. The Agent
   * should retry the message later. retry_info field may be optionally
   * set with additional information about retrying.
   *
   * @generated from enum value: ServerErrorResponseType_Unavailable = 2;
   */
  ServerErrorResponseType_Unavailable = 2,
}

/**
 * Status: [Beta]
 *
 * @generated from enum opamp.proto.CommandType
 */
export declare enum CommandType {
  /**
   * The Agent should restart. This request will be ignored if the Agent does not
   * support restart.
   *
   * @generated from enum value: CommandType_Restart = 0;
   */
  CommandType_Restart = 0,
}

/**
 * @generated from enum opamp.proto.AgentCapabilities
 */
export declare enum AgentCapabilities {
  /**
   * The capabilities field is unspecified.
   *
   * @generated from enum value: AgentCapabilities_Unspecified = 0;
   */
  AgentCapabilities_Unspecified = 0,

  /**
   * The Agent can report status. This bit MUST be set, since all Agents MUST
   * report status.
   *
   * @generated from enum value: AgentCapabilities_ReportsStatus = 1;
   */
  AgentCapabilities_ReportsStatus = 1,

  /**
   * The Agent can accept remote configuration from the Server.
   *
   * @generated from enum value: AgentCapabilities_AcceptsRemoteConfig = 2;
   */
  AgentCapabilities_AcceptsRemoteConfig = 2,

  /**
   * The Agent will report EffectiveConfig in AgentToServer.
   *
   * @generated from enum value: AgentCapabilities_ReportsEffectiveConfig = 4;
   */
  AgentCapabilities_ReportsEffectiveConfig = 4,

  /**
   * The Agent can accept package offers.
   * Status: [Beta]
   *
   * @generated from enum value: AgentCapabilities_AcceptsPackages = 8;
   */
  AgentCapabilities_AcceptsPackages = 8,

  /**
   * The Agent can report package status.
   * Status: [Beta]
   *
   * @generated from enum value: AgentCapabilities_ReportsPackageStatuses = 16;
   */
  AgentCapabilities_ReportsPackageStatuses = 16,

  /**
   * The Agent can report own trace to the destination specified by
   * the Server via ConnectionSettingsOffers.own_traces field.
   * Status: [Beta]
   *
   * @generated from enum value: AgentCapabilities_ReportsOwnTraces = 32;
   */
  AgentCapabilities_ReportsOwnTraces = 32,

  /**
   * The Agent can report own metrics to the destination specified by
   * the Server via ConnectionSettingsOffers.own_metrics field.
   * Status: [Beta]
   *
   * @generated from enum value: AgentCapabilities_ReportsOwnMetrics = 64;
   */
  AgentCapabilities_ReportsOwnMetrics = 64,

  /**
   * The Agent can report own logs to the destination specified by
   * the Server via ConnectionSettingsOffers.own_logs field.
   * Status: [Beta]
   *
   * @generated from enum value: AgentCapabilities_ReportsOwnLogs = 128;
   */
  AgentCapabilities_ReportsOwnLogs = 128,

  /**
   * The can accept connections settings for OpAMP via
   * ConnectionSettingsOffers.opamp field.
   * Status: [Beta]
   *
   * @generated from enum value: AgentCapabilities_AcceptsOpAMPConnectionSettings = 256;
   */
  AgentCapabilities_AcceptsOpAMPConnectionSettings = 256,

  /**
   * The can accept connections settings for other destinations via
   * ConnectionSettingsOffers.other_connections field.
   * Status: [Beta]
   *
   * @generated from enum value: AgentCapabilities_AcceptsOtherConnectionSettings = 512;
   */
  AgentCapabilities_AcceptsOtherConnectionSettings = 512,

  /**
   * The Agent can accept restart requests.
   * Status: [Beta]
   *
   * @generated from enum value: AgentCapabilities_AcceptsRestartCommand = 1024;
   */
  AgentCapabilities_AcceptsRestartCommand = 1024,

  /**
   * The Agent will report Health via AgentToServer.health field.
   *
   * @generated from enum value: AgentCapabilities_ReportsHealth = 2048;
   */
  AgentCapabilities_ReportsHealth = 2048,

  /**
   * The Agent will report RemoteConfig status via AgentToServer.remote_config_status field.
   *
   * @generated from enum value: AgentCapabilities_ReportsRemoteConfig = 4096;
   */
  AgentCapabilities_ReportsRemoteConfig = 4096,
}

/**
 * @generated from enum opamp.proto.RemoteConfigStatuses
 */
export declare enum RemoteConfigStatuses {
  /**
   * The value of status field is not set.
   *
   * @generated from enum value: RemoteConfigStatuses_UNSET = 0;
   */
  RemoteConfigStatuses_UNSET = 0,

  /**
   * Remote config was successfully applied by the Agent.
   *
   * @generated from enum value: RemoteConfigStatuses_APPLIED = 1;
   */
  RemoteConfigStatuses_APPLIED = 1,

  /**
   * Agent is currently applying the remote config that it received earlier.
   *
   * @generated from enum value: RemoteConfigStatuses_APPLYING = 2;
   */
  RemoteConfigStatuses_APPLYING = 2,

  /**
   * Agent tried to apply the config received earlier, but it failed.
   * See error_message for more details.
   *
   * @generated from enum value: RemoteConfigStatuses_FAILED = 3;
   */
  RemoteConfigStatuses_FAILED = 3,
}

/**
 * The status of this package.
 * Status: [Beta]
 *
 * @generated from enum opamp.proto.PackageStatusEnum
 */
export declare enum PackageStatusEnum {
  /**
   * Package is successfully installed by the Agent.
   * The error_message field MUST NOT be set.
   *
   * @generated from enum value: PackageStatusEnum_Installed = 0;
   */
  PackageStatusEnum_Installed = 0,

  /**
   * Installation of this package has not yet started.
   *
   * @generated from enum value: PackageStatusEnum_InstallPending = 1;
   */
  PackageStatusEnum_InstallPending = 1,

  /**
   * Agent is currently downloading and installing the package.
   * server_offered_hash field MUST be set to indicate the version that the
   * Agent is installing. The error_message field MUST NOT be set.
   *
   * @generated from enum value: PackageStatusEnum_Installing = 2;
   */
  PackageStatusEnum_Installing = 2,

  /**
   * Agent tried to install the package but installation failed.
   * server_offered_hash field MUST be set to indicate the version that the Agent
   * tried to install. The error_message may also contain more details about
   * the failure.
   *
   * @generated from enum value: PackageStatusEnum_InstallFailed = 3;
   */
  PackageStatusEnum_InstallFailed = 3,
}

/**
 * @generated from message opamp.proto.AgentToServer
 */
export declare class AgentToServer extends Message<AgentToServer> {
  /**
   * Globally unique identifier of the running instance of the Agent. SHOULD remain
   * unchanged for the lifetime of the Agent process.
   * MUST be 16 bytes long and SHOULD be generated using the UUID v7 spec.
   *
   * @generated from field: bytes instance_uid = 1;
   */
  instanceUid: Uint8Array;

  /**
   * The sequence number is incremented by 1 for every AgentToServer sent
   * by the Agent. This allows the Server to detect that it missed a message when
   * it notices that the sequence_num is not exactly by 1 greater than the previously
   * received one.
   *
   * @generated from field: uint64 sequence_num = 2;
   */
  sequenceNum: bigint;

  /**
   * Data that describes the Agent, its type, where it runs, etc.
   * May be omitted if nothing changed since last AgentToServer message.
   *
   * @generated from field: opamp.proto.AgentDescription agent_description = 3;
   */
  agentDescription?: AgentDescription;

  /**
   * Bitmask of flags defined by AgentCapabilities enum.
   * All bits that are not defined in AgentCapabilities enum MUST be set to 0 by
   * the Agent. This allows extending the protocol and the AgentCapabilities enum
   * in the future such that old Agents automatically report that they don't
   * support the new capability.
   * This field MUST be always set.
   *
   * @generated from field: uint64 capabilities = 4;
   */
  capabilities: bigint;

  /**
   * The current health of the Agent and sub-components. The top-level ComponentHealth represents
   * the health of the Agent overall. May be omitted if nothing changed since last AgentToServer
   * message.
   * Status: [Beta]
   *
   * @generated from field: opamp.proto.ComponentHealth health = 5;
   */
  health?: ComponentHealth;

  /**
   * The current effective configuration of the Agent. The effective configuration is
   * the one that is currently used by the Agent. The effective configuration may be
   * different from the remote configuration received from the Server earlier, e.g.
   * because the Agent uses a local configuration instead (or in addition).
   *
   * This field SHOULD be unset if the effective config is unchanged since the last
   * AgentToServer message.
   *
   * @generated from field: opamp.proto.EffectiveConfig effective_config = 6;
   */
  effectiveConfig?: EffectiveConfig;

  /**
   * The status of the remote config that was previously received from the Server.
   * This field SHOULD be unset if the remote config status is unchanged since the
   * last AgentToServer message.
   *
   * @generated from field: opamp.proto.RemoteConfigStatus remote_config_status = 7;
   */
  remoteConfigStatus?: RemoteConfigStatus;

  /**
   * The list of the Agent packages, including package statuses. This field SHOULD be
   * unset if this information is unchanged since the last AgentToServer message for
   * this Agent was sent in the stream.
   * Status: [Beta]
   *
   * @generated from field: opamp.proto.PackageStatuses package_statuses = 8;
   */
  packageStatuses?: PackageStatuses;

  /**
   * AgentDisconnect MUST be set in the last AgentToServer message sent from the
   * Agent to the Server.
   *
   * @generated from field: opamp.proto.AgentDisconnect agent_disconnect = 9;
   */
  agentDisconnect?: AgentDisconnect;

  /**
   * Bit flags as defined by AgentToServerFlags bit masks.
   *
   * @generated from field: uint64 flags = 10;
   */
  flags: bigint;

  /**
   * A request to create connection settings. This field is set for flows where
   * the Agent initiates the creation of connection settings.
   * Status: [Development]
   *
   * @generated from field: opamp.proto.ConnectionSettingsRequest connection_settings_request = 11;
   */
  connectionSettingsRequest?: ConnectionSettingsRequest;

  /**
   * A message indicating custom capabilities supported by the Agent.
   * Status: [Development]
   *
   * @generated from field: opamp.proto.CustomCapabilities custom_capabilities = 12;
   */
  customCapabilities?: CustomCapabilities;

  /**
   * A custom message sent from an Agent to the Server.
   * Status: [Development]
   *
   * @generated from field: opamp.proto.CustomMessage custom_message = 13;
   */
  customMessage?: CustomMessage;

  constructor(data?: PartialMessage<AgentToServer>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "opamp.proto.AgentToServer";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AgentToServer;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AgentToServer;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AgentToServer;

  static equals(a: AgentToServer | PlainMessage<AgentToServer> | undefined, b: AgentToServer | PlainMessage<AgentToServer> | undefined): boolean;
}

/**
 * AgentDisconnect is the last message sent from the Agent to the Server. The Server
 * SHOULD forget the association of the Agent instance with the message stream.
 *
 * If the message stream is closed in the transport layer then the Server SHOULD
 * forget association of all Agent instances that were previously established for
 * this message stream using AgentConnect message, even if the corresponding
 * AgentDisconnect message were not explicitly received from the Agent.
 *
 * @generated from message opamp.proto.AgentDisconnect
 */
export declare class AgentDisconnect extends Message<AgentDisconnect> {
  constructor(data?: PartialMessage<AgentDisconnect>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "opamp.proto.AgentDisconnect";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AgentDisconnect;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AgentDisconnect;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AgentDisconnect;

  static equals(a: AgentDisconnect | PlainMessage<AgentDisconnect> | undefined, b: AgentDisconnect | PlainMessage<AgentDisconnect> | undefined): boolean;
}

/**
 * ConnectionSettingsRequest is a request from the Agent to the Server to create
 * and respond with an offer of connection settings for the Agent.
 * Status: [Development]
 *
 * @generated from message opamp.proto.ConnectionSettingsRequest
 */
export declare class ConnectionSettingsRequest extends Message<ConnectionSettingsRequest> {
  /**
   * Request for OpAMP connection settings. If this field is unset
   * then the ConnectionSettingsRequest message is empty and is not actionable
   * for the Server.
   *
   * @generated from field: opamp.proto.OpAMPConnectionSettingsRequest opamp = 1;
   */
  opamp?: OpAMPConnectionSettingsRequest;

  constructor(data?: PartialMessage<ConnectionSettingsRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "opamp.proto.ConnectionSettingsRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConnectionSettingsRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConnectionSettingsRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConnectionSettingsRequest;

  static equals(a: ConnectionSettingsRequest | PlainMessage<ConnectionSettingsRequest> | undefined, b: ConnectionSettingsRequest | PlainMessage<ConnectionSettingsRequest> | undefined): boolean;
}

/**
 * OpAMPConnectionSettingsRequest is a request for the Server to produce
 * a OpAMPConnectionSettings in its response.
 * Status: [Development]
 *
 * @generated from message opamp.proto.OpAMPConnectionSettingsRequest
 */
export declare class OpAMPConnectionSettingsRequest extends Message<OpAMPConnectionSettingsRequest> {
  /**
   * A request to create a client certificate. This is used to initiate a
   * Client Signing Request (CSR) flow.
   * Required.
   *
   * @generated from field: opamp.proto.CertificateRequest certificate_request = 1;
   */
  certificateRequest?: CertificateRequest;

  constructor(data?: PartialMessage<OpAMPConnectionSettingsRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "opamp.proto.OpAMPConnectionSettingsRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OpAMPConnectionSettingsRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OpAMPConnectionSettingsRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OpAMPConnectionSettingsRequest;

  static equals(a: OpAMPConnectionSettingsRequest | PlainMessage<OpAMPConnectionSettingsRequest> | undefined, b: OpAMPConnectionSettingsRequest | PlainMessage<OpAMPConnectionSettingsRequest> | undefined): boolean;
}

/**
 * Status: [Development]
 *
 * @generated from message opamp.proto.CertificateRequest
 */
export declare class CertificateRequest extends Message<CertificateRequest> {
  /**
   * PEM-encoded Client Certificate Signing Request (CSR), signed by client's private key.
   * The Server SHOULD validate the request and SHOULD respond with a
   * OpAMPConnectionSettings where the certificate.public_key contains the issued
   * certificate.
   *
   * @generated from field: bytes csr = 1;
   */
  csr: Uint8Array;

  constructor(data?: PartialMessage<CertificateRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "opamp.proto.CertificateRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CertificateRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CertificateRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CertificateRequest;

  static equals(a: CertificateRequest | PlainMessage<CertificateRequest> | undefined, b: CertificateRequest | PlainMessage<CertificateRequest> | undefined): boolean;
}

/**
 * @generated from message opamp.proto.ServerToAgent
 */
export declare class ServerToAgent extends Message<ServerToAgent> {
  /**
   * Agent instance uid. MUST match the instance_uid field in AgentToServer message.
   * Used for multiplexing messages from/to multiple agents using one message stream.
   *
   * @generated from field: bytes instance_uid = 1;
   */
  instanceUid: Uint8Array;

  /**
   * error_response is set if the Server wants to indicate that something went wrong
   * during processing of an AgentToServer message. If error_response is set then
   * all other fields below must be unset and vice versa, if any of the fields below is
   * set then error_response must be unset.
   *
   * @generated from field: opamp.proto.ServerErrorResponse error_response = 2;
   */
  errorResponse?: ServerErrorResponse;

  /**
   * remote_config field is set when the Server has a remote config offer for the Agent.
   *
   * @generated from field: opamp.proto.AgentRemoteConfig remote_config = 3;
   */
  remoteConfig?: AgentRemoteConfig;

  /**
   * This field is set when the Server wants the Agent to change one or more
   * of its client connection settings (destination, headers, certificate, etc).
   * Status: [Beta]
   *
   * @generated from field: opamp.proto.ConnectionSettingsOffers connection_settings = 4;
   */
  connectionSettings?: ConnectionSettingsOffers;

  /**
   * This field is set when the Server has packages to offer to the Agent.
   * Status: [Beta]
   *
   * @generated from field: opamp.proto.PackagesAvailable packages_available = 5;
   */
  packagesAvailable?: PackagesAvailable;

  /**
   * Bit flags as defined by ServerToAgentFlags bit masks.
   *
   * @generated from field: uint64 flags = 6;
   */
  flags: bigint;

  /**
   * Bitmask of flags defined by ServerCapabilities enum.
   * All bits that are not defined in ServerCapabilities enum MUST be set to 0
   * by the Server. This allows extending the protocol and the ServerCapabilities
   * enum in the future such that old Servers automatically report that they
   * don't support the new capability.
   * This field MUST be set in the first ServerToAgent sent by the Server and MAY
   * be omitted in subsequent ServerToAgent messages by setting it to
   * UnspecifiedServerCapability value.
   *
   * @generated from field: uint64 capabilities = 7;
   */
  capabilities: bigint;

  /**
   * Properties related to identification of the Agent, which can be overridden
   * by the Server if needed.
   *
   * @generated from field: opamp.proto.AgentIdentification agent_identification = 8;
   */
  agentIdentification?: AgentIdentification;

  /**
   * Allows the Server to instruct the Agent to perform a command, e.g. RESTART. This field should not be specified
   * with fields other than instance_uid and capabilities. If specified, other fields will be ignored and the command
   * will be performed.
   * Status: [Beta]
   *
   * @generated from field: opamp.proto.ServerToAgentCommand command = 9;
   */
  command?: ServerToAgentCommand;

  /**
   * A message indicating custom capabilities supported by the Server.
   * Status: [Development]
   *
   * @generated from field: opamp.proto.CustomCapabilities custom_capabilities = 10;
   */
  customCapabilities?: CustomCapabilities;

  /**
   * A custom message sent from the Server to an Agent.
   * Status: [Development]
   *
   * @generated from field: opamp.proto.CustomMessage custom_message = 11;
   */
  customMessage?: CustomMessage;

  constructor(data?: PartialMessage<ServerToAgent>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "opamp.proto.ServerToAgent";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServerToAgent;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServerToAgent;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServerToAgent;

  static equals(a: ServerToAgent | PlainMessage<ServerToAgent> | undefined, b: ServerToAgent | PlainMessage<ServerToAgent> | undefined): boolean;
}

/**
 * The OpAMPConnectionSettings message is a collection of fields which comprise an
 * offer from the Server to the Agent to use the specified settings for OpAMP
 * connection.
 * Status: [Beta]
 *
 * @generated from message opamp.proto.OpAMPConnectionSettings
 */
export declare class OpAMPConnectionSettings extends Message<OpAMPConnectionSettings> {
  /**
   * OpAMP Server URL This MUST be a WebSocket or HTTP URL and MUST be non-empty, for
   * example: "wss://example.com:4318/v1/opamp"
   *
   * @generated from field: string destination_endpoint = 1;
   */
  destinationEndpoint: string;

  /**
   * Optional headers to use when connecting. Typically used to set access tokens or
   * other authorization headers. For HTTP-based protocols the Agent should
   * set these in the request headers.
   * For example:
   * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
   *
   * @generated from field: opamp.proto.Headers headers = 2;
   */
  headers?: Headers;

  /**
   * The Agent should use the offered certificate to connect to the destination
   * from now on. If the Agent is able to validate and connect using the offered
   * certificate the Agent SHOULD forget any previous client certificates
   * for this connection.
   * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
   * This field can be used to perform a client certificate revocation/rotation.
   *
   * @generated from field: opamp.proto.TLSCertificate certificate = 3;
   */
  certificate?: TLSCertificate;

  constructor(data?: PartialMessage<OpAMPConnectionSettings>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "opamp.proto.OpAMPConnectionSettings";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OpAMPConnectionSettings;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OpAMPConnectionSettings;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OpAMPConnectionSettings;

  static equals(a: OpAMPConnectionSettings | PlainMessage<OpAMPConnectionSettings> | undefined, b: OpAMPConnectionSettings | PlainMessage<OpAMPConnectionSettings> | undefined): boolean;
}

/**
 * The TelemetryConnectionSettings message is a collection of fields which comprise an
 * offer from the Server to the Agent to use the specified settings for a network
 * connection to report own telemetry.
 * Status: [Beta]
 *
 * @generated from message opamp.proto.TelemetryConnectionSettings
 */
export declare class TelemetryConnectionSettings extends Message<TelemetryConnectionSettings> {
  /**
   * The value MUST be a full URL an OTLP/HTTP/Protobuf receiver with path. Schema
   * SHOULD begin with "https://", for example "https://example.com:4318/v1/metrics"
   * The Agent MAY refuse to send the telemetry if the URL begins with "http://".
   *
   * @generated from field: string destination_endpoint = 1;
   */
  destinationEndpoint: string;

  /**
   * Optional headers to use when connecting. Typically used to set access tokens or
   * other authorization headers. For HTTP-based protocols the Agent should
   * set these in the request headers.
   * For example:
   * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
   *
   * @generated from field: opamp.proto.Headers headers = 2;
   */
  headers?: Headers;

  /**
   * The Agent should use the offered certificate to connect to the destination
   * from now on. If the Agent is able to validate and connect using the offered
   * certificate the Agent SHOULD forget any previous client certificates
   * for this connection.
   * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
   * This field can be used to perform a client certificate revocation/rotation.
   *
   * @generated from field: opamp.proto.TLSCertificate certificate = 3;
   */
  certificate?: TLSCertificate;

  constructor(data?: PartialMessage<TelemetryConnectionSettings>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "opamp.proto.TelemetryConnectionSettings";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TelemetryConnectionSettings;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TelemetryConnectionSettings;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TelemetryConnectionSettings;

  static equals(a: TelemetryConnectionSettings | PlainMessage<TelemetryConnectionSettings> | undefined, b: TelemetryConnectionSettings | PlainMessage<TelemetryConnectionSettings> | undefined): boolean;
}

/**
 * The OtherConnectionSettings message is a collection of fields which comprise an
 * offer from the Server to the Agent to use the specified settings for a network
 * connection. It is not required that all fields in this message are specified.
 * The Server may specify only some of the fields, in which case it means that
 * the Server offers the Agent to change only those fields, while keeping the
 * rest of the fields unchanged.
 *
 * For example the Server may send a ConnectionSettings message with only the
 * certificate field set, while all other fields are unset. This means that
 * the Server wants the Agent to use a new certificate and continue sending to
 * the destination it is currently sending using the current header and other
 * settings.
 *
 * For fields which reference other messages the field is considered unset
 * when the reference is unset.
 *
 * For primitive field (string) we rely on the "flags" to describe that the
 * field is not set (this is done to overcome the limitation of old protoc
 * compilers don't generate methods that allow to check for the presence of
 * the field.
 * Status: [Beta]
 *
 * @generated from message opamp.proto.OtherConnectionSettings
 */
export declare class OtherConnectionSettings extends Message<OtherConnectionSettings> {
  /**
   * A URL, host:port or some other destination specifier.
   *
   * @generated from field: string destination_endpoint = 1;
   */
  destinationEndpoint: string;

  /**
   * Optional headers to use when connecting. Typically used to set access tokens or
   * other authorization headers. For HTTP-based protocols the Agent should
   * set these in the request headers.
   * For example:
   * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
   *
   * @generated from field: opamp.proto.Headers headers = 2;
   */
  headers?: Headers;

  /**
   * The Agent should use the offered certificate to connect to the destination
   * from now on. If the Agent is able to validate and connect using the offered
   * certificate the Agent SHOULD forget any previous client certificates
   * for this connection.
   * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
   * This field can be used to perform a client certificate revocation/rotation.
   *
   * @generated from field: opamp.proto.TLSCertificate certificate = 3;
   */
  certificate?: TLSCertificate;

  /**
   * Other connection settings. These are Agent-specific and are up to the Agent
   * interpret.
   *
   * @generated from field: map<string, string> other_settings = 4;
   */
  otherSettings: { [key: string]: string };

  constructor(data?: PartialMessage<OtherConnectionSettings>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "opamp.proto.OtherConnectionSettings";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OtherConnectionSettings;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OtherConnectionSettings;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OtherConnectionSettings;

  static equals(a: OtherConnectionSettings | PlainMessage<OtherConnectionSettings> | undefined, b: OtherConnectionSettings | PlainMessage<OtherConnectionSettings> | undefined): boolean;
}

/**
 * Status: [Beta]
 *
 * @generated from message opamp.proto.Headers
 */
export declare class Headers extends Message<Headers> {
  /**
   * @generated from field: repeated opamp.proto.Header headers = 1;
   */
  headers: Header[];

  constructor(data?: PartialMessage<Headers>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "opamp.proto.Headers";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Headers;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Headers;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Headers;

  static equals(a: Headers | PlainMessage<Headers> | undefined, b: Headers | PlainMessage<Headers> | undefined): boolean;
}

/**
 * Status: [Beta]
 *
 * @generated from message opamp.proto.Header
 */
export declare class Header extends Message<Header> {
  /**
   * @generated from field: string key = 1;
   */
  key: string;

  /**
   * @generated from field: string value = 2;
   */
  value: string;

  constructor(data?: PartialMessage<Header>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "opamp.proto.Header";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Header;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Header;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Header;

  static equals(a: Header | PlainMessage<Header> | undefined, b: Header | PlainMessage<Header> | undefined): boolean;
}

/**
 * Status: [Beta]
 *
 * The (public_key,private_key) certificate pair should be issued and
 * signed by a Certificate Authority that the destination Server recognizes.
 *
 * It is highly recommended that the private key of the CA certificate is NOT
 * stored on the destination Server otherwise compromising the Server will allow
 * a malicious actor to issue valid Server certificates which will be automatically
 * trusted by all agents and will allow the actor to trivially MITM Agent-to-Server
 * traffic of all servers that use this CA certificate for their Server-side
 * certificates.
 *
 * Alternatively the certificate may be self-signed, assuming the Server can
 * verify the certificate.
 *
 * @generated from message opamp.proto.TLSCertificate
 */
export declare class TLSCertificate extends Message<TLSCertificate> {
  /**
   * PEM-encoded public key of the certificate. Required.
   *
   * @generated from field: bytes public_key = 1;
   */
  publicKey: Uint8Array;

  /**
   * PEM-encoded private key of the certificate. Required.
   *
   * @generated from field: bytes private_key = 2;
   */
  privateKey: Uint8Array;

  /**
   * PEM-encoded public key of the CA that signed this certificate.
   * Optional. MUST be specified if the certificate is CA-signed.
   * Can be stored by TLS-terminating intermediary proxies in order to verify
   * the connecting client's certificate in the future.
   * It is not recommended that the Agent accepts this CA as an authority for
   * any purposes.
   *
   * @generated from field: bytes ca_public_key = 3;
   */
  caPublicKey: Uint8Array;

  constructor(data?: PartialMessage<TLSCertificate>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "opamp.proto.TLSCertificate";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLSCertificate;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLSCertificate;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLSCertificate;

  static equals(a: TLSCertificate | PlainMessage<TLSCertificate> | undefined, b: TLSCertificate | PlainMessage<TLSCertificate> | undefined): boolean;
}

/**
 * Status: [Beta]
 *
 * @generated from message opamp.proto.ConnectionSettingsOffers
 */
export declare class ConnectionSettingsOffers extends Message<ConnectionSettingsOffers> {
  /**
   * Hash of all settings, including settings that may be omitted from this message
   * because they are unchanged.
   *
   * @generated from field: bytes hash = 1;
   */
  hash: Uint8Array;

  /**
   * Settings to connect to the OpAMP Server.
   * If this field is not set then the Agent should assume that the settings are
   * unchanged and should continue using existing settings.
   * The Agent MUST verify the offered connection settings by actually connecting
   * before accepting the setting to ensure it does not loose access to the OpAMP
   * Server due to invalid settings.
   *
   * @generated from field: opamp.proto.OpAMPConnectionSettings opamp = 2;
   */
  opamp?: OpAMPConnectionSettings;

  /**
   * Settings to connect to an OTLP metrics backend to send Agent's own metrics to.
   * If this field is not set then the Agent should assume that the settings
   * are unchanged.
   *
   * Once accepted the Agent should periodically send to the specified destination
   * its own metrics, i.e. metrics of the Agent process and any custom metrics that
   * describe the Agent state.
   *
   * All attributes specified in the identifying_attributes field in AgentDescription
   * message SHOULD be also specified in the Resource of the reported OTLP metrics.
   *
   * Attributes specified in the non_identifying_attributes field in
   * AgentDescription message may be also specified in the Resource of the reported
   * OTLP metrics, in which case they SHOULD have exactly the same values.
   *
   * Process metrics MUST follow the conventions for processes:
   * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/semantic_conventions/process-metrics.md
   *
   * @generated from field: opamp.proto.TelemetryConnectionSettings own_metrics = 3;
   */
  ownMetrics?: TelemetryConnectionSettings;

  /**
   * Similar to own_metrics, but for traces.
   *
   * @generated from field: opamp.proto.TelemetryConnectionSettings own_traces = 4;
   */
  ownTraces?: TelemetryConnectionSettings;

  /**
   * Similar to own_metrics, but for logs.
   *
   * @generated from field: opamp.proto.TelemetryConnectionSettings own_logs = 5;
   */
  ownLogs?: TelemetryConnectionSettings;

  /**
   * Another set of connection settings, with a string name associated with each.
   * How the Agent uses these is Agent-specific. Typically the name represents
   * the name of the destination to connect to (as it is known to the Agent).
   * If this field is not set then the Agent should assume that the other_connections
   * settings are unchanged.
   *
   * @generated from field: map<string, opamp.proto.OtherConnectionSettings> other_connections = 6;
   */
  otherConnections: { [key: string]: OtherConnectionSettings };

  constructor(data?: PartialMessage<ConnectionSettingsOffers>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "opamp.proto.ConnectionSettingsOffers";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConnectionSettingsOffers;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConnectionSettingsOffers;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConnectionSettingsOffers;

  static equals(a: ConnectionSettingsOffers | PlainMessage<ConnectionSettingsOffers> | undefined, b: ConnectionSettingsOffers | PlainMessage<ConnectionSettingsOffers> | undefined): boolean;
}

/**
 * List of packages that the Server offers to the Agent.
 * Status: [Beta]
 *
 * @generated from message opamp.proto.PackagesAvailable
 */
export declare class PackagesAvailable extends Message<PackagesAvailable> {
  /**
   * Map of packages. Keys are package names, values are the packages available for download.
   *
   * @generated from field: map<string, opamp.proto.PackageAvailable> packages = 1;
   */
  packages: { [key: string]: PackageAvailable };

  /**
   * Aggregate hash of all remotely installed packages. The Agent SHOULD include this
   * value in subsequent PackageStatuses messages. This in turn allows the management
   * Server to identify that a different set of packages is available for the Agent
   * and specify the available packages in the next ServerToAgent message.
   *
   * This field MUST be always set if the management Server supports packages
   * of agents.
   *
   * The hash is calculated as an aggregate of all packages names and content.
   *
   * @generated from field: bytes all_packages_hash = 2;
   */
  allPackagesHash: Uint8Array;

  constructor(data?: PartialMessage<PackagesAvailable>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "opamp.proto.PackagesAvailable";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PackagesAvailable;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PackagesAvailable;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PackagesAvailable;

  static equals(a: PackagesAvailable | PlainMessage<PackagesAvailable> | undefined, b: PackagesAvailable | PlainMessage<PackagesAvailable> | undefined): boolean;
}

/**
 * Each Agent is composed of one or more packages. A package has a name and
 * content stored in a file. The content of the files, functionality
 * provided by the packages, how they are stored and used by the Agent side is Agent
 * type-specific and is outside the concerns of the OpAMP protocol.
 *
 * If the Agent does not have an installed package with the specified name then
 * it SHOULD download it from the specified URL and install it.
 *
 * If the Agent already has an installed package with the specified name
 * but with a different hash then the Agent SHOULD download and
 * install the package again, since it is a different version of the same package.
 *
 * If the Agent has an installed package with the specified name and the same
 * hash then the Agent does not need to do anything, it already
 * has the right version of the package.
 * Status: [Beta]
 *
 * @generated from message opamp.proto.PackageAvailable
 */
export declare class PackageAvailable extends Message<PackageAvailable> {
  /**
   * @generated from field: opamp.proto.PackageType type = 1;
   */
  type: PackageType;

  /**
   * The package version that is available on the Server side. The Agent may for
   * example use this information to avoid downloading a package that was previously
   * already downloaded and failed to install.
   *
   * @generated from field: string version = 2;
   */
  version: string;

  /**
   * The downloadable file of the package.
   *
   * @generated from field: opamp.proto.DownloadableFile file = 3;
   */
  file?: DownloadableFile;

  /**
   * The hash of the package. SHOULD be calculated based on all other fields of the
   * PackageAvailable message and content of the file of the package. The hash is
   * used by the Agent to determine if the package it has is different from the
   * package the Server is offering.
   *
   * @generated from field: bytes hash = 4;
   */
  hash: Uint8Array;

  constructor(data?: PartialMessage<PackageAvailable>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "opamp.proto.PackageAvailable";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PackageAvailable;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PackageAvailable;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PackageAvailable;

  static equals(a: PackageAvailable | PlainMessage<PackageAvailable> | undefined, b: PackageAvailable | PlainMessage<PackageAvailable> | undefined): boolean;
}

/**
 * Status: [Beta]
 *
 * @generated from message opamp.proto.DownloadableFile
 */
export declare class DownloadableFile extends Message<DownloadableFile> {
  /**
   * The URL from which the file can be downloaded using HTTP GET request.
   * The Server at the specified URL SHOULD support range requests
   * to allow for resuming downloads.
   *
   * @generated from field: string download_url = 1;
   */
  downloadUrl: string;

  /**
   * The hash of the file content. Can be used by the Agent to verify that the file
   * was downloaded correctly.
   *
   * @generated from field: bytes content_hash = 2;
   */
  contentHash: Uint8Array;

  /**
   * Optional signature of the file content. Can be used by the Agent to verify the
   * authenticity of the downloaded file, for example can be the
   * [detached GPG signature](https://www.gnupg.org/gph/en/manual/x135.html#AEN160).
   * The exact signing and verification method is Agent specific. See
   * https://github.com/open-telemetry/opamp-spec/blob/main/specification.md#code-signing
   * for recommendations.
   *
   * @generated from field: bytes signature = 3;
   */
  signature: Uint8Array;

  constructor(data?: PartialMessage<DownloadableFile>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "opamp.proto.DownloadableFile";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DownloadableFile;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DownloadableFile;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DownloadableFile;

  static equals(a: DownloadableFile | PlainMessage<DownloadableFile> | undefined, b: DownloadableFile | PlainMessage<DownloadableFile> | undefined): boolean;
}

/**
 * @generated from message opamp.proto.ServerErrorResponse
 */
export declare class ServerErrorResponse extends Message<ServerErrorResponse> {
  /**
   * @generated from field: opamp.proto.ServerErrorResponseType type = 1;
   */
  type: ServerErrorResponseType;

  /**
   * Error message in the string form, typically human readable.
   *
   * @generated from field: string error_message = 2;
   */
  errorMessage: string;

  /**
   * @generated from oneof opamp.proto.ServerErrorResponse.Details
   */
  Details: {
    /**
     * Additional information about retrying if type==UNAVAILABLE.
     *
     * @generated from field: opamp.proto.RetryInfo retry_info = 3;
     */
    value: RetryInfo;
    case: "retryInfo";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<ServerErrorResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "opamp.proto.ServerErrorResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServerErrorResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServerErrorResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServerErrorResponse;

  static equals(a: ServerErrorResponse | PlainMessage<ServerErrorResponse> | undefined, b: ServerErrorResponse | PlainMessage<ServerErrorResponse> | undefined): boolean;
}

/**
 * @generated from message opamp.proto.RetryInfo
 */
export declare class RetryInfo extends Message<RetryInfo> {
  /**
   * @generated from field: uint64 retry_after_nanoseconds = 1;
   */
  retryAfterNanoseconds: bigint;

  constructor(data?: PartialMessage<RetryInfo>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "opamp.proto.RetryInfo";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RetryInfo;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RetryInfo;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RetryInfo;

  static equals(a: RetryInfo | PlainMessage<RetryInfo> | undefined, b: RetryInfo | PlainMessage<RetryInfo> | undefined): boolean;
}

/**
 * ServerToAgentCommand is sent from the Server to the Agent to request that the Agent
 * perform a command.
 * Status: [Beta]
 *
 * @generated from message opamp.proto.ServerToAgentCommand
 */
export declare class ServerToAgentCommand extends Message<ServerToAgentCommand> {
  /**
   * @generated from field: opamp.proto.CommandType type = 1;
   */
  type: CommandType;

  constructor(data?: PartialMessage<ServerToAgentCommand>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "opamp.proto.ServerToAgentCommand";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServerToAgentCommand;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServerToAgentCommand;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServerToAgentCommand;

  static equals(a: ServerToAgentCommand | PlainMessage<ServerToAgentCommand> | undefined, b: ServerToAgentCommand | PlainMessage<ServerToAgentCommand> | undefined): boolean;
}

/**
 * @generated from message opamp.proto.AgentDescription
 */
export declare class AgentDescription extends Message<AgentDescription> {
  /**
   * Attributes that identify the Agent.
   * Keys/values are according to OpenTelemetry semantic conventions, see:
   * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
   *
   * For standalone running Agents (such as OpenTelemetry Collector) the following
   * attributes SHOULD be specified:
   * - service.name should be set to a reverse FQDN that uniquely identifies the
   *   Agent type, e.g. "io.opentelemetry.collector"
   * - service.namespace if it is used in the environment where the Agent runs.
   * - service.version should be set to version number of the Agent build.
   * - service.instance.id should be set. It may be set equal to the Agent's
   *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
   *   that uniquely identifies the Agent in combination with other attributes.
   * - any other attributes that are necessary for uniquely identifying the Agent's
   *   own telemetry.
   *
   * The Agent SHOULD also include these attributes in the Resource of its own
   * telemetry. The combination of identifying attributes SHOULD be sufficient to
   * uniquely identify the Agent's own telemetry in the destination system to which
   * the Agent sends its own telemetry.
   *
   * @generated from field: repeated opamp.proto.KeyValue identifying_attributes = 1;
   */
  identifyingAttributes: KeyValue[];

  /**
   * Attributes that do not necessarily identify the Agent but help describe
   * where it runs.
   * The following attributes SHOULD be included:
   * - os.type, os.version - to describe where the Agent runs.
   * - host.* to describe the host the Agent runs on.
   * - cloud.* to describe the cloud where the host is located.
   * - any other relevant Resource attributes that describe this Agent and the
   *   environment it runs in.
   * - any user-defined attributes that the end user would like to associate
   *   with this Agent.
   *
   * @generated from field: repeated opamp.proto.KeyValue non_identifying_attributes = 2;
   */
  nonIdentifyingAttributes: KeyValue[];

  constructor(data?: PartialMessage<AgentDescription>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "opamp.proto.AgentDescription";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AgentDescription;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AgentDescription;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AgentDescription;

  static equals(a: AgentDescription | PlainMessage<AgentDescription> | undefined, b: AgentDescription | PlainMessage<AgentDescription> | undefined): boolean;
}

/**
 * The health of the Agent and sub-components
 * Status: [Beta]
 *
 * @generated from message opamp.proto.ComponentHealth
 */
export declare class ComponentHealth extends Message<ComponentHealth> {
  /**
   * Set to true if the component is up and healthy.
   *
   * @generated from field: bool healthy = 1;
   */
  healthy: boolean;

  /**
   * Timestamp since the component is up, i.e. when the component was started.
   * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
   * If the component is not running MUST be set to 0.
   *
   * @generated from field: fixed64 start_time_unix_nano = 2;
   */
  startTimeUnixNano: bigint;

  /**
   * Human-readable error message if the component is in erroneous state. SHOULD be set
   * when healthy==false.
   *
   * @generated from field: string last_error = 3;
   */
  lastError: string;

  /**
   * Component status represented as a string. The status values are defined by agent-specific
   * semantics and not at the protocol level.
   *
   * @generated from field: string status = 4;
   */
  status: string;

  /**
   * The time when the component status was observed. Value is UNIX Epoch time in
   * nanoseconds since 00:00:00 UTC on 1 January 1970.
   *
   * @generated from field: fixed64 status_time_unix_nano = 5;
   */
  statusTimeUnixNano: bigint;

  /**
   * A map to store more granular, sub-component health. It can nest as deeply as needed to
   * describe the underlying system.
   *
   * @generated from field: map<string, opamp.proto.ComponentHealth> component_health_map = 6;
   */
  componentHealthMap: { [key: string]: ComponentHealth };

  constructor(data?: PartialMessage<ComponentHealth>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "opamp.proto.ComponentHealth";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ComponentHealth;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ComponentHealth;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ComponentHealth;

  static equals(a: ComponentHealth | PlainMessage<ComponentHealth> | undefined, b: ComponentHealth | PlainMessage<ComponentHealth> | undefined): boolean;
}

/**
 * @generated from message opamp.proto.EffectiveConfig
 */
export declare class EffectiveConfig extends Message<EffectiveConfig> {
  /**
   * The effective config of the Agent.
   *
   * @generated from field: opamp.proto.AgentConfigMap config_map = 1;
   */
  configMap?: AgentConfigMap;

  constructor(data?: PartialMessage<EffectiveConfig>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "opamp.proto.EffectiveConfig";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EffectiveConfig;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EffectiveConfig;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EffectiveConfig;

  static equals(a: EffectiveConfig | PlainMessage<EffectiveConfig> | undefined, b: EffectiveConfig | PlainMessage<EffectiveConfig> | undefined): boolean;
}

/**
 * @generated from message opamp.proto.RemoteConfigStatus
 */
export declare class RemoteConfigStatus extends Message<RemoteConfigStatus> {
  /**
   * The hash of the remote config that was last received by this Agent in the
   * AgentRemoteConfig.config_hash field.
   * The Server SHOULD compare this hash with the config hash
   * it has for the Agent and if the hashes are different the Server MUST include
   * the remote_config field in the response in the ServerToAgent message.
   *
   * @generated from field: bytes last_remote_config_hash = 1;
   */
  lastRemoteConfigHash: Uint8Array;

  /**
   * @generated from field: opamp.proto.RemoteConfigStatuses status = 2;
   */
  status: RemoteConfigStatuses;

  /**
   * Optional error message if status==FAILED.
   *
   * @generated from field: string error_message = 3;
   */
  errorMessage: string;

  constructor(data?: PartialMessage<RemoteConfigStatus>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "opamp.proto.RemoteConfigStatus";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RemoteConfigStatus;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RemoteConfigStatus;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RemoteConfigStatus;

  static equals(a: RemoteConfigStatus | PlainMessage<RemoteConfigStatus> | undefined, b: RemoteConfigStatus | PlainMessage<RemoteConfigStatus> | undefined): boolean;
}

/**
 * The PackageStatuses message describes the status of all packages that the Agent
 * has or was offered.
 * Status: [Beta]
 *
 * @generated from message opamp.proto.PackageStatuses
 */
export declare class PackageStatuses extends Message<PackageStatuses> {
  /**
   * A map of PackageStatus messages, where the keys are package names.
   * The key MUST match the name field of PackageStatus message.
   *
   * @generated from field: map<string, opamp.proto.PackageStatus> packages = 1;
   */
  packages: { [key: string]: PackageStatus };

  /**
   * The aggregate hash of all packages that this Agent previously received from the
   * Server via PackagesAvailable message.
   *
   * The Server SHOULD compare this hash to the aggregate hash of all packages that
   * it has for this Agent and if the hashes are different the Server SHOULD send
   * an PackagesAvailable message to the Agent.
   *
   * @generated from field: bytes server_provided_all_packages_hash = 2;
   */
  serverProvidedAllPackagesHash: Uint8Array;

  /**
   * This field is set if the Agent encountered an error when processing the
   * PackagesAvailable message and that error is not related to any particular single
   * package.
   * The field must be unset is there were no processing errors.
   *
   * @generated from field: string error_message = 3;
   */
  errorMessage: string;

  constructor(data?: PartialMessage<PackageStatuses>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "opamp.proto.PackageStatuses";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PackageStatuses;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PackageStatuses;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PackageStatuses;

  static equals(a: PackageStatuses | PlainMessage<PackageStatuses> | undefined, b: PackageStatuses | PlainMessage<PackageStatuses> | undefined): boolean;
}

/**
 * The status of a single package.
 * Status: [Beta]
 *
 * @generated from message opamp.proto.PackageStatus
 */
export declare class PackageStatus extends Message<PackageStatus> {
  /**
   * Package name. MUST be always set and MUST match the key in the packages field
   * of PackageStatuses message.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The version of the package that the Agent has.
   * MUST be set if the Agent has this package.
   * MUST be empty if the Agent does not have this package. This may be the case
   * for example if the package was offered by the Server but failed to install
   * and the Agent did not have this package previously.
   *
   * @generated from field: string agent_has_version = 2;
   */
  agentHasVersion: string;

  /**
   * The hash of the package that the Agent has.
   * MUST be set if the Agent has this package.
   * MUST be empty if the Agent does not have this package. This may be the case for
   * example if the package was offered by the Server but failed to install and the
   * Agent did not have this package previously.
   *
   * @generated from field: bytes agent_has_hash = 3;
   */
  agentHasHash: Uint8Array;

  /**
   * The version of the package that the Server offered to the Agent.
   * MUST be set if the installation of the package is initiated by an earlier offer
   * from the Server to install this package.
   *
   * MUST be empty if the Agent has this package but it was installed locally and
   * was not offered by the Server.
   *
   * Note that it is possible for both agent_has_version and server_offered_version
   * fields to be set and to have different values. This is for example possible if
   * the Agent already has a version of the package successfully installed, the Server
   * offers a different version, but the Agent fails to install that version.
   *
   * @generated from field: string server_offered_version = 4;
   */
  serverOfferedVersion: string;

  /**
   * The hash of the package that the Server offered to the Agent.
   * MUST be set if the installation of the package is initiated by an earlier
   * offer from the Server to install this package.
   *
   * MUST be empty if the Agent has this package but it was installed locally and
   * was not offered by the Server.
   *
   * Note that it is possible for both agent_has_hash and server_offered_hash
   * fields to be set and to have different values. This is for example possible if
   * the Agent already has a version of the package successfully installed, the
   * Server offers a different version, but the Agent fails to install that version.
   *
   * @generated from field: bytes server_offered_hash = 5;
   */
  serverOfferedHash: Uint8Array;

  /**
   * @generated from field: opamp.proto.PackageStatusEnum status = 6;
   */
  status: PackageStatusEnum;

  /**
   * Error message if the status is erroneous.
   *
   * @generated from field: string error_message = 7;
   */
  errorMessage: string;

  constructor(data?: PartialMessage<PackageStatus>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "opamp.proto.PackageStatus";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PackageStatus;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PackageStatus;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PackageStatus;

  static equals(a: PackageStatus | PlainMessage<PackageStatus> | undefined, b: PackageStatus | PlainMessage<PackageStatus> | undefined): boolean;
}

/**
 * Properties related to identification of the Agent, which can be overridden
 * by the Server if needed
 *
 * @generated from message opamp.proto.AgentIdentification
 */
export declare class AgentIdentification extends Message<AgentIdentification> {
  /**
   * When new_instance_uid is set, Agent MUST update instance_uid
   * to the value provided and use it for all further communication.
   * MUST be 16 bytes long and SHOULD be generated using the UUID v7 spec.
   *
   * @generated from field: bytes new_instance_uid = 1;
   */
  newInstanceUid: Uint8Array;

  constructor(data?: PartialMessage<AgentIdentification>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "opamp.proto.AgentIdentification";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AgentIdentification;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AgentIdentification;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AgentIdentification;

  static equals(a: AgentIdentification | PlainMessage<AgentIdentification> | undefined, b: AgentIdentification | PlainMessage<AgentIdentification> | undefined): boolean;
}

/**
 * @generated from message opamp.proto.AgentRemoteConfig
 */
export declare class AgentRemoteConfig extends Message<AgentRemoteConfig> {
  /**
   * Agent config offered by the management Server to the Agent instance. SHOULD NOT be
   * set if the config for this Agent has not changed since it was last requested (i.e.
   * AgentConfigRequest.last_remote_config_hash field is equal to
   * AgentConfigResponse.config_hash field).
   *
   * @generated from field: opamp.proto.AgentConfigMap config = 1;
   */
  config?: AgentConfigMap;

  /**
   * Hash of "config". The Agent SHOULD include this value in subsequent
   * RemoteConfigStatus messages in the last_remote_config_hash field. This in turn
   * allows the management Server to identify that a new config is available for the Agent.
   *
   * This field MUST be always set if the management Server supports remote configuration
   * of agents.
   *
   * Management Server must choose a hashing function that guarantees lack of hash
   * collisions in practice.
   *
   * @generated from field: bytes config_hash = 2;
   */
  configHash: Uint8Array;

  constructor(data?: PartialMessage<AgentRemoteConfig>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "opamp.proto.AgentRemoteConfig";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AgentRemoteConfig;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AgentRemoteConfig;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AgentRemoteConfig;

  static equals(a: AgentRemoteConfig | PlainMessage<AgentRemoteConfig> | undefined, b: AgentRemoteConfig | PlainMessage<AgentRemoteConfig> | undefined): boolean;
}

/**
 * @generated from message opamp.proto.AgentConfigMap
 */
export declare class AgentConfigMap extends Message<AgentConfigMap> {
  /**
   * Map of configs. Keys are config file names or config section names.
   * The configuration is assumed to be a collection of one or more named config files
   * or sections.
   * For agents that use a single config file or section the map SHOULD contain a single
   * entry and the key may be an empty string.
   *
   * @generated from field: map<string, opamp.proto.AgentConfigFile> config_map = 1;
   */
  configMap: { [key: string]: AgentConfigFile };

  constructor(data?: PartialMessage<AgentConfigMap>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "opamp.proto.AgentConfigMap";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AgentConfigMap;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AgentConfigMap;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AgentConfigMap;

  static equals(a: AgentConfigMap | PlainMessage<AgentConfigMap> | undefined, b: AgentConfigMap | PlainMessage<AgentConfigMap> | undefined): boolean;
}

/**
 * @generated from message opamp.proto.AgentConfigFile
 */
export declare class AgentConfigFile extends Message<AgentConfigFile> {
  /**
   * Config file or section body. The content, format and encoding depends on the Agent
   * type. The content_type field may optionally describe the MIME type of the body.
   *
   * @generated from field: bytes body = 1;
   */
  body: Uint8Array;

  /**
   * Optional MIME Content-Type that describes what's in the body field, for
   * example "text/yaml".
   *
   * @generated from field: string content_type = 2;
   */
  contentType: string;

  constructor(data?: PartialMessage<AgentConfigFile>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "opamp.proto.AgentConfigFile";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AgentConfigFile;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AgentConfigFile;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AgentConfigFile;

  static equals(a: AgentConfigFile | PlainMessage<AgentConfigFile> | undefined, b: AgentConfigFile | PlainMessage<AgentConfigFile> | undefined): boolean;
}

/**
 * @generated from message opamp.proto.CustomCapabilities
 */
export declare class CustomCapabilities extends Message<CustomCapabilities> {
  /**
   * A list of custom capabilities that are supported. Each capability is a reverse FQDN
   * with optional version information that uniquely identifies the custom capability
   * and should match a capability specified in a supported CustomMessage.
   * Status: [Development]
   *
   * @generated from field: repeated string capabilities = 1;
   */
  capabilities: string[];

  constructor(data?: PartialMessage<CustomCapabilities>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "opamp.proto.CustomCapabilities";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CustomCapabilities;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CustomCapabilities;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CustomCapabilities;

  static equals(a: CustomCapabilities | PlainMessage<CustomCapabilities> | undefined, b: CustomCapabilities | PlainMessage<CustomCapabilities> | undefined): boolean;
}

/**
 * @generated from message opamp.proto.CustomMessage
 */
export declare class CustomMessage extends Message<CustomMessage> {
  /**
   * A reverse FQDN that uniquely identifies the capability and matches one of the
   * capabilities in the CustomCapabilities message.
   * Status: [Development]
   *
   * @generated from field: string capability = 1;
   */
  capability: string;

  /**
   * Type of message within the capability. The capability defines the types of custom
   * messages that are used to implement the capability. The type must only be unique
   * within the capability.
   * Status: [Development]
   *
   * @generated from field: string type = 2;
   */
  type: string;

  /**
   * Binary data of the message. The capability must specify the format of the contents
   * of the data for each custom message type it defines.
   * Status: [Development]
   *
   * @generated from field: bytes data = 3;
   */
  data: Uint8Array;

  constructor(data?: PartialMessage<CustomMessage>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "opamp.proto.CustomMessage";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CustomMessage;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CustomMessage;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CustomMessage;

  static equals(a: CustomMessage | PlainMessage<CustomMessage> | undefined, b: CustomMessage | PlainMessage<CustomMessage> | undefined): boolean;
}


#!/bin/bash

set -e

# Get the latest tag
LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
echo "Latest tag: $LATEST_TAG"

# Check if there are any commits since the last tag
COMMITS_SINCE_TAG=$(git log --oneline $LATEST_TAG..HEAD | wc -l)

if [ "$COMMITS_SINCE_TAG" -eq 0 ]; then
    echo "No changes since $LATEST_TAG. Skipping release PR creation."
    exit 0
fi

echo "Found $COMMITS_SINCE_TAG commits since $LATEST_TAG"

# Calculate next version
VERSION_WITHOUT_V=${LATEST_TAG#v}
IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION_WITHOUT_V"
NEW_PATCH=$((PATCH + 1))
NEXT_VERSION="v$MAJOR.$MINOR.$NEW_PATCH"

echo "Next version: $NEXT_VERSION"

# Check if a release PR already exists
EXISTING_PR=$(gh pr list --head "release/$NEXT_VERSION" --json number --jq '.[0].number' 2>/dev/null || echo "")

# Generate changelog
CHANGELOG=$(git log --oneline --no-merges $LATEST_TAG..HEAD | sed 's/^/- /')

# Create PR title and body
PR_TITLE="Release $NEXT_VERSION"
PR_BODY="## Release $NEXT_VERSION

This PR will create a new release tag \`$NEXT_VERSION\` when merged.

### Changes since $LATEST_TAG ($COMMITS_SINCE_TAG commits)

$CHANGELOG

### Checklist
- [ ] All tests pass
- [ ] Documentation is updated
- [ ] Release notes are ready

### Auto-generated by GitHub Actions
This PR was automatically created by the release workflow."

if [ -n "$EXISTING_PR" ]; then
    echo "Updating existing release PR #$EXISTING_PR"
    gh pr edit $EXISTING_PR --title "$PR_TITLE" --body "$PR_BODY"
else
    echo "Creating new release PR for $NEXT_VERSION"
    git checkout -b "release/$NEXT_VERSION"
    git push origin "release/$NEXT_VERSION"
    gh pr create --title "$PR_TITLE" --body "$PR_BODY" --base main --head "release/$NEXT_VERSION" --label "release" --label "automated"
fi 
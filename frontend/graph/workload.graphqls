
# each workload in k8s is uniquly identified by it's namespace, resource kind and resource name.
type K8sWorkloadId {
  namespace: String!
  kind: K8sResourceKind!
  name: String!
}

# filter for workloads.
# workload querties can be expensive and resource intensive,
# so we provide a filter to reduce the scope of the query to just what actually needed.
# each empty value means no filter for that field.
# for example, if namespace is not empty and other fields are, it will return all sources in the namespace.
input WorkloadFilter {
  namespace: String
  workloadKind: K8sResourceKind
  workloadName: String
  markedForInstrumentation: Boolean
}

type DesiredConditionStatus {

  # name of the condition, in lowercase with spaces ("runtime detection", "agent enabled", etc.)
  name: String!

  # shows if the actual state of the condition vs the desired state.
  status: DesiredStateProgress!

  # reasonEnum is a String, out of close set of enum values per condition type.
  reasonEnum: String

  # message is a human readable, high cardinality, free form text,
  # that describes the status for this condition.
  # it is used to provide additional context for the status.
  message: String!
}

type K8sWorkloadMakredForInstrumentation {

  # markedForInstrumentation is the reconciled decision for this source.
  # a source can be marked or unmakred for instrumentation due to the presence
  # of Source CR, there can be workload sources and namespace sources.
  markedForInstrumentation: Boolean!

  # decisionEnum is a String, out of close set of enum values, 
  # that describes the reason for the markedForInstrumentation value
  decisionEnum: String!

  # the message is a human readable, high cardinality, free form text,
  # that describes the reason for the markedForInstrumentation value.
  # it is used to provide additional context for the decision.
  message: String!

  # TODO: add "Source" info here.
}

type EnvVar {
  name: String!
  value: String!
}

type K8sWorkloadRuntimeInfoContainer {
  # the name of the container in the pod manifest.
  containerName: String!

  # the programming language of the container.
  language: ProgrammingLanguage!

  # the runtime version of the container, or empty if not found.
  # odigos has a heuristic approch and is not guaranteed to always find the runtime version.
  runtimeVersion: String

  # the environment variables that are relevant for odigos injection,
  # as seen in the process environment (read from "/proc/N/environ")
  processEnvVars: [EnvVar!]!

  # relevant odigos environment variables that are set by container runtime (for example, set as ENV layer in Dockerfile)
  # if a relevant env is set in the container runtime, it is set here.
  # there are some rare cases where value can be set in this list but not comming from container runtime.
  containerRuntimeEnvVars: [EnvVar!]

  # if there was any cri error, the containerRuntimeEnvVars will be empty, 
  # criErrorMessage will be set to the error message, and containerRuntimeEnvVars is unknown.
  criErrorMessage: String

  # the libc type of the container, or empty if not found.
  # values are "glibc" or "musl"
  libcType: String

  # if the container is running in secure execution mode or not.
  # if empty, the detection could not be completed.
  secureExecutionMode: Boolean

  # if other instrumentation agent is detected to run in the container,
  # this will be the name of the detected agent.
  # will be empty most of the times, when no other agent is detected in the container.
  otherAgentName: String
}

type K8sWorkloadRuntimeInfo {

  # completed is true if the runtime info has been calculated for the source.
  completed: Boolean!

  # the status of the runtime info detection process.
  completedStatus: DesiredConditionStatus!

  # containers is a list of containers that are part of the source.
  # it contains the runtime info for each container.
  # all containers are always included.
  containers: [K8sWorkloadRuntimeInfoContainer!]
}

type DistroParam {
  key: String!
  value: String!
}

# currently empty, will be populated in the future.
type K8sWorkloadAgentEnabledContainerTraces {
  enabled: Boolean!
}

# currently empty, will be populated in the future.
type K8sWorkloadAgentEnabledContainerMetrics {
  enabled: Boolean!
}

# currently empty, will be populated in the future.
type K8sWorkloadAgentEnabledContainerLogs {
  enabled: Boolean!
}

# describes the agent enabled info for a container.
type K8sWorkloadAgentEnabledContainer {
  # the name of the container in the pod manifest.
  containerName: String!

  # if an agent is enabled for this container.
  agentEnabled: Boolean!

  # the status info of the agentEnabled decision for this container.
  agentEnabledStatus: DesiredConditionStatus!

  # the otel distro name that is used for this container.
  otelDistroName: String

  # the env injection method that is used for this container.
  # it can have 3 values:
  # - "loader": inject the LD_PRELOAD env var to the pod manifest which will trigger the odigos loader.
  # - "pod-manifest": inject the runtime specific agent loading env vars (e.g PYTHONPATH, NODE_OPTIONS) to the pod manifest as specified in the distro manifest.
  # - "loader-fallback-to-pod-manifest" - it means we tried LD_PRELOAD and it failed, so we falled-back to using the pod manifest.
  envInjectionMethod: String

  # the distro params that are used for this container.
  distroParams: [DistroParam!]

  # if traces are enabled for this container, this field will be populated.
  traces: K8sWorkloadAgentEnabledContainerTraces

  # if metrics are enabled for this container, this field will be populated.
  metrics: K8sWorkloadAgentEnabledContainerMetrics

  # if logs are enabled for this container, this field will be populated.
  logs: K8sWorkloadAgentEnabledContainerLogs
}

# agentEnabled is the reconciled decision for odigos if an agent should be injected into the source pods.
# it is based on the runtimeInfo and additional configurations (instrumentation rules, odigos config, agent manifests)
# enabling the agent means that odigos is attempting to initiate instrumentation for the source.
# pods for this workload are expected to have the agent injected, but it is not guaranteed.
# only the actual state on each pod describe if the agent was indeed injected or not.
type K8sWorkloadAgentEnabled {

  # when enabled is true, odigos will attempt to inject the agent 
  # into relevant containers of future new pods from this source.
  # this value is true when at least one container is enabled.
  # to view the detailed decision for each container, see the containers field.
  agentEnabled: Boolean!

  # the status of the agentEnabled decision.
  enabledStatus: DesiredConditionStatus!

  # containers is a list of containers that are part of the source.
  # it contains the agentEnabled decision for each container.
  # all containers are always included, even if the agent is not enabled for them for any reason.
  containers: [K8sWorkloadAgentEnabledContainer!]
}

type K8sWorkloadRollout {
    # the status of the rollout. that is being tracked by odigos.
    rolloutStatus: DesiredConditionStatus!
}

type K8sWorkloadContainerOverrides {
  containerName: String!

  # RuntimeInfo to use for agent enabling.
	# If not null, the automatic detection will not be used for this container,
	# and the distro to use will be calculated based on this value instead.
  # this value is expected to be null most of the times, and only used in rare cases.
  runtimeInfo: K8sWorkloadRuntimeInfoContainer
}

# show all info for a specific source container.
type K8sWorkloadContainer {
  containerName: String!

  # status of the runtime info detection for this container.
  runtimeInfo: K8sWorkloadRuntimeInfoContainer

  # status of the agent injection enabled decision for this container.
  agentEnabled: K8sWorkloadAgentEnabledContainer

  # manunal overrides for this container info, to set specific values for it or bypass failed detection.
  overrides: K8sWorkloadContainerOverrides
}

type K8sWorkloadPodContainerProcessAttribute {
    key: String!
    value: String!
}

type K8sWorkloadPodContainerProcess {

    # if the agent instrumenting this process is reporting healthy or not.
    # if the agent is still starting up, this will be empty.
    healthy: Boolean

    # the status of the health of the process.
    healthStatus: DesiredConditionStatus!

    # attributes are key value pairs that are reported as part of this process resource attributes in telemetry.
    # it contains just some of the attributes and may not be complete.
    identifyingAttributes: [K8sWorkloadPodContainerProcessAttribute!]!
}

type K8sWorkloadPodContainer {
    # the name of the container in the pod manifest.
    containerName: String!

    # if this container is using an instrumentation device, this will be set to the device name.
    instrumentationDeviceName: String

    # if the container is marked as started in k8s.
    started: Boolean

    # if the container is marked as ready in k8s.
    ready: Boolean

    # if the container is in crash loop back off.
    isCrashLoop: Boolean

    # the number of times the container has restarted.
    restartCount: Int

    # the time the container started running (on restarts, this will be the time of the first restart).
    # if pod is not running, this will be null.
    runningStartedTime: String

    # if the container is in state waiting, this will be the reason and message from k8s for the status.
    waitingReasonEnum: String
    waitingMessage: String

    # the status of the health of the container itself, which is not directly related to the agent and instrumentation.
    # it tracks the started, ready, and crash loop back off and present a unified status to show container health.
    healthStatus: DesiredConditionStatus!

    processes: [K8sWorkloadPodContainerProcess!]!
}

type K8sWorkloadPod {
  # the name of the pod resource in k8s.
  podName: String!

  # the name of the node that the pod is running on.
  nodeName: String!

  startTime: String!

  # if the agent is injected into the pod.
  # agent injection is decided at pod creation time, 
  # and depends on the agentEnabled decision for the source 
  # and the availability of the instrumentor webhook to handle requests.
  agentInjected: Boolean!

  # the status of the agentInjected decision.
  # this status is not a condition on a resource, it's a calculated value based on the observed state of the pod.
  # it is used to track if the agent injected state is as desired, or if there are any issues.
  agentInjectedStatus: DesiredConditionStatus!

  # during rollout, pods can be running more than one revision of the workload.
  # this value indicates if a specific pod is running the latest revision of the workload.
  runningLatestWorkloadRevision: String

  # the general health of the pod containers, as one aggregated status for all containers.
  podHealthStatus: DesiredConditionStatus!

  # all containers that are part of the pod.
  # all containers are always included, even if the agent is not enabled for them for any reason.
  containers: [K8sWorkloadPodContainer!]!
}

type K8sWorkloadTelemetryMetricsExpectingTelemetryStatus {

  # indicate whether the source is expected to generate telemetry.
  # this value is calculated based on the source's actual instrumentation process.
  # it is not a guarantee that the source will generate telemetry, but it's a good indicator.
  isExpectingTelemetry: Boolean

  # the status of the telemetry observed
  # this status will indicate any issues, if telemetry is expected but not observed.
  telemetryObservedStatus: DesiredConditionStatus!
}

type K8sWorkloadTelemetryMetrics {

  # total bytes sent by this source, counted from when ui pod started running.
  # when the value is null, no telemetry data was observed yet for this source.
  # this value shows the amount from an arbitrary point in time, and thus the exact value is not important on it's own.
  # when it's != 0, it means the source is observed to be generating telemetry.
  # it might be 0 or null even when the source is generating telemetry, if:
  # - the ui pod just started running.
  # - the source is generating telemetry once in a while, and the ui pod did not record it yet.
  # - bug or connectivity issue in the own-telemetry collection mechanism.
  #
  # use this value with caution, and take the above into account.
  totalDataSentBytes: Int

  # the current throughput of the source, counted over a timespan of 20 seconds 
  # (or as configured in the node collector).
  # when the value is null, no telemetry data was observed yet for this source.
  # when this value is != 0, it means the source is observed to be generating telemetry.
  # when it's 0 or null, it's likely that the source is not generating telemetry.
  # this value might not be accurate when:
  # - the ui pod just started running.
  # - the source just started running, and did not participate in the telemetry collection yet (20 seconds cycle)
  # - the source pods does not have traffic at the moment (thus no telemetry is generated)
  # - bug or connectivity issue in the own-telemetry collection mechanism.
  #
  # use this value with caution, and take the above into account.
  throughputBytes: Int

  # the status of the expectingTelemetry decision.
  # this status is not a condition on a resource, it's a calculated value based on the observed state of the source.
  # it is used to track if the expectingTelemetry state is as desired, or if there are any issues.
  expectingTelemetry: K8sWorkloadTelemetryMetricsExpectingTelemetryStatus!
}

type K8sWorkload {
  id: K8sWorkloadId!

  # this field is an aggregated status for the odigos health of the workload.
  # it examine all related odigos values to determine if the workload is in it's desired odigos state, 
  # and will indicate any odigos related errors or progress related to this workload.
  # the goal is to have one single property to exaimne and get an overall view for a workload.
  workloadOdigosHealthStatus: DesiredConditionStatus!

  markedForInstrumentation: K8sWorkloadMakredForInstrumentation!

  # runtimeInfo is empty if source is not marked for instrumentation,
  # or if the source has not been processed by odigos yet.
  # once a source that is makred for instrumentation is processed, this field will be set.
  runtimeInfo: K8sWorkloadRuntimeInfo

  agentEnabled: K8sWorkloadAgentEnabled

  rollout: K8sWorkloadRollout

  # show all info for a specific source container.
  containers: [K8sWorkloadContainer!]

  # show all info for all pods that are part of the workload.
  # all pods are always included, even if the agent is not enabled for them for any reason.
  pods: [K8sWorkloadPod!]

  # track the aggregated status of all the agent injection decisions for all pods of this workload.
  # any pod which isn't matching it's agent injection desired status will be reflected in this value.
  podsAgentInjectionStatus: DesiredConditionStatus!

  # aggregated value for the health of all pods in the workload.
  # this value is the general health of the workload, and issues here may not be related to odigos.
  podsHealthStatus: DesiredConditionStatus!

  # the telemetry metrics for this source 
  # e.g. how much data is generate from this source as counted in the node collector.
  telemetryMetrics: [K8sWorkloadTelemetryMetrics!]!
}

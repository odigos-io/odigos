// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

type Action interface {
	IsAction()
	GetID() string
	GetType() string
	GetName() *string
	GetNotes() *string
	GetDisable() bool
	GetSignals() []SignalType
}

type ActionInput struct {
	Type    string       `json:"type"`
	Name    *string      `json:"name,omitempty"`
	Notes   *string      `json:"notes,omitempty"`
	Disable bool         `json:"disable"`
	Signals []SignalType `json:"signals"`
	Details string       `json:"details"`
}

type AddClusterInfoAction struct {
	ID      string         `json:"id"`
	Type    string         `json:"type"`
	Name    *string        `json:"name,omitempty"`
	Notes   *string        `json:"notes,omitempty"`
	Disable bool           `json:"disable"`
	Signals []SignalType   `json:"signals"`
	Details []*ClusterInfo `json:"details"`
}

func (AddClusterInfoAction) IsAction()              {}
func (this AddClusterInfoAction) GetID() string     { return this.ID }
func (this AddClusterInfoAction) GetType() string   { return this.Type }
func (this AddClusterInfoAction) GetName() *string  { return this.Name }
func (this AddClusterInfoAction) GetNotes() *string { return this.Notes }
func (this AddClusterInfoAction) GetDisable() bool  { return this.Disable }
func (this AddClusterInfoAction) GetSignals() []SignalType {
	if this.Signals == nil {
		return nil
	}
	interfaceSlice := make([]SignalType, 0, len(this.Signals))
	for _, concrete := range this.Signals {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type APIToken struct {
	Token     string `json:"token"`
	Name      string `json:"name"`
	IssuedAt  int    `json:"issuedAt"`
	ExpiresAt int    `json:"expiresAt"`
}

type AttributeFilters struct {
	ServiceName           string                     `json:"serviceName"`
	AttributeKey          string                     `json:"attributeKey"`
	FallbackSamplingRatio float64                    `json:"fallbackSamplingRatio"`
	Condition             *AttributeFiltersCondition `json:"condition"`
}

type AttributeFiltersCondition struct {
	StringCondition  *StringCondition  `json:"stringCondition,omitempty"`
	NumberCondition  *NumberCondition  `json:"numberCondition,omitempty"`
	BooleanCondition *BooleanCondition `json:"booleanCondition,omitempty"`
	JSONCondition    *JSONCondition    `json:"jsonCondition,omitempty"`
}

type BooleanCondition struct {
	Operation     BooleanOperation `json:"operation"`
	ExpectedValue bool             `json:"expectedValue"`
}

type ClusterCollectorAnalyze struct {
	Enabled              *EntityProperty `json:"enabled"`
	CollectorGroup       *EntityProperty `json:"collectorGroup"`
	Deployed             *EntityProperty `json:"deployed,omitempty"`
	DeployedError        *EntityProperty `json:"deployedError,omitempty"`
	CollectorReady       *EntityProperty `json:"collectorReady,omitempty"`
	DeploymentCreated    *EntityProperty `json:"deploymentCreated"`
	ExpectedReplicas     *EntityProperty `json:"expectedReplicas,omitempty"`
	HealthyReplicas      *EntityProperty `json:"healthyReplicas,omitempty"`
	FailedReplicas       *EntityProperty `json:"failedReplicas,omitempty"`
	FailedReplicasReason *EntityProperty `json:"failedReplicasReason,omitempty"`
}

type ClusterInfo struct {
	AttributeName        string  `json:"attributeName"`
	AttributeStringValue *string `json:"attributeStringValue,omitempty"`
}

type CodeAttributes struct {
	Column     *bool `json:"column,omitempty"`
	FilePath   *bool `json:"filePath,omitempty"`
	Function   *bool `json:"function,omitempty"`
	LineNumber *bool `json:"lineNumber,omitempty"`
	Namespace  *bool `json:"namespace,omitempty"`
	Stacktrace *bool `json:"stacktrace,omitempty"`
}

type CodeAttributesInput struct {
	Column     *bool `json:"column,omitempty"`
	FilePath   *bool `json:"filePath,omitempty"`
	Function   *bool `json:"function,omitempty"`
	LineNumber *bool `json:"lineNumber,omitempty"`
	Namespace  *bool `json:"namespace,omitempty"`
	Stacktrace *bool `json:"stacktrace,omitempty"`
}

type ComputePlatform struct {
	ComputePlatformType  ComputePlatformType    `json:"computePlatformType"`
	APITokens            []*APIToken            `json:"apiTokens"`
	K8sActualNamespaces  []*K8sActualNamespace  `json:"k8sActualNamespaces"`
	K8sActualNamespace   *K8sActualNamespace    `json:"k8sActualNamespace,omitempty"`
	Sources              *PaginatedSources      `json:"sources"`
	Source               *K8sActualSource       `json:"source"`
	Destinations         []*Destination         `json:"destinations"`
	Actions              []*PipelineAction      `json:"actions"`
	InstrumentationRules []*InstrumentationRule `json:"instrumentationRules"`
	DataStreams          []*DataStream          `json:"dataStreams"`
}

type Condition struct {
	Status             ConditionStatus `json:"status"`
	Type               string          `json:"type"`
	Reason             *string         `json:"reason,omitempty"`
	Message            *string         `json:"message,omitempty"`
	LastTransitionTime *string         `json:"lastTransitionTime,omitempty"`
}

type ContainerAgentConfigAnalyze struct {
	ContainerName  *EntityProperty `json:"containerName"`
	AgentEnabled   *EntityProperty `json:"agentEnabled"`
	Reason         *EntityProperty `json:"reason,omitempty"`
	Message        *EntityProperty `json:"message,omitempty"`
	OtelDistroName *EntityProperty `json:"otelDistroName,omitempty"`
}

type ContainerRuntimeInfoAnalyze struct {
	ContainerName  *EntityProperty   `json:"containerName"`
	Language       *EntityProperty   `json:"language"`
	RuntimeVersion *EntityProperty   `json:"runtimeVersion"`
	EnvVars        []*EntityProperty `json:"envVars"`
}

type CustomInstrumentations struct {
	Probes []*Probe `json:"probes,omitempty"`
}

type CustomInstrumentationsInput struct {
	Probes []*ProbeInput `json:"probes,omitempty"`
}

type CustomReadDataLabel struct {
	Condition string `json:"condition"`
	Title     string `json:"title"`
	Value     string `json:"value"`
}

type DataStream struct {
	Name string `json:"name"`
}

type DataStreamInput struct {
	Name string `json:"name"`
}

type DbQueryPayloadCollection struct {
	MaxPayloadLength    *int  `json:"maxPayloadLength,omitempty"`
	DropPartialPayloads *bool `json:"dropPartialPayloads,omitempty"`
}

type DbQueryPayloadCollectionInput struct {
	MaxPayloadLength    *int  `json:"maxPayloadLength,omitempty"`
	DropPartialPayloads *bool `json:"dropPartialPayloads,omitempty"`
}

type DeleteAttributeAction struct {
	ID      string       `json:"id"`
	Type    string       `json:"type"`
	Name    *string      `json:"name,omitempty"`
	Notes   *string      `json:"notes,omitempty"`
	Disable bool         `json:"disable"`
	Signals []SignalType `json:"signals"`
	Details []string     `json:"details"`
}

func (DeleteAttributeAction) IsAction()              {}
func (this DeleteAttributeAction) GetID() string     { return this.ID }
func (this DeleteAttributeAction) GetType() string   { return this.Type }
func (this DeleteAttributeAction) GetName() *string  { return this.Name }
func (this DeleteAttributeAction) GetNotes() *string { return this.Notes }
func (this DeleteAttributeAction) GetDisable() bool  { return this.Disable }
func (this DeleteAttributeAction) GetSignals() []SignalType {
	if this.Signals == nil {
		return nil
	}
	interfaceSlice := make([]SignalType, 0, len(this.Signals))
	for _, concrete := range this.Signals {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type Destination struct {
	ID              string                        `json:"id"`
	Type            string                        `json:"type"`
	Name            string                        `json:"name"`
	DataStreamNames []*string                     `json:"dataStreamNames"`
	ExportedSignals *ExportedSignals              `json:"exportedSignals"`
	Fields          string                        `json:"fields"`
	DestinationType *DestinationTypesCategoryItem `json:"destinationType"`
	Conditions      []*Condition                  `json:"conditions,omitempty"`
}

type DestinationDetails struct {
	Type      string `json:"type"`
	URLString string `json:"urlString"`
	Fields    string `json:"fields"`
}

type DestinationFieldYamlProperties struct {
	Name                 string                 `json:"name"`
	DisplayName          string                 `json:"displayName"`
	ComponentType        string                 `json:"componentType"`
	ComponentProperties  string                 `json:"componentProperties"`
	Secret               bool                   `json:"secret"`
	InitialValue         string                 `json:"initialValue"`
	RenderCondition      []string               `json:"renderCondition"`
	HideFromReadData     []string               `json:"hideFromReadData"`
	CustomReadDataLabels []*CustomReadDataLabel `json:"customReadDataLabels"`
}

type DestinationInput struct {
	Name              string                `json:"name"`
	Type              string                `json:"type"`
	CurrentStreamName string                `json:"currentStreamName"`
	ExportedSignals   *ExportedSignalsInput `json:"exportedSignals"`
	Fields            []*FieldInput         `json:"fields"`
}

type DestinationTypesCategoryItem struct {
	Type                    string                            `json:"type"`
	DisplayName             string                            `json:"displayName"`
	ImageURL                string                            `json:"imageUrl"`
	SupportedSignals        *SupportedSignals                 `json:"supportedSignals"`
	TestConnectionSupported bool                              `json:"testConnectionSupported"`
	Fields                  []*DestinationFieldYamlProperties `json:"fields"`
}

type DestinationsCategory struct {
	Name        string                          `json:"name"`
	Description string                          `json:"description"`
	Items       []*DestinationTypesCategoryItem `json:"items"`
}

type EntityProperty struct {
	Name    string  `json:"name"`
	Value   string  `json:"value"`
	Status  *string `json:"status,omitempty"`
	Explain *string `json:"explain,omitempty"`
}

type ErrorSamplerAction struct {
	ID      string       `json:"id"`
	Type    string       `json:"type"`
	Name    *string      `json:"name,omitempty"`
	Notes   *string      `json:"notes,omitempty"`
	Disable bool         `json:"disable"`
	Signals []SignalType `json:"signals"`
	Details string       `json:"details"`
}

func (ErrorSamplerAction) IsAction()              {}
func (this ErrorSamplerAction) GetID() string     { return this.ID }
func (this ErrorSamplerAction) GetType() string   { return this.Type }
func (this ErrorSamplerAction) GetName() *string  { return this.Name }
func (this ErrorSamplerAction) GetNotes() *string { return this.Notes }
func (this ErrorSamplerAction) GetDisable() bool  { return this.Disable }
func (this ErrorSamplerAction) GetSignals() []SignalType {
	if this.Signals == nil {
		return nil
	}
	interfaceSlice := make([]SignalType, 0, len(this.Signals))
	for _, concrete := range this.Signals {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type ExportedSignals struct {
	Traces  bool `json:"traces"`
	Metrics bool `json:"metrics"`
	Logs    bool `json:"logs"`
}

type ExportedSignalsInput struct {
	Traces  bool `json:"traces"`
	Metrics bool `json:"metrics"`
	Logs    bool `json:"logs"`
}

type FieldInput struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

type GetConfigResponse struct {
	Installation InstallationStatus `json:"installation"`
	Tier         Tier               `json:"tier"`
	Readonly     bool               `json:"readonly"`
}

type GetDestinationCategories struct {
	Categories []*DestinationsCategory `json:"categories"`
}

type HeadersCollection struct {
	HeaderKeys []*string `json:"headerKeys,omitempty"`
}

type HeadersCollectionInput struct {
	HeaderKeys []*string `json:"headerKeys,omitempty"`
}

type HTTPPayloadCollection struct {
	MimeTypes           []*string `json:"mimeTypes,omitempty"`
	MaxPayloadLength    *int      `json:"maxPayloadLength,omitempty"`
	DropPartialPayloads *bool     `json:"dropPartialPayloads,omitempty"`
}

type HTTPPayloadCollectionInput struct {
	MimeTypes           []*string `json:"mimeTypes,omitempty"`
	MaxPayloadLength    *int      `json:"maxPayloadLength,omitempty"`
	DropPartialPayloads *bool     `json:"dropPartialPayloads,omitempty"`
}

type InstrumentationInstanceAnalyze struct {
	Healthy               *EntityProperty   `json:"healthy"`
	Message               *EntityProperty   `json:"message,omitempty"`
	IdentifyingAttributes []*EntityProperty `json:"identifyingAttributes"`
}

type InstrumentationLibraryGlobalID struct {
	Name     string               `json:"name"`
	SpanKind *SpanKind            `json:"spanKind,omitempty"`
	Language *ProgrammingLanguage `json:"language,omitempty"`
}

type InstrumentationLibraryGlobalIDInput struct {
	Name     string               `json:"name"`
	SpanKind *SpanKind            `json:"spanKind,omitempty"`
	Language *ProgrammingLanguage `json:"language,omitempty"`
}

type InstrumentationRule struct {
	Type                     InstrumentationRuleType           `json:"type"`
	RuleID                   string                            `json:"ruleId"`
	RuleName                 *string                           `json:"ruleName,omitempty"`
	Notes                    *string                           `json:"notes,omitempty"`
	Disabled                 *bool                             `json:"disabled,omitempty"`
	Mutable                  bool                              `json:"mutable"`
	ProfileName              string                            `json:"profileName"`
	Workloads                []*PodWorkload                    `json:"workloads,omitempty"`
	InstrumentationLibraries []*InstrumentationLibraryGlobalID `json:"instrumentationLibraries,omitempty"`
	CodeAttributes           *CodeAttributes                   `json:"codeAttributes,omitempty"`
	HeadersCollection        *HeadersCollection                `json:"headersCollection,omitempty"`
	PayloadCollection        *PayloadCollection                `json:"payloadCollection,omitempty"`
	CustomInstrumentations   *CustomInstrumentations           `json:"customInstrumentations,omitempty"`
}

type InstrumentationRuleInput struct {
	RuleName                 *string                                `json:"ruleName,omitempty"`
	Notes                    *string                                `json:"notes,omitempty"`
	Disabled                 *bool                                  `json:"disabled,omitempty"`
	Workloads                []*PodWorkloadInput                    `json:"workloads,omitempty"`
	InstrumentationLibraries []*InstrumentationLibraryGlobalIDInput `json:"instrumentationLibraries,omitempty"`
	CodeAttributes           *CodeAttributesInput                   `json:"codeAttributes,omitempty"`
	HeadersCollection        *HeadersCollectionInput                `json:"headersCollection,omitempty"`
	PayloadCollection        *PayloadCollectionInput                `json:"payloadCollection,omitempty"`
	CustomInstrumentations   *CustomInstrumentationsInput           `json:"customInstrumentations,omitempty"`
}

type InstrumentationSourcesAnalyze struct {
	Instrumented     *EntityProperty `json:"instrumented"`
	Workload         *EntityProperty `json:"workload,omitempty"`
	Namespace        *EntityProperty `json:"namespace,omitempty"`
	InstrumentedText *EntityProperty `json:"instrumentedText,omitempty"`
}

type JSONCondition struct {
	Operation     JSONOperation `json:"operation"`
	ExpectedValue *string       `json:"expectedValue,omitempty"`
	JSONPath      *string       `json:"jsonPath,omitempty"`
}

type K8sActualNamespace struct {
	Name            string             `json:"name"`
	Selected        bool               `json:"selected"`
	DataStreamNames []*string          `json:"dataStreamNames"`
	Sources         []*K8sActualSource `json:"sources"`
}

type K8sActualSource struct {
	Namespace         string             `json:"namespace"`
	Name              string             `json:"name"`
	Kind              K8sResourceKind    `json:"kind"`
	DataStreamNames   []*string          `json:"dataStreamNames"`
	NumberOfInstances *int               `json:"numberOfInstances,omitempty"`
	Selected          *bool              `json:"selected,omitempty"`
	OtelServiceName   *string            `json:"otelServiceName,omitempty"`
	Containers        []*SourceContainer `json:"containers,omitempty"`
	Conditions        []*Condition       `json:"conditions,omitempty"`
}

type K8sAnnotationAttribute struct {
	AnnotationKey string `json:"annotationKey"`
	AttributeKey  string `json:"attributeKey"`
}

type K8sAttributes struct {
	CollectContainerAttributes  bool                      `json:"collectContainerAttributes"`
	CollectReplicaSetAttributes bool                      `json:"collectReplicaSetAttributes"`
	CollectWorkloadID           bool                      `json:"collectWorkloadId"`
	CollectClusterID            bool                      `json:"collectClusterId"`
	LabelsAttributes            []*K8sLabelAttribute      `json:"labelsAttributes"`
	AnnotationsAttributes       []*K8sAnnotationAttribute `json:"annotationsAttributes"`
}

type K8sAttributesAction struct {
	ID      string         `json:"id"`
	Type    string         `json:"type"`
	Name    *string        `json:"name,omitempty"`
	Notes   *string        `json:"notes,omitempty"`
	Disable bool           `json:"disable"`
	Signals []SignalType   `json:"signals"`
	Details *K8sAttributes `json:"details"`
}

func (K8sAttributesAction) IsAction()              {}
func (this K8sAttributesAction) GetID() string     { return this.ID }
func (this K8sAttributesAction) GetType() string   { return this.Type }
func (this K8sAttributesAction) GetName() *string  { return this.Name }
func (this K8sAttributesAction) GetNotes() *string { return this.Notes }
func (this K8sAttributesAction) GetDisable() bool  { return this.Disable }
func (this K8sAttributesAction) GetSignals() []SignalType {
	if this.Signals == nil {
		return nil
	}
	interfaceSlice := make([]SignalType, 0, len(this.Signals))
	for _, concrete := range this.Signals {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type K8sDesiredNamespaceInput struct {
	AutoInstrument *bool `json:"autoInstrument,omitempty"`
}

type K8sDesiredSourceInput struct {
	ServiceName    *string `json:"serviceName,omitempty"`
	AutoInstrument *bool   `json:"autoInstrument,omitempty"`
}

type K8sLabelAttribute struct {
	LabelKey     string `json:"labelKey"`
	AttributeKey string `json:"attributeKey"`
}

type K8sNamespaceID struct {
	Name string `json:"name"`
}

type K8sSourceID struct {
	Namespace string          `json:"namespace"`
	Kind      K8sResourceKind `json:"kind"`
	Name      string          `json:"name"`
}

type LatencySamplerAction struct {
	ID      string       `json:"id"`
	Type    string       `json:"type"`
	Name    *string      `json:"name,omitempty"`
	Notes   *string      `json:"notes,omitempty"`
	Disable bool         `json:"disable"`
	Signals []SignalType `json:"signals"`
	Details []*string    `json:"details"`
}

func (LatencySamplerAction) IsAction()              {}
func (this LatencySamplerAction) GetID() string     { return this.ID }
func (this LatencySamplerAction) GetType() string   { return this.Type }
func (this LatencySamplerAction) GetName() *string  { return this.Name }
func (this LatencySamplerAction) GetNotes() *string { return this.Notes }
func (this LatencySamplerAction) GetDisable() bool  { return this.Disable }
func (this LatencySamplerAction) GetSignals() []SignalType {
	if this.Signals == nil {
		return nil
	}
	interfaceSlice := make([]SignalType, 0, len(this.Signals))
	for _, concrete := range this.Signals {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type MessagingPayloadCollection struct {
	MaxPayloadLength    *int  `json:"maxPayloadLength,omitempty"`
	DropPartialPayloads *bool `json:"dropPartialPayloads,omitempty"`
}

type MessagingPayloadCollectionInput struct {
	MaxPayloadLength    *int  `json:"maxPayloadLength,omitempty"`
	DropPartialPayloads *bool `json:"dropPartialPayloads,omitempty"`
}

type Mutation struct {
}

type NodeCollectorAnalyze struct {
	Enabled        *EntityProperty `json:"enabled"`
	CollectorGroup *EntityProperty `json:"collectorGroup"`
	Deployed       *EntityProperty `json:"deployed,omitempty"`
	DeployedError  *EntityProperty `json:"deployedError,omitempty"`
	CollectorReady *EntityProperty `json:"collectorReady,omitempty"`
	DaemonSet      *EntityProperty `json:"daemonSet"`
	DesiredNodes   *EntityProperty `json:"desiredNodes,omitempty"`
	CurrentNodes   *EntityProperty `json:"currentNodes,omitempty"`
	UpdatedNodes   *EntityProperty `json:"updatedNodes,omitempty"`
	AvailableNodes *EntityProperty `json:"availableNodes,omitempty"`
}

type NumberCondition struct {
	Operation     NumberOperation `json:"operation"`
	ExpectedValue float64         `json:"expectedValue"`
}

type ObservabilitySignalSupport struct {
	Supported bool `json:"supported"`
}

type OdigosAnalyze struct {
	OdigosVersion        *EntityProperty          `json:"odigosVersion"`
	KubernetesVersion    *EntityProperty          `json:"kubernetesVersion"`
	Tier                 *EntityProperty          `json:"tier"`
	InstallationMethod   *EntityProperty          `json:"installationMethod"`
	NumberOfDestinations int                      `json:"numberOfDestinations"`
	NumberOfSources      int                      `json:"numberOfSources"`
	ClusterCollector     *ClusterCollectorAnalyze `json:"clusterCollector"`
	NodeCollector        *NodeCollectorAnalyze    `json:"nodeCollector"`
	IsSettled            bool                     `json:"isSettled"`
	HasErrors            bool                     `json:"hasErrors"`
}

type OtelAgentsAnalyze struct {
	Created    *EntityProperty                `json:"created"`
	CreateTime *EntityProperty                `json:"createTime,omitempty"`
	Containers []*ContainerAgentConfigAnalyze `json:"containers"`
}

type OverviewMetricsResponse struct {
	Sources      []*SingleSourceMetricsResponse      `json:"sources"`
	Destinations []*SingleDestinationMetricsResponse `json:"destinations"`
}

type PaginatedSources struct {
	NextPage string             `json:"nextPage"`
	Items    []*K8sActualSource `json:"items"`
}

type PatchSourceRequestInput struct {
	CurrentStreamName string  `json:"currentStreamName"`
	OtelServiceName   *string `json:"otelServiceName,omitempty"`
	ContainerName     *string `json:"containerName,omitempty"`
	Language          *string `json:"language,omitempty"`
	Version           *string `json:"version,omitempty"`
}

type PayloadCollection struct {
	HTTPRequest  *HTTPPayloadCollection      `json:"httpRequest,omitempty"`
	HTTPResponse *HTTPPayloadCollection      `json:"httpResponse,omitempty"`
	DbQuery      *DbQueryPayloadCollection   `json:"dbQuery,omitempty"`
	Messaging    *MessagingPayloadCollection `json:"messaging,omitempty"`
}

type PayloadCollectionInput struct {
	HTTPRequest  *HTTPPayloadCollectionInput      `json:"httpRequest,omitempty"`
	HTTPResponse *HTTPPayloadCollectionInput      `json:"httpResponse,omitempty"`
	DbQuery      *DbQueryPayloadCollectionInput   `json:"dbQuery,omitempty"`
	Messaging    *MessagingPayloadCollectionInput `json:"messaging,omitempty"`
}

type PersistNamespaceItemInput struct {
	Namespace         string `json:"namespace"`
	Selected          bool   `json:"selected"`
	CurrentStreamName string `json:"currentStreamName"`
}

type PersistNamespaceSourceInput struct {
	Namespace         string          `json:"namespace"`
	Name              string          `json:"name"`
	Kind              K8sResourceKind `json:"kind"`
	Selected          bool            `json:"selected"`
	CurrentStreamName string          `json:"currentStreamName"`
}

type PiiMaskingAction struct {
	ID      string       `json:"id"`
	Type    string       `json:"type"`
	Name    *string      `json:"name,omitempty"`
	Notes   *string      `json:"notes,omitempty"`
	Disable bool         `json:"disable"`
	Signals []SignalType `json:"signals"`
	Details []string     `json:"details,omitempty"`
}

func (PiiMaskingAction) IsAction()              {}
func (this PiiMaskingAction) GetID() string     { return this.ID }
func (this PiiMaskingAction) GetType() string   { return this.Type }
func (this PiiMaskingAction) GetName() *string  { return this.Name }
func (this PiiMaskingAction) GetNotes() *string { return this.Notes }
func (this PiiMaskingAction) GetDisable() bool  { return this.Disable }
func (this PiiMaskingAction) GetSignals() []SignalType {
	if this.Signals == nil {
		return nil
	}
	interfaceSlice := make([]SignalType, 0, len(this.Signals))
	for _, concrete := range this.Signals {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type PipelineAction struct {
	ID         string       `json:"id"`
	Type       string       `json:"type"`
	Spec       string       `json:"spec"`
	Conditions []*Condition `json:"conditions,omitempty"`
}

type PodAnalyze struct {
	PodName                       *EntityProperty        `json:"podName"`
	NodeName                      *EntityProperty        `json:"nodeName"`
	Phase                         *EntityProperty        `json:"phase"`
	AgentInjected                 *EntityProperty        `json:"agentInjected"`
	RunningLatestWorkloadRevision *EntityProperty        `json:"runningLatestWorkloadRevision,omitempty"`
	Containers                    []*PodContainerAnalyze `json:"containers"`
}

type PodContainerAnalyze struct {
	ContainerName            *EntityProperty                   `json:"containerName"`
	ActualDevices            *EntityProperty                   `json:"actualDevices"`
	Started                  *EntityProperty                   `json:"started,omitempty"`
	Ready                    *EntityProperty                   `json:"ready,omitempty"`
	InstrumentationInstances []*InstrumentationInstanceAnalyze `json:"instrumentationInstances"`
}

type PodWorkload struct {
	Namespace string          `json:"namespace"`
	Name      string          `json:"name"`
	Kind      K8sResourceKind `json:"kind"`
}

type PodWorkloadInput struct {
	Namespace string          `json:"namespace"`
	Kind      K8sResourceKind `json:"kind"`
	Name      string          `json:"name"`
}

type ProbabilisticSamplerAction struct {
	ID      string       `json:"id"`
	Type    string       `json:"type"`
	Name    *string      `json:"name,omitempty"`
	Notes   *string      `json:"notes,omitempty"`
	Disable bool         `json:"disable"`
	Signals []SignalType `json:"signals"`
	Details string       `json:"details"`
}

func (ProbabilisticSamplerAction) IsAction()              {}
func (this ProbabilisticSamplerAction) GetID() string     { return this.ID }
func (this ProbabilisticSamplerAction) GetType() string   { return this.Type }
func (this ProbabilisticSamplerAction) GetName() *string  { return this.Name }
func (this ProbabilisticSamplerAction) GetNotes() *string { return this.Notes }
func (this ProbabilisticSamplerAction) GetDisable() bool  { return this.Disable }
func (this ProbabilisticSamplerAction) GetSignals() []SignalType {
	if this.Signals == nil {
		return nil
	}
	interfaceSlice := make([]SignalType, 0, len(this.Signals))
	for _, concrete := range this.Signals {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type Probe struct {
	ClassName  *string `json:"className,omitempty"`
	MethodName *string `json:"methodName,omitempty"`
}

type ProbeInput struct {
	ClassName  *string `json:"className,omitempty"`
	MethodName *string `json:"methodName,omitempty"`
}

type Query struct {
}

type RenameAttributeAction struct {
	ID      string       `json:"id"`
	Type    string       `json:"type"`
	Name    *string      `json:"name,omitempty"`
	Notes   *string      `json:"notes,omitempty"`
	Disable bool         `json:"disable"`
	Signals []SignalType `json:"signals"`
	Details string       `json:"details"`
}

func (RenameAttributeAction) IsAction()              {}
func (this RenameAttributeAction) GetID() string     { return this.ID }
func (this RenameAttributeAction) GetType() string   { return this.Type }
func (this RenameAttributeAction) GetName() *string  { return this.Name }
func (this RenameAttributeAction) GetNotes() *string { return this.Notes }
func (this RenameAttributeAction) GetDisable() bool  { return this.Disable }
func (this RenameAttributeAction) GetSignals() []SignalType {
	if this.Signals == nil {
		return nil
	}
	interfaceSlice := make([]SignalType, 0, len(this.Signals))
	for _, concrete := range this.Signals {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type RuntimeInfoAnalyze struct {
	Generation *EntityProperty                `json:"generation"`
	Containers []*ContainerRuntimeInfoAnalyze `json:"containers"`
}

type ServiceMap struct {
	Services []*ServiceMapFromSource `json:"services"`
}

type ServiceMapFromSource struct {
	ServiceName string                `json:"serviceName"`
	Services    []*ServiceMapToSource `json:"services"`
}

type ServiceMapToSource struct {
	ServiceName string `json:"serviceName"`
	Requests    int    `json:"requests"`
	DateTime    string `json:"dateTime"`
}

type ServiceNameFilters struct {
	ServiceName           string  `json:"serviceName"`
	SamplingRatio         float64 `json:"samplingRatio"`
	FallbackSamplingRatio float64 `json:"fallbackSamplingRatio"`
}

type ServiceNameSamplerAction struct {
	ID      string                `json:"id"`
	Type    string                `json:"type"`
	Name    *string               `json:"name,omitempty"`
	Notes   *string               `json:"notes,omitempty"`
	Disable bool                  `json:"disable"`
	Signals []SignalType          `json:"signals"`
	Details []*ServiceNameFilters `json:"details"`
}

func (ServiceNameSamplerAction) IsAction()              {}
func (this ServiceNameSamplerAction) GetID() string     { return this.ID }
func (this ServiceNameSamplerAction) GetType() string   { return this.Type }
func (this ServiceNameSamplerAction) GetName() *string  { return this.Name }
func (this ServiceNameSamplerAction) GetNotes() *string { return this.Notes }
func (this ServiceNameSamplerAction) GetDisable() bool  { return this.Disable }
func (this ServiceNameSamplerAction) GetSignals() []SignalType {
	if this.Signals == nil {
		return nil
	}
	interfaceSlice := make([]SignalType, 0, len(this.Signals))
	for _, concrete := range this.Signals {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type SingleDestinationMetricsResponse struct {
	ID            string `json:"id"`
	TotalDataSent int    `json:"totalDataSent"`
	Throughput    int    `json:"throughput"`
}

type SingleSourceMetricsResponse struct {
	Namespace     string `json:"namespace"`
	Kind          string `json:"kind"`
	Name          string `json:"name"`
	TotalDataSent int    `json:"totalDataSent"`
	Throughput    int    `json:"throughput"`
}

type SourceAnalyze struct {
	Name            *EntityProperty                `json:"name"`
	Kind            *EntityProperty                `json:"kind"`
	Namespace       *EntityProperty                `json:"namespace"`
	SourceObjects   *InstrumentationSourcesAnalyze `json:"sourceObjects"`
	RuntimeInfo     *RuntimeInfoAnalyze            `json:"runtimeInfo"`
	OtelAgents      *OtelAgentsAnalyze             `json:"otelAgents"`
	TotalPods       int                            `json:"totalPods"`
	PodsPhasesCount string                         `json:"podsPhasesCount"`
	Pods            []*PodAnalyze                  `json:"pods"`
}

type SourceConditions struct {
	Namespace  string          `json:"namespace"`
	Name       string          `json:"name"`
	Kind       K8sResourceKind `json:"kind"`
	Conditions []*Condition    `json:"conditions"`
}

type SourceContainer struct {
	ContainerName          string  `json:"containerName"`
	Language               string  `json:"language"`
	RuntimeVersion         string  `json:"runtimeVersion"`
	Overriden              bool    `json:"overriden"`
	Instrumented           bool    `json:"instrumented"`
	InstrumentationMessage string  `json:"instrumentationMessage"`
	OtelDistroName         *string `json:"otelDistroName,omitempty"`
}

type SpanAttributeSamplerAction struct {
	ID      string              `json:"id"`
	Type    string              `json:"type"`
	Name    *string             `json:"name,omitempty"`
	Notes   *string             `json:"notes,omitempty"`
	Disable bool                `json:"disable"`
	Signals []SignalType        `json:"signals"`
	Details []*AttributeFilters `json:"details"`
}

func (SpanAttributeSamplerAction) IsAction()              {}
func (this SpanAttributeSamplerAction) GetID() string     { return this.ID }
func (this SpanAttributeSamplerAction) GetType() string   { return this.Type }
func (this SpanAttributeSamplerAction) GetName() *string  { return this.Name }
func (this SpanAttributeSamplerAction) GetNotes() *string { return this.Notes }
func (this SpanAttributeSamplerAction) GetDisable() bool  { return this.Disable }
func (this SpanAttributeSamplerAction) GetSignals() []SignalType {
	if this.Signals == nil {
		return nil
	}
	interfaceSlice := make([]SignalType, 0, len(this.Signals))
	for _, concrete := range this.Signals {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type StringCondition struct {
	Operation     StringOperation `json:"operation"`
	ExpectedValue *string         `json:"expectedValue,omitempty"`
}

type SupportedSignals struct {
	Traces  *ObservabilitySignalSupport `json:"traces"`
	Metrics *ObservabilitySignalSupport `json:"metrics"`
	Logs    *ObservabilitySignalSupport `json:"logs"`
}

type TestConnectionResponse struct {
	Succeeded       bool    `json:"succeeded"`
	StatusCode      int     `json:"statusCode"`
	DestinationType *string `json:"destinationType,omitempty"`
	Message         *string `json:"message,omitempty"`
	Reason          *string `json:"reason,omitempty"`
}

type BooleanOperation string

const (
	BooleanOperationExists BooleanOperation = "exists"
	BooleanOperationEquals BooleanOperation = "equals"
)

var AllBooleanOperation = []BooleanOperation{
	BooleanOperationExists,
	BooleanOperationEquals,
}

func (e BooleanOperation) IsValid() bool {
	switch e {
	case BooleanOperationExists, BooleanOperationEquals:
		return true
	}
	return false
}

func (e BooleanOperation) String() string {
	return string(e)
}

func (e *BooleanOperation) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BooleanOperation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BooleanOperation", str)
	}
	return nil
}

func (e BooleanOperation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ComputePlatformType string

const (
	ComputePlatformTypeK8s ComputePlatformType = "K8S"
	ComputePlatformTypeVM  ComputePlatformType = "VM"
)

var AllComputePlatformType = []ComputePlatformType{
	ComputePlatformTypeK8s,
	ComputePlatformTypeVM,
}

func (e ComputePlatformType) IsValid() bool {
	switch e {
	case ComputePlatformTypeK8s, ComputePlatformTypeVM:
		return true
	}
	return false
}

func (e ComputePlatformType) String() string {
	return string(e)
}

func (e *ComputePlatformType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ComputePlatformType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ComputePlatformType", str)
	}
	return nil
}

func (e ComputePlatformType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ConditionStatus string

const (
	ConditionStatusSuccess  ConditionStatus = "success"
	ConditionStatusError    ConditionStatus = "error"
	ConditionStatusDisabled ConditionStatus = "disabled"
	ConditionStatusLoading  ConditionStatus = "loading"
)

var AllConditionStatus = []ConditionStatus{
	ConditionStatusSuccess,
	ConditionStatusError,
	ConditionStatusDisabled,
	ConditionStatusLoading,
}

func (e ConditionStatus) IsValid() bool {
	switch e {
	case ConditionStatusSuccess, ConditionStatusError, ConditionStatusDisabled, ConditionStatusLoading:
		return true
	}
	return false
}

func (e ConditionStatus) String() string {
	return string(e)
}

func (e *ConditionStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConditionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConditionStatus", str)
	}
	return nil
}

func (e ConditionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type InstallationStatus string

const (
	InstallationStatusNew          InstallationStatus = "NEW"
	InstallationStatusAppsSelected InstallationStatus = "APPS_SELECTED"
	InstallationStatusFinished     InstallationStatus = "FINISHED"
)

var AllInstallationStatus = []InstallationStatus{
	InstallationStatusNew,
	InstallationStatusAppsSelected,
	InstallationStatusFinished,
}

func (e InstallationStatus) IsValid() bool {
	switch e {
	case InstallationStatusNew, InstallationStatusAppsSelected, InstallationStatusFinished:
		return true
	}
	return false
}

func (e InstallationStatus) String() string {
	return string(e)
}

func (e *InstallationStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InstallationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InstallationStatus", str)
	}
	return nil
}

func (e InstallationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type InstrumentationRuleType string

const (
	InstrumentationRuleTypeCodeAttributes        InstrumentationRuleType = "CodeAttributes"
	InstrumentationRuleTypeHeadersCollection     InstrumentationRuleType = "HeadersCollection"
	InstrumentationRuleTypePayloadCollection     InstrumentationRuleType = "PayloadCollection"
	InstrumentationRuleTypeCustomInstrumentation InstrumentationRuleType = "CustomInstrumentation"
	InstrumentationRuleTypeUnknownType           InstrumentationRuleType = "UnknownType"
)

var AllInstrumentationRuleType = []InstrumentationRuleType{
	InstrumentationRuleTypeCodeAttributes,
	InstrumentationRuleTypeHeadersCollection,
	InstrumentationRuleTypePayloadCollection,
	InstrumentationRuleTypeCustomInstrumentation,
	InstrumentationRuleTypeUnknownType,
}

func (e InstrumentationRuleType) IsValid() bool {
	switch e {
	case InstrumentationRuleTypeCodeAttributes, InstrumentationRuleTypeHeadersCollection, InstrumentationRuleTypePayloadCollection, InstrumentationRuleTypeCustomInstrumentation, InstrumentationRuleTypeUnknownType:
		return true
	}
	return false
}

func (e InstrumentationRuleType) String() string {
	return string(e)
}

func (e *InstrumentationRuleType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InstrumentationRuleType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InstrumentationRuleType", str)
	}
	return nil
}

func (e InstrumentationRuleType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type JSONOperation string

const (
	JSONOperationExists         JSONOperation = "exists"
	JSONOperationEquals         JSONOperation = "equals"
	JSONOperationNotEquals      JSONOperation = "not_equals"
	JSONOperationIsValidJSON    JSONOperation = "is_valid_json"
	JSONOperationIsInvalidJSON  JSONOperation = "is_invalid_json"
	JSONOperationJsonpathExists JSONOperation = "jsonpath_exists"
	JSONOperationKeyEquals      JSONOperation = "key_equals"
	JSONOperationKeyNotEquals   JSONOperation = "key_not_equals"
)

var AllJSONOperation = []JSONOperation{
	JSONOperationExists,
	JSONOperationEquals,
	JSONOperationNotEquals,
	JSONOperationIsValidJSON,
	JSONOperationIsInvalidJSON,
	JSONOperationJsonpathExists,
	JSONOperationKeyEquals,
	JSONOperationKeyNotEquals,
}

func (e JSONOperation) IsValid() bool {
	switch e {
	case JSONOperationExists, JSONOperationEquals, JSONOperationNotEquals, JSONOperationIsValidJSON, JSONOperationIsInvalidJSON, JSONOperationJsonpathExists, JSONOperationKeyEquals, JSONOperationKeyNotEquals:
		return true
	}
	return false
}

func (e JSONOperation) String() string {
	return string(e)
}

func (e *JSONOperation) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = JSONOperation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid JsonOperation", str)
	}
	return nil
}

func (e JSONOperation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type K8sResourceKind string

const (
	K8sResourceKindDeployment  K8sResourceKind = "Deployment"
	K8sResourceKindDaemonSet   K8sResourceKind = "DaemonSet"
	K8sResourceKindStatefulSet K8sResourceKind = "StatefulSet"
	K8sResourceKindCronJob     K8sResourceKind = "CronJob"
)

var AllK8sResourceKind = []K8sResourceKind{
	K8sResourceKindDeployment,
	K8sResourceKindDaemonSet,
	K8sResourceKindStatefulSet,
	K8sResourceKindCronJob,
}

func (e K8sResourceKind) IsValid() bool {
	switch e {
	case K8sResourceKindDeployment, K8sResourceKindDaemonSet, K8sResourceKindStatefulSet, K8sResourceKindCronJob:
		return true
	}
	return false
}

func (e K8sResourceKind) String() string {
	return string(e)
}

func (e *K8sResourceKind) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = K8sResourceKind(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid K8sResourceKind", str)
	}
	return nil
}

func (e K8sResourceKind) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NumberOperation string

const (
	NumberOperationExists             NumberOperation = "exists"
	NumberOperationEquals             NumberOperation = "equals"
	NumberOperationNotEquals          NumberOperation = "not_equals"
	NumberOperationGreaterThan        NumberOperation = "greater_than"
	NumberOperationLessThan           NumberOperation = "less_than"
	NumberOperationGreaterThanOrEqual NumberOperation = "greater_than_or_equal"
	NumberOperationLessThanOrEqual    NumberOperation = "less_than_or_equal"
)

var AllNumberOperation = []NumberOperation{
	NumberOperationExists,
	NumberOperationEquals,
	NumberOperationNotEquals,
	NumberOperationGreaterThan,
	NumberOperationLessThan,
	NumberOperationGreaterThanOrEqual,
	NumberOperationLessThanOrEqual,
}

func (e NumberOperation) IsValid() bool {
	switch e {
	case NumberOperationExists, NumberOperationEquals, NumberOperationNotEquals, NumberOperationGreaterThan, NumberOperationLessThan, NumberOperationGreaterThanOrEqual, NumberOperationLessThanOrEqual:
		return true
	}
	return false
}

func (e NumberOperation) String() string {
	return string(e)
}

func (e *NumberOperation) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NumberOperation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NumberOperation", str)
	}
	return nil
}

func (e NumberOperation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProgrammingLanguage string

const (
	ProgrammingLanguageUnspecified ProgrammingLanguage = "Unspecified"
	ProgrammingLanguageJava        ProgrammingLanguage = "Java"
	ProgrammingLanguageGo          ProgrammingLanguage = "Go"
	ProgrammingLanguageJavaScript  ProgrammingLanguage = "JavaScript"
	ProgrammingLanguagePython      ProgrammingLanguage = "Python"
	ProgrammingLanguageDotNet      ProgrammingLanguage = "DotNet"
)

var AllProgrammingLanguage = []ProgrammingLanguage{
	ProgrammingLanguageUnspecified,
	ProgrammingLanguageJava,
	ProgrammingLanguageGo,
	ProgrammingLanguageJavaScript,
	ProgrammingLanguagePython,
	ProgrammingLanguageDotNet,
}

func (e ProgrammingLanguage) IsValid() bool {
	switch e {
	case ProgrammingLanguageUnspecified, ProgrammingLanguageJava, ProgrammingLanguageGo, ProgrammingLanguageJavaScript, ProgrammingLanguagePython, ProgrammingLanguageDotNet:
		return true
	}
	return false
}

func (e ProgrammingLanguage) String() string {
	return string(e)
}

func (e *ProgrammingLanguage) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProgrammingLanguage(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProgrammingLanguage", str)
	}
	return nil
}

func (e ProgrammingLanguage) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SignalType string

const (
	SignalTypeTraces  SignalType = "TRACES"
	SignalTypeMetrics SignalType = "METRICS"
	SignalTypeLogs    SignalType = "LOGS"
)

var AllSignalType = []SignalType{
	SignalTypeTraces,
	SignalTypeMetrics,
	SignalTypeLogs,
}

func (e SignalType) IsValid() bool {
	switch e {
	case SignalTypeTraces, SignalTypeMetrics, SignalTypeLogs:
		return true
	}
	return false
}

func (e SignalType) String() string {
	return string(e)
}

func (e *SignalType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SignalType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SignalType", str)
	}
	return nil
}

func (e SignalType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SpanKind string

const (
	SpanKindInternal SpanKind = "Internal"
	SpanKindServer   SpanKind = "Server"
	SpanKindClient   SpanKind = "Client"
	SpanKindProducer SpanKind = "Producer"
	SpanKindConsumer SpanKind = "Consumer"
)

var AllSpanKind = []SpanKind{
	SpanKindInternal,
	SpanKindServer,
	SpanKindClient,
	SpanKindProducer,
	SpanKindConsumer,
}

func (e SpanKind) IsValid() bool {
	switch e {
	case SpanKindInternal, SpanKindServer, SpanKindClient, SpanKindProducer, SpanKindConsumer:
		return true
	}
	return false
}

func (e SpanKind) String() string {
	return string(e)
}

func (e *SpanKind) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SpanKind(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SpanKind", str)
	}
	return nil
}

func (e SpanKind) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StringOperation string

const (
	StringOperationExists      StringOperation = "exists"
	StringOperationEquals      StringOperation = "equals"
	StringOperationNotEquals   StringOperation = "not_equals"
	StringOperationContains    StringOperation = "contains"
	StringOperationNotContains StringOperation = "not_contains"
	StringOperationRegex       StringOperation = "regex"
)

var AllStringOperation = []StringOperation{
	StringOperationExists,
	StringOperationEquals,
	StringOperationNotEquals,
	StringOperationContains,
	StringOperationNotContains,
	StringOperationRegex,
}

func (e StringOperation) IsValid() bool {
	switch e {
	case StringOperationExists, StringOperationEquals, StringOperationNotEquals, StringOperationContains, StringOperationNotContains, StringOperationRegex:
		return true
	}
	return false
}

func (e StringOperation) String() string {
	return string(e)
}

func (e *StringOperation) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StringOperation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StringOperation", str)
	}
	return nil
}

func (e StringOperation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Tier string

const (
	TierCommunity Tier = "community"
	TierCloud     Tier = "cloud"
	TierOnprem    Tier = "onprem"
)

var AllTier = []Tier{
	TierCommunity,
	TierCloud,
	TierOnprem,
}

func (e Tier) IsValid() bool {
	switch e {
	case TierCommunity, TierCloud, TierOnprem:
		return true
	}
	return false
}

func (e Tier) String() string {
	return string(e)
}

func (e *Tier) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Tier(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Tier", str)
	}
	return nil
}

func (e Tier) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

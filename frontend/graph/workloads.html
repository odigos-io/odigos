<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Workloads - Odigos</title>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f7fa;
            min-height: 100vh;
            color: #1f2937;
            line-height: 1.6;
        }
        .main-wrapper {
            display: flex;
            min-height: 100vh;
            gap: 0;
        }
        .sidebar {
            width: 420px;
            height: 100vh;
            background-color: #ffffff;
            border-right: 1px solid #e5e7eb;
            padding: 20px;
            overflow-y: auto;
            flex-shrink: 0;
            box-shadow: 2px 0 4px rgba(0,0,0,0.05);
            position: sticky;
            top: 0;
        }
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .container {
            flex: 1;
            background-color: #ffffff;
            padding: 32px;
            overflow-y: auto;
            margin: 0;
            border-radius: 0;
            box-shadow: none;
            border: none;
        }
        h1 {
            color: #111827;
            margin-bottom: 24px;
            font-size: 28px;
            font-weight: 600;
            letter-spacing: -0.025em;
        }
        #json-output {
            height: calc(100vh - 120px);
            overflow: auto;
            padding: 8px;
        }
        #json-output::-webkit-scrollbar {
            width: 12px;
        }
        #json-output::-webkit-scrollbar-track {
            background: #f7fafc;
            border-radius: 6px;
        }
        #json-output::-webkit-scrollbar-thumb {
            background: #cbd5e0;
            border-radius: 6px;
        }
        #json-output::-webkit-scrollbar-thumb:hover {
            background: #a0aec0;
        }
        .json-item {
            margin: 4px 0;
            padding: 4px 8px;
            border-radius: 6px;
            transition: background-color 0.2s ease;
        }
        .json-item.expandable {
            cursor: pointer;
        }
        .json-item.expandable:hover {
            background-color: #f7fafc;
        }
        .json-key {
            color: #1e40af;
            font-weight: 500;
        }
        .workload-health-message {
            display: block;
            font-size: 10px;
            color: #6b7280;
            font-weight: 400;
            margin-top: 2px;
            margin-left: 18px;
            line-height: 1.2;
            max-width: calc(100% - 18px);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .json-string {
            color: #059669;
            font-weight: 400;
        }
        .json-number {
            color: #0369a1;
            font-weight: 500;
        }
        .json-boolean {
            color: #0369a1;
            font-weight: 500;
        }
        .json-null {
            color: #a0aec0;
            font-style: italic;
        }
        .emoji-tooltip-wrapper {
            position: relative;
            display: inline-block;
            margin-right: 8px;
        }
        .emoji-tooltip {
            visibility: hidden;
            background-color: #1f2937;
            color: #f9fafb;
            text-align: left;
            padding: 10px 14px;
            border-radius: 6px;
            position: absolute;
            z-index: 1000;
            top: 0;
            left: 100%;
            margin-left: 8px;
            white-space: nowrap;
            font-size: 12px;
            font-weight: 400;
            opacity: 0;
            transition: opacity 0.2s ease;
            pointer-events: none;
            max-width: 400px;
            min-width: 200px;
            white-space: normal;
            word-wrap: break-word;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1), 0 2px 4px rgba(0,0,0,0.06);
            line-height: 1.5;
        }
        .emoji-tooltip::before {
            content: "";
            position: absolute;
            right: 100%;
            top: 10px;
            border-width: 5px;
            border-style: solid;
            border-color: transparent #1f2937 transparent transparent;
        }
        .emoji-tooltip-wrapper:hover .emoji-tooltip {
            visibility: visible;
            opacity: 1;
        }
        .status-error {
            color: #dc2626;
            font-weight: 600;
            background-color: #fef2f2;
            padding: 3px 8px;
            border-radius: 4px;
            border: 1px solid #fecaca;
        }
        .status-failure {
            color: #b91c1c;
            font-weight: 600;
            background-color: #fef2f2;
            padding: 3px 8px;
            border-radius: 4px;
            border: 1px solid #fecaca;
        }
        .status-notice {
            color: #d97706;
            font-weight: 600;
            background-color: #fffbeb;
            padding: 3px 8px;
            border-radius: 4px;
            border: 1px solid #fde68a;
        }
        .status-pending {
            color: #2563eb;
            font-weight: 500;
            background-color: #eff6ff;
            padding: 3px 8px;
            border-radius: 4px;
            border: 1px solid #bfdbfe;
        }
        .status-waiting {
            color: #1e40af;
            font-weight: 500;
            background-color: #eff6ff;
            padding: 3px 8px;
            border-radius: 4px;
            border: 1px solid #bfdbfe;
        }
        .status-unsupported {
            color: #6b7280;
            font-weight: 500;
            background-color: #f9fafb;
            padding: 3px 8px;
            border-radius: 4px;
            border: 1px solid #e5e7eb;
        }
        .status-disabled {
            color: #9ca3af;
            font-weight: 400;
            background-color: #f9fafb;
            padding: 3px 8px;
            border-radius: 4px;
            border: 1px solid #e5e7eb;
        }
        .status-success {
            color: #059669;
            font-weight: 600;
            background-color: #ecfdf5;
            padding: 3px 8px;
            border-radius: 4px;
            border: 1px solid #a7f3d0;
        }
        .status-irrelevant {
            color: #d1d5db;
            font-weight: 400;
        }
        .status-unknown {
            color: #9ca3af;
            font-weight: 500;
            background-color: #f9fafb;
            padding: 3px 8px;
            border-radius: 4px;
            border: 1px solid #e5e7eb;
        }
        .toggle {
            cursor: pointer;
            user-select: none;
            display: inline-block;
            width: 18px;
            height: 18px;
            text-align: center;
            margin-right: 6px;
            border-radius: 3px;
            transition: background-color 0.2s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        .toggle:hover {
            background-color: #f3f4f6;
        }
        .toggle::before {
            content: '▶';
            display: inline-block;
            transition: transform 0.2s ease;
            font-size: 9px;
            color: #6b7280;
        }
        .toggle.expanded::before {
            transform: rotate(90deg);
        }
        .children {
            margin-left: 24px;
            display: none;
            padding-left: 8px;
            border-left: 1px solid #e5e7eb;
            margin-top: 6px;
        }
        .children.expanded {
            display: block;
        }
        .loading {
            color: #6b7280;
            font-size: 14px;
            font-weight: 400;
            padding: 32px;
            text-align: center;
        }
        .error {
            color: #dc2626;
            font-size: 14px;
            font-weight: 500;
            padding: 32px;
            text-align: center;
            background-color: #fef2f2;
            border-radius: 6px;
            border: 1px solid #fecaca;
        }
        .sidebar-header {
            position: sticky;
            top: 0;
            background-color: #ffffff;
            z-index: 10;
            padding-bottom: 12px;
            margin-bottom: 12px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }
        .sidebar h2 {
            color: #111827;
            margin: 0;
            font-size: 18px;
            font-weight: 600;
            letter-spacing: -0.025em;
            flex: 1;
        }
        .sidebar-header-btn {
            background-color: #f3f4f6;
            border: 1px solid #d1d5db;
            color: #374151;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            font-weight: 500;
        }
        .sidebar-header-btn:hover {
            background-color: #e5e7eb;
            border-color: #9ca3af;
            color: #111827;
        }
        .sidebar-header-btn:active {
            background-color: #d1d5db;
        }
        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 8px;
            margin-bottom: 8px;
        }
        .filter-group:last-child {
            border-bottom: none;
            padding-bottom: 0;
            margin-bottom: 0;
        }
        .filter-group-label {
            font-size: 13px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 4px;
        }
        .header-row {
            display: flex;
            align-items: flex-start;
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e5e7eb;
            padding: 0 32px;
            padding-top: 24px;
            padding-bottom: 20px;
        }
        .header-left {
            display: flex;
            flex-direction: column;
            width: 100%;
        }
        .header-title-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
            width: 100%;
        }
        .header-title-row h1 {
            margin: 0;
        }
        .timestamp-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .status-section {
            background-color: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 12px 16px;
            margin-top: 12px;
            font-size: 13px;
            color: #374151;
            transition: all 0.3s ease;
        }
        .status-section.no-results {
            background-color: #fef3c7;
            border: 2px solid #f59e0b;
            box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.1);
        }
        .status-section.no-results .status-header h2 {
            color: #92400e;
        }
        .status-section.no-results .status-header-text {
            color: #92400e;
            font-weight: 500;
        }
        .status-header {
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 8px;
        }
        .status-header-text {
            margin-left: auto;
            font-size: 13px;
            color: #6b7280;
            font-weight: 400;
        }
        .status-header-clear-btn {
            background-color: transparent;
            border: 1px solid #d1d5db;
            color: #6b7280;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            font-weight: 500;
            margin-left: 8px;
        }
        .status-header-clear-btn:hover {
            background-color: #f3f4f6;
            border-color: #9ca3af;
            color: #374151;
        }
        .status-header-clear-btn:active {
            background-color: #e5e7eb;
        }
        .status-filters-list {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .status-filters-list li {
            font-size: 13px;
            color: #374151;
            padding: 2px 0;
        }
        .status-toggle {
            width: 10px;
            height: 10px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s ease;
            color: #6b7280;
            font-size: 8px;
        }
        .status-toggle.expanded {
            transform: rotate(90deg);
        }
        .status-content.expanded {
            display: block;
        }
        .status-content:not(.expanded) {
            display: none;
        }
        .status-line {
            color: #6b7280;
            font-size: 13px;
            margin-top: 0;
            font-weight: 400;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .status-line-clear-btn {
            background-color: transparent;
            border: 1px solid #d1d5db;
            color: #6b7280;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            font-weight: 500;
        }
        .status-line-clear-btn:hover {
            background-color: #f3f4f6;
            border-color: #9ca3af;
            color: #374151;
        }
        .status-line-clear-btn:active {
            background-color: #e5e7eb;
        }
        .overview-section {
            background-color: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 12px 16px;
            margin-top: 12px;
            font-size: 13px;
            color: #374151;
        }
        .overview-section h2 {
            font-size: 14px;
            font-weight: 600;
            color: #111827;
            margin: 0 0 8px 0;
        }
        .overview-section .overview-stats {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .overview-section .overview-stat {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .overview-section .overview-stat-label {
            font-weight: 500;
            color: #6b7280;
        }
        .overview-section .overview-stat-value {
            font-weight: 600;
            color: #111827;
        }
        .overview-filter-btn {
            background-color: transparent;
            border: 1px solid #d1d5db;
            color: #6b7280;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            margin-left: 8px;
        }
        .overview-filter-btn:hover {
            background-color: #f3f4f6;
            border-color: #9ca3af;
            color: #374151;
        }
        .overview-toggle {
            width: 10px;
            height: 10px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s ease;
            color: #6b7280;
            font-size: 8px;
        }
        .overview-toggle.expanded {
            transform: rotate(90deg);
        }
        .overview-content.expanded {
            display: block;
        }
        .overview-content:not(.expanded) {
            display: none;
        }
        .btn {
            background-color: #2563eb;
            color: white;
            border: none;
            padding: 6px 12px;
            margin-right: 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: background-color 0.2s ease;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        .btn:hover {
            background-color: #1d4ed8;
        }
        .btn:active {
            background-color: #1e40af;
        }
        .timestamp {
            color: #6b7280;
            font-size: 13px;
            font-weight: 400;
            padding: 6px 12px;
            background-color: #f9fafb;
            border-radius: 4px;
            border: 1px solid #e5e7eb;
        }
        .timestamp-refresh-btn {
            background-color: transparent;
            border: 1px solid #d1d5db;
            color: #6b7280;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            font-weight: 500;
        }
        .timestamp-refresh-btn:hover {
            background-color: #f3f4f6;
            border-color: #9ca3af;
            color: #374151;
        }
        .timestamp-refresh-btn:active {
            background-color: #e5e7eb;
        }
        .timestamp-duration {
            margin-left: 6px;
            color: #9ca3af;
        }
        .timestamp-duration.old {
            color: #dc2626;
            font-weight: 600;
            background-color: #fef2f2;
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid #fecaca;
        }
        .verbosity-select, .namespace-select, .name-select {
            padding: 6px 10px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            background: white;
            color: #374151;
            font-weight: 400;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            width: 100%;
        }
        .verbosity-select:hover, .namespace-select:hover, .name-select:hover {
            border-color: #9ca3af;
        }
        .verbosity-select:focus, .namespace-select:focus, .name-select:focus {
            outline: none;
            border-color: #2563eb;
            box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.1);
        }
        .verbosity-label, .namespace-label, .name-label, .workload-label, .language-label, .health-status-label {
            font-size: 12px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 2px;
        }
        .instrumentation-filter {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .instrumentation-filter-label {
            font-size: 12px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 2px;
        }
        .instrumentation-checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 1px 0;
        }
        .instrumentation-checkbox {
            width: 14px;
            height: 14px;
            cursor: pointer;
            accent-color: #2563eb;
        }
        .instrumentation-checkbox-label {
            font-size: 12px;
            color: #374151;
            cursor: pointer;
            user-select: none;
        }
        .instrumentation-count {
            font-size: 11px;
            color: #6b7280;
            margin-left: 3px;
        }
        .namespace-filter-header, .workload-filter-header, .language-filter-header, .health-status-filter-header, .condition-filter-main-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            user-select: none;
            margin-bottom: 4px;
        }
        .namespace-filter-header-left, .workload-filter-header-left, .language-filter-header-left, .health-status-filter-header-left, .condition-filter-main-header-left {
            display: flex;
            align-items: center;
            gap: 4px;
            flex: 1;
        }
        .condition-filter-main-label {
            font-size: 13px;
            font-weight: 600;
            color: #374151;
        }
        .condition-filter-main-toggle {
            width: 10px;
            height: 10px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s ease;
            color: #6b7280;
            font-size: 8px;
        }
        .condition-filter-main-toggle.expanded {
            transform: rotate(90deg);
        }
        .condition-filters-container {
            display: none;
            flex-direction: column;
            gap: 1px;
        }
        .condition-filters-container.expanded {
            display: flex;
        }
        .namespace-show-all-btn, .workload-show-all-btn, .language-show-all-btn, .health-status-show-all-btn {
            background-color: transparent;
            border: 1px solid #d1d5db;
            color: #6b7280;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            margin-left: 4px;
        }
        .namespace-show-all-btn:hover, .workload-show-all-btn:hover, .language-show-all-btn:hover, .health-status-show-all-btn:hover {
            background-color: #f3f4f6;
            border-color: #9ca3af;
            color: #374151;
        }
        .namespace-show-all-btn:active, .workload-show-all-btn:active, .language-show-all-btn:active, .health-status-show-all-btn:active {
            background-color: #e5e7eb;
        }
        .namespace-filter-toggle, .workload-filter-toggle, .language-filter-toggle, .health-status-filter-toggle {
            width: 10px;
            height: 10px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s ease;
            color: #6b7280;
            font-size: 8px;
        }
        .namespace-filter-toggle.expanded, .workload-filter-toggle.expanded, .language-filter-toggle.expanded, .health-status-filter-toggle.expanded {
            transform: rotate(90deg);
        }
        .namespace-filters-container {
            display: none;
            flex-direction: column;
            gap: 1px;
            max-height: 300px;
            overflow-y: auto;
            padding: 1px 0;
        }
        .namespace-filters-container.expanded {
            display: flex;
        }
        .workload-search-box, .namespace-search-box {
            padding: 4px 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 12px;
            margin: 4px 0;
            width: 100%;
            box-sizing: border-box;
        }
        .workload-search-box:focus, .namespace-search-box:focus {
            outline: none;
            border-color: #2563eb;
            box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.1);
        }
        .search-message {
            font-size: 11px;
            color: #374151;
            font-weight: 500;
            padding: 6px 8px;
            margin: 4px 0 6px 0;
            background-color: #f3f4f6;
            border-left: 3px solid #2563eb;
            border-radius: 4px;
        }
        .workload-filters-container {
            display: none;
            flex-direction: column;
            gap: 1px;
            max-height: 300px;
            overflow-y: auto;
            padding: 1px 0;
        }
        .workload-filters-container.expanded {
            display: flex;
        }
        .workload-checkbox-wrapper.hidden, .namespace-checkbox-wrapper.hidden {
            display: none;
        }
        .workload-checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 2px;
            padding: 0;
            margin-left: 0;
        }
        .workload-checkbox {
            width: 14px;
            height: 14px;
            cursor: pointer;
            accent-color: #2563eb;
        }
        .workload-checkbox-label {
            font-size: 12px;
            color: #374151;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 4px;
            flex: 1;
        }
        .workload-count {
            font-size: 11px;
            color: #6b7280;
            margin-left: 3px;
        }
        .language-filters-container {
            display: none;
            flex-direction: column;
            gap: 1px;
            max-height: 300px;
            overflow-y: auto;
            padding: 1px 0;
        }
        .language-filters-container.expanded {
            display: flex;
        }
        .health-status-filters-container {
            display: none;
            flex-direction: column;
            gap: 1px;
            max-height: 300px;
            overflow-y: auto;
            padding: 1px 0;
        }
        .health-status-filters-container.expanded {
            display: flex;
        }
        .language-filter-footer {
            font-size: 10px;
            color: #6b7280;
            margin-top: 1px;
            margin-bottom: 2px;
        }
        .language-checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 2px;
            padding: 0;
            margin-left: 0;
        }
        .language-checkbox {
            width: 14px;
            height: 14px;
            cursor: pointer;
            accent-color: #2563eb;
        }
        .language-checkbox-label {
            font-size: 12px;
            color: #374151;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 4px;
            flex: 1;
        }
        .language-count {
            font-size: 11px;
            color: #6b7280;
            margin-left: 3px;
        }
        .language-only-btn {
            background-color: transparent;
            border: 1px solid #d1d5db;
            color: #6b7280;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            margin-left: 0;
        }
        .language-only-btn:hover {
            background-color: #f3f4f6;
            border-color: #9ca3af;
            color: #374151;
        }
        .language-only-btn:active {
            background-color: #e5e7eb;
        }
        .namespace-checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 2px;
            padding: 0;
            margin-left: 0;
        }
        .namespace-checkbox {
            width: 14px;
            height: 14px;
            cursor: pointer;
            accent-color: #2563eb;
        }
        .namespace-checkbox-label {
            font-size: 12px;
            color: #374151;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 4px;
            flex: 1;
        }
        .namespace-count {
            font-size: 11px;
            color: #6b7280;
            margin-left: 3px;
        }
        .condition-filter-group, .health-status-filter-group {
            margin-bottom: 8px;
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 8px;
        }
        .condition-filter-group:last-child, .health-status-filter-group:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }
        .health-status-filter-group {
            margin-left: 0;
        }
        .health-status-filter-subgroup {
            margin-left: 14px;
            margin-top: 4px;
            margin-bottom: 2px;
        }
        .health-status-filter-subgroup-header {
            display: flex;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            user-select: none;
            margin-bottom: 2px;
        }
        .health-status-filter-subgroup-toggle {
            width: 10px;
            height: 10px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s ease;
            color: #6b7280;
            font-size: 8px;
        }
        .health-status-filter-subgroup-toggle.expanded {
            transform: rotate(90deg);
        }
        .health-status-filter-subgroup-label {
            font-size: 11px;
            font-weight: 600;
            color: #6b7280;
        }
        .health-status-filter-subgroup-content {
            display: none;
            flex-direction: column;
            gap: 2px;
            margin-left: 14px;
            margin-top: 2px;
        }
        .health-status-filter-subgroup-content.expanded {
            display: flex;
        }
        .health-status-checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 2px;
            padding: 0;
            margin-left: 0;
        }
        .health-status-checkbox {
            width: 14px;
            height: 14px;
            cursor: pointer;
            accent-color: #2563eb;
        }
        .health-status-checkbox-label {
            font-size: 12px;
            color: #374151;
            cursor: pointer;
            user-select: none;
        }
        .health-status-checkbox-label span[title],
        .health-status-status-header span[title] {
            pointer-events: auto;
            position: relative;
            z-index: 1;
        }
        .health-status-count {
            font-size: 11px;
            color: #6b7280;
            margin-left: 4px;
        }
        .health-status-only-btn {
            background-color: transparent;
            border: 1px solid #d1d5db;
            color: #6b7280;
            padding: 1px 3px;
            border-radius: 3px;
            font-size: 9px;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            margin-left: 0;
        }
        .health-status-only-btn:hover {
            background-color: #f3f4f6;
            border-color: #9ca3af;
            color: #374151;
        }
        .health-status-filter-all-btn {
            background-color: transparent;
            border: 1px solid #d1d5db;
            color: #6b7280;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }
        .health-status-filter-all-btn:hover {
            background-color: #f3f4f6;
            border-color: #9ca3af;
            color: #374151;
        }
        .health-status-filter-footer {
            font-size: 10px;
            color: #6b7280;
            margin-top: 1px;
            margin-bottom: 2px;
        }
        .condition-filter-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 6px;
            margin-bottom: 2px;
        }
        .condition-filter-header-left {
            display: flex;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            user-select: none;
            flex: 1;
        }
        .condition-filter-toggle {
            width: 10px;
            height: 10px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s ease;
            color: #6b7280;
            font-size: 8px;
        }
        .condition-filter-toggle.expanded {
            transform: rotate(90deg);
        }
        .condition-filter-label {
            font-size: 12px;
            font-weight: 600;
            color: #374151;
        }
        .condition-filter-all-btn {
            background-color: transparent;
            border: 1px solid #d1d5db;
            color: #6b7280;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }
        .condition-filter-all-btn:hover {
            background-color: #f3f4f6;
            border-color: #9ca3af;
            color: #374151;
        }
        .condition-filter-all-btn:active {
            background-color: #e5e7eb;
        }
        .condition-filter-content {
            display: none;
            flex-direction: column;
            gap: 1px;
            margin-left: 0;
        }
        .condition-filter-content.expanded {
            display: flex;
        }
        .condition-filter-footer {
            font-size: 10px;
            color: #6b7280;
            margin-top: 1px;
            margin-bottom: 2px;
        }
        .namespace-filter-footer, .workload-filter-footer {
            font-size: 10px;
            color: #6b7280;
            margin-top: 1px;
            margin-bottom: 2px;
        }
        .condition-checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 2px;
            padding: 0;
            margin-left: 0;
        }
        .condition-checkbox {
            width: 14px;
            height: 14px;
            cursor: pointer;
            accent-color: #2563eb;
        }
        .condition-checkbox-label {
            font-size: 12px;
            color: #374151;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 4px;
            flex: 1;
        }
        .condition-checkbox-label span[title] {
            pointer-events: auto;
            position: relative;
            z-index: 1;
        }
        .condition-count {
            font-size: 11px;
            color: #6b7280;
            margin-left: 3px;
        }
        .filter-zero-count {
            opacity: 0.5;
            text-decoration: line-through;
        }
        .filter-zero-count .condition-checkbox-label,
        .filter-zero-count .health-status-checkbox-label,
        .filter-zero-count .language-checkbox-label,
        .filter-zero-count .namespace-checkbox-label,
        .filter-zero-count .workload-checkbox-label {
            color: #9ca3af;
        }
        .filter-zero-count .condition-count,
        .filter-zero-count .health-status-count,
        .filter-zero-count .language-count,
        .filter-zero-count .namespace-count {
            color: #d1d5db;
            font-weight: 600;
        }
        .condition-only-btn {
            background-color: transparent;
            border: 1px solid #d1d5db;
            color: #6b7280;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            margin-left: 0;
        }
        .condition-only-btn:hover {
            background-color: #f3f4f6;
            border-color: #9ca3af;
            color: #374151;
        }
        .condition-only-btn:active {
            background-color: #e5e7eb;
        }
        .namespace-only-btn, .workload-only-btn {
            background-color: transparent;
            border: 1px solid #d1d5db;
            color: #6b7280;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            margin-left: 0;
        }
        .namespace-only-btn:hover, .workload-only-btn:hover {
            background-color: #f3f4f6;
            border-color: #9ca3af;
            color: #374151;
        }
        .namespace-only-btn:active, .workload-only-btn:active {
            background-color: #e5e7eb;
        }
        .sidebar .btn {
            width: 100%;
            margin-right: 0;
            margin-bottom: 4px;
        }
        .tabs {
            border-bottom: 1px solid #e5e7eb;
            margin-bottom: 20px;
            display: flex;
            gap: 0;
        }
        .tab-button {
            background-color: transparent;
            border: none;
            padding: 12px 16px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #6b7280;
            border-bottom: 2px solid transparent;
            transition: color 0.2s ease;
            position: relative;
            margin-bottom: -1px;
        }
        .tab-button:hover {
            color: #374151;
        }
        .tab-button.active {
            color: #2563eb;
            border-bottom-color: #2563eb;
            font-weight: 600;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .k8s-commands {
            padding: 20px;
        }
        .k8s-command-section {
            margin-bottom: 20px;
        }
        .k8s-command-title {
            font-weight: 600;
            font-size: 14px;
            color: #374151;
            margin-bottom: 8px;
        }
        .k8s-command-block {
            display: flex;
            align-items: center;
            gap: 10px;
            background-color: #f9fafb;
            padding: 12px;
            border-radius: 6px;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
            font-size: 13px;
            border: 1px solid #e5e7eb;
            transition: border-color 0.2s ease;
        }
        .k8s-command-block:hover {
            border-color: #d1d5db;
        }
        .k8s-command-text {
            flex: 1;
            white-space: pre-wrap;
            word-wrap: break-word;
            color: #374151;
            font-weight: 400;
        }
        .k8s-copy-btn {
            background-color: #2563eb;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            white-space: nowrap;
            transition: background-color 0.2s ease;
        }
        .k8s-copy-btn:hover {
            background-color: #1d4ed8;
        }
        .k8s-copy-btn:active {
            background-color: #1e40af;
        }
        
        /* Custom scrollbar */
        #json-output::-webkit-scrollbar {
            width: 12px;
        }
        #json-output::-webkit-scrollbar-track {
            background: #f7fafc;
            border-radius: 6px;
        }
        #json-output::-webkit-scrollbar-thumb {
            background: #cbd5e0;
            border-radius: 6px;
        }
        #json-output::-webkit-scrollbar-thumb:hover {
            background: #a0aec0;
        }
        
        /* Responsive design */
        @media (max-width: 1024px) {
            .main-wrapper {
                flex-direction: column;
            }
            .sidebar {
                width: 100%;
                height: auto;
                max-height: 50vh;
                border-right: none;
                border-bottom: 1px solid #e5e7eb;
                position: relative;
            }
            .header-row {
                padding: 0 20px;
                padding-top: 20px;
                padding-bottom: 16px;
            }
            .container {
                padding: 20px;
            }
            #json-output {
                height: calc(100vh - 200px);
            }
        }
        @media (max-width: 768px) {
            .header-row {
                flex-direction: column;
                align-items: flex-start;
                gap: 12px;
            }
            .timestamp {
                margin-left: 0;
            }
            h1 {
                font-size: 24px;
            }
        }
        
        /* Subtle animations */
        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }
        
        .workload-item {
            animation: fadeIn 0.2s ease-out;
        }
    </style>
</head>
<body>
    <div class="main-wrapper">
        <div class="sidebar">
            <div class="sidebar-header">
                <h2>Filters</h2>
                <button class="sidebar-header-btn" onclick="clearAllFilters()">Clear All Filters</button>
                <button class="sidebar-header-btn" onclick="collapseAll()">Collapse All</button>
            </div>
            <div class="controls">
                <div class="filter-group">
                    <div class="namespace-filter-header" onclick="toggleNamespaceFilters()">
                        <div class="namespace-filter-header-left">
                            <span class="namespace-filter-toggle" id="namespace-filter-toggle">▶</span>
                            <span class="namespace-label" id="namespace-label">Namespace</span>
                            <button id="namespace-show-all-btn" class="namespace-show-all-btn" onclick="selectAllNamespaces(event)" style="display: none;">show all</button>
                        </div>
                    </div>
                    <div id="namespace-filter-footer" class="namespace-filter-footer">
                        <!-- Dynamically updated -->
                    </div>
                    <input type="text" id="namespace-search-box" class="namespace-search-box" placeholder="Search namespaces..." oninput="filterNamespacesBySearch()" style="display: none;">
                    <div id="namespace-search-message" class="search-message" style="display: none;"></div>
                    <div id="namespace-filters-container" class="namespace-filters-container">
                        <!-- Dynamically populated -->
                    </div>
                </div>
                <div class="filter-group">
                    <div class="workload-filter-header" onclick="toggleWorkloadFilters()">
                        <div class="workload-filter-header-left">
                            <span class="workload-filter-toggle" id="workload-filter-toggle">▶</span>
                            <span class="workload-label" id="workload-label">Workloads</span>
                            <button id="workload-show-all-btn" class="workload-show-all-btn" onclick="selectAllWorkloads(event)" style="display: none;">show all</button>
                        </div>
                    </div>
                    <div id="workload-filter-footer" class="workload-filter-footer">
                        <!-- Dynamically updated -->
                    </div>
                    <input type="text" id="workload-search-box" class="workload-search-box" placeholder="Search workloads..." oninput="filterWorkloadsBySearch()" style="display: none;">
                    <div id="workload-search-message" class="search-message" style="display: none;"></div>
                    <div id="workload-filters-container" class="workload-filters-container">
                        <!-- Dynamically populated -->
                    </div>
                </div>
                <div class="filter-group">
                    <div class="language-filter-header" onclick="toggleLanguageFilters()">
                        <div class="language-filter-header-left">
                            <span class="language-filter-toggle" id="language-filter-toggle">▶</span>
                            <span class="language-label" id="language-label">Programming Language</span>
                            <button id="language-show-all-btn" class="language-show-all-btn" onclick="selectAllLanguages(event)" style="display: none;">show all</button>
                        </div>
                    </div>
                    <div id="language-filter-footer" class="language-filter-footer">
                        <!-- Dynamically updated -->
                    </div>
                    <div id="language-filters-container" class="language-filters-container">
                        <!-- Dynamically populated -->
                    </div>
                </div>
                <div class="filter-group">
                    <span class="instrumentation-filter-label">Marked for Instrumentation</span>
                    <div class="instrumentation-filter">
                        <div class="instrumentation-checkbox-wrapper">
                            <input type="checkbox" id="filter-marked" class="instrumentation-checkbox" checked onchange="applyInstrumentationFilter()">
                            <label for="filter-marked" class="instrumentation-checkbox-label">
                                Marked
                                <span id="count-marked" class="instrumentation-count">(0)</span>
                            </label>
                        </div>
                        <div class="instrumentation-checkbox-wrapper">
                            <input type="checkbox" id="filter-not-marked" class="instrumentation-checkbox" checked onchange="applyInstrumentationFilter()">
                            <label for="filter-not-marked" class="instrumentation-checkbox-label">
                                Not Marked
                                <span id="count-not-marked" class="instrumentation-count">(0)</span>
                            </label>
                        </div>
                    </div>
                </div>
                <div class="filter-group">
                    <div class="health-status-filter-header" onclick="toggleHealthStatusFilters()">
                        <div class="health-status-filter-header-left">
                            <span class="health-status-filter-toggle" id="health-status-filter-toggle">▶</span>
                            <span class="health-status-label" id="health-status-label">Odigos Health</span>
                            <button id="health-status-show-all-btn" class="health-status-show-all-btn" onclick="selectAllHealthStatuses(event)" style="display: none;">show all</button>
                        </div>
                    </div>
                    <div id="health-status-filter-footer" class="health-status-filter-footer">
                        <!-- Dynamically updated -->
                    </div>
                    <div id="health-status-filters-container" class="health-status-filters-container">
                        <!-- Dynamically populated for health status filters -->
                    </div>
                </div>
                <div class="filter-group">
                    <div class="condition-filter-main-header" onclick="toggleConditionFilters()">
                        <div class="condition-filter-main-header-left">
                            <span class="condition-filter-main-toggle" id="condition-filter-main-toggle">▶</span>
                            <span class="condition-filter-main-label">Conditions</span>
                        </div>
                    </div>
                    <div id="condition-filters-container" class="condition-filters-container">
                        <!-- Dynamically populated for all conditions -->
                    </div>
                </div>
                <div class="filter-group">
                    <button class="btn" onclick="refreshData()">Refresh</button>
                    <button class="btn" onclick="expandAll()">Expand All</button>
                </div>
            </div>
        </div>
        <div class="main-content">
            <div class="header-row">
                <div class="header-left">
                    <div class="header-title-row">
                        <h1>Workloads</h1>
                        <div class="timestamp-container">
                            <span id="timestamp" class="timestamp"></span>
                            <button class="timestamp-refresh-btn" onclick="refreshData()">Refresh</button>
                        </div>
                    </div>
                    <div id="status-section" class="status-section" style="display: none;">
                        <div class="status-header" onclick="toggleStatusSection()" style="cursor: pointer; user-select: none; display: flex; align-items: center; gap: 6px; margin-bottom: 8px;">
                            <span class="status-toggle" id="status-toggle" style="width: 10px; height: 10px; display: inline-flex; align-items: center; justify-content: center; transition: transform 0.2s ease; color: #6b7280; font-size: 8px;">▶</span>
                            <h2 style="margin: 0; font-size: 14px; font-weight: 600; color: #111827;">Applied Filters</h2>
                            <span id="status-header-text" class="status-header-text"></span>
                            <button id="status-header-clear-btn" class="status-header-clear-btn" onclick="event.stopPropagation(); clearAllFilters();" style="display: none;">Clear All Filters</button>
                        </div>
                        <div id="status-content" class="status-content">
                            <ul id="status-filters-list" class="status-filters-list"></ul>
                        </div>
                    </div>
                    <div id="overview-section" class="overview-section" style="display: none;">
                        <div class="overview-header" onclick="toggleOverview()" style="cursor: pointer; user-select: none; display: flex; align-items: center; gap: 6px; margin-bottom: 8px;">
                            <span class="overview-toggle" id="overview-toggle" style="width: 10px; height: 10px; display: inline-flex; align-items: center; justify-content: center; transition: transform 0.2s ease; color: #6b7280; font-size: 8px;">▶</span>
                            <h2 style="margin: 0; font-size: 14px; font-weight: 600; color: #111827;">Cluster Overview</h2>
                            <span id="overview-header-stats" style="margin-left: auto; font-size: 12px; color: #6b7280; font-weight: 400;"></span>
                        </div>
                        <div id="overview-content" class="overview-content">
                        <div class="overview-stats">
                            <div class="overview-stat">
                                <span class="overview-stat-label">Total:</span>
                                <span class="overview-stat-value" id="overview-total">0 workloads found in cluster in 0 namespaces (excluding ignored namespaces)</span>
                            </div>
                            <div class="overview-stat">
                                <span class="overview-stat-label">Out of these:</span>
                            </div>
                            <div class="overview-stat" style="margin-left: 20px;">
                                <span class="overview-stat-label">•</span>
                                <span class="overview-stat-value" id="overview-marked">0 is marked to be instrumented by odigos</span>
                                <button class="overview-filter-btn" id="overview-marked-filter-btn" onclick="filterByMarkedStatus(true)" style="display: none;">filter these</button>
                            </div>
                            <div id="overview-health-status" style="display: none;">
                                <div id="overview-health-status-content" style="margin-left: 40px;">
                                    <!-- Dynamically populated -->
                                </div>
                            </div>
                            <div class="overview-stat" style="margin-left: 20px;">
                                <span class="overview-stat-label">•</span>
                                <span class="overview-stat-value" id="overview-not-marked">0 is not marked to be instrumented by odigos</span>
                                <button class="overview-filter-btn" id="overview-not-marked-filter-btn" onclick="filterByMarkedStatus(false)" style="display: none;">filter these</button>
                            </div>
                        </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="container">
                <div id="json-output" class="loading">Loading...</div>
            </div>
        </div>
    </div>
    <script>
        function getStatusEmoji(statusValue) {
            if (!statusValue || typeof statusValue !== 'string') {
                return '';
            }
            const statusEmojis = {
                'error': '⚠️',
                'failure': '❌',
                'notice': '📢',
                'pending': '⏳',
                'waiting': '⏱️',
                'unsupported': '🚫',
                'disabled': '⏸️',
                'success': '✅',
                'irrelevant': '➖',
                'unknown': '❓'
            };
            return statusEmojis[statusValue.toLowerCase()] || '';
        }
        
        function getStatusProperties(statusValue) {
            if (!statusValue || typeof statusValue !== 'string') {
                return null;
            }
            const statusLower = statusValue.toLowerCase();
            const properties = {
                'error': {
                    desiredState: 'Unknown',
                    permanence: 'Unknown',
                    userAction: 'Unknown'
                },
                'failure': {
                    desiredState: 'No',
                    permanence: 'Permanent',
                    userAction: 'Yes - investigate or disable'
                },
                'notice': {
                    desiredState: 'No',
                    permanence: 'Permanent',
                    userAction: 'Yes - rollout or investigate'
                },
                'pending': {
                    desiredState: 'No',
                    permanence: 'Transient (long term)',
                    userAction: 'No'
                },
                'waiting': {
                    desiredState: 'No',
                    permanence: 'Transient (short term)',
                    userAction: 'No'
                },
                'unsupported': {
                    desiredState: 'No',
                    permanence: 'Permanent',
                    userAction: 'No - informational only'
                },
                'disabled': {
                    desiredState: 'Yes',
                    permanence: 'Permanent',
                    userAction: 'No - informational only'
                },
                'success': {
                    desiredState: 'Yes',
                    permanence: 'Permanent',
                    userAction: 'No'
                },
                'irrelevant': {
                    desiredState: 'Not applicable',
                    permanence: 'Not applicable',
                    userAction: 'Not applicable'
                },
                'unknown': {
                    desiredState: 'Unknown',
                    permanence: 'Unknown',
                    userAction: 'Unknown'
                }
            };
            return properties[statusLower] || null;
        }
        
        function getStatusTooltip(statusValue) {
            if (!statusValue || typeof statusValue !== 'string') {
                return statusValue || '';
            }
            const statusLower = statusValue.toLowerCase();
            const tooltips = {
                'error': 'Error - Odigos failed to determine the current or desired state due to an internal error. The actual status is unknown.',
                'failure': 'Failure - Workload is not in desired state due to a permanent issue. Manual investigation or disabling is required.',
                'notice': 'Notice - Workload is not in desired state due to a permanent issue. Manual rollout or investigation is required.',
                'pending': 'Pending - Workload is waiting for a transient long term event to progress with instrumentation. No manual involvement is needed.',
                'waiting': 'Waiting - Workload is waiting for a transient short term event to progress with instrumentation. No manual involvement is needed.',
                'unsupported': 'Unsupported - Workload cannot reach desired state due to permanent limitations (e.g., unknown language or no agent available). This is informational only.',
                'disabled': 'Disabled - Workload is in desired state but instrumentation is disabled by user settings. This is informational only.',
                'success': 'Success - Workload is in its desired state.',
                'irrelevant': 'Irrelevant - This condition is not applicable yet in the current context.',
                'unknown': 'Unknown - Status could not be determined.'
            };
            return tooltips[statusLower] || statusValue;
        }
        
        function getStatusPropertiesText(statusValue) {
            const properties = getStatusProperties(statusValue);
            if (!properties) {
                return '';
            }
            const parts = [];
            parts.push(`Desired state: ${properties.desiredState}`);
            parts.push(`Permanence: ${properties.permanence}`);
            parts.push(`User action: ${properties.userAction}`);
            return parts.join(' • ');
        }
        
        function parseCamelCase(text) {
            if (!text || typeof text !== 'string') {
                return text;
            }
            // Insert a space before each capital letter that follows a lowercase letter or number
            // Also handle consecutive capitals followed by lowercase (e.g., "API" -> "API")
            return text.replace(/([a-z0-9])([A-Z])/g, '$1 $2')
                      .replace(/([A-Z]+)([A-Z][a-z])/g, '$1 $2')
                      .trim();
        }
        
        function renderJSON(data, parent, key = null, emoji = null, emojiTooltip = null) {
            const item = document.createElement('div');
            item.className = 'json-item';
            
            if (key !== null) {
                const keySpan = document.createElement('span');
                keySpan.className = 'json-key';
                
                // Add emoji with tooltip if provided
                if (emoji) {
                    const tooltipWrapper = document.createElement('span');
                    tooltipWrapper.className = 'emoji-tooltip-wrapper';
                    
                    const emojiSpan = document.createElement('span');
                    emojiSpan.textContent = emoji + ' ';
                    emojiSpan.style.cursor = 'help';
                    tooltipWrapper.appendChild(emojiSpan);
                    
                    const tooltipDiv = document.createElement('div');
                    tooltipDiv.className = 'emoji-tooltip';
                    tooltipDiv.textContent = emojiTooltip && emojiTooltip.trim() 
                        ? emojiTooltip 
                        : 'Test tooltip message - this should appear on hover';
                    tooltipWrapper.appendChild(tooltipDiv);
                    
                    keySpan.appendChild(tooltipWrapper);
                }
                
                keySpan.appendChild(document.createTextNode(key + ': '));
                item.appendChild(keySpan);
            }
            
            if (data === null) {
                const nullSpan = document.createElement('span');
                nullSpan.className = 'json-null';
                nullSpan.textContent = 'null';
                item.appendChild(nullSpan);
                parent.appendChild(item);
                return;
            }
            
            const type = typeof data;
            
            if (type === 'string' || type === 'number' || type === 'boolean') {
                const valueSpan = document.createElement('span');
                
                // Special handling for status fields
                if (type === 'string' && key === 'status') {
                    const statusValue = data.toLowerCase();
                    const statusClasses = {
                        'error': 'status-error',
                        'failure': 'status-failure',
                        'notice': 'status-notice',
                        'pending': 'status-pending',
                        'waiting': 'status-waiting',
                        'unsupported': 'status-unsupported',
                        'disabled': 'status-disabled',
                        'success': 'status-success',
                        'irrelevant': 'status-irrelevant',
                        'unknown': 'status-unknown'
                    };
                    
                    const emoji = getStatusEmoji(data);
                    const statusClass = statusClasses[statusValue] || 'json-string';
                    
                    valueSpan.className = statusClass;
                    valueSpan.textContent = emoji + ' "' + data + '"';
                } else {
                    valueSpan.className = 'json-' + type;
                    if (type === 'string') {
                        valueSpan.textContent = '"' + data + '"';
                    } else {
                        valueSpan.textContent = data;
                    }
                }
                
                item.appendChild(valueSpan);
                parent.appendChild(item);
                return;
            }
            
            if (Array.isArray(data)) {
                const toggle = document.createElement('span');
                toggle.className = 'toggle';
                toggle.textContent = '';
                item.appendChild(toggle);
                
                const bracket = document.createElement('span');
                bracket.textContent = '[' + data.length + ']';
                item.appendChild(bracket);
                
                const children = document.createElement('div');
                children.className = 'children';
                
                data.forEach((val, idx) => {
                    let itemKey = idx;
                    // Use containerName for containers array
                    if (key === 'containers' && val && typeof val === 'object' && val.containerName) {
                        itemKey = val.containerName;
                    }
                    renderJSON(val, children, itemKey);
                });
                
                item.appendChild(children);
                item.classList.add('expandable');
                
                const toggleFunc = (e) => {
                    if (e) {
                        e.stopPropagation();
                    }
                    toggle.classList.toggle('expanded');
                    children.classList.toggle('expanded');
                };
                
                toggle.onclick = (e) => {
                    e.stopPropagation();
                    toggleFunc();
                };
                item.onclick = (e) => {
                    e.stopPropagation();
                    toggleFunc();
                };
                parent.appendChild(item);
                return;
            }
            
            if (type === 'object') {
                // Check if this is a status object (has both status and message fields)
                const isStatusObject = data.status && typeof data.status === 'string' && data.message;
                let statusEmoji = null;
                let statusMessage = null;
                
                if (isStatusObject) {
                    statusEmoji = getStatusEmoji(data.status);
                    statusMessage = typeof data.message === 'string' ? data.message : '';
                }
                
                const toggle = document.createElement('span');
                toggle.className = 'toggle';
                toggle.textContent = '';
                item.appendChild(toggle);
                
                // Add emoji for status objects
                if (statusEmoji && key !== null) {
                    const tooltipWrapper = document.createElement('span');
                    tooltipWrapper.className = 'emoji-tooltip-wrapper';
                    
                    const emojiSpan = document.createElement('span');
                    emojiSpan.textContent = statusEmoji + ' ';
                    emojiSpan.style.cursor = 'help';
                    tooltipWrapper.appendChild(emojiSpan);
                    
                    const tooltipDiv = document.createElement('div');
                    tooltipDiv.className = 'emoji-tooltip';
                    tooltipDiv.textContent = statusMessage || '';
                    tooltipWrapper.appendChild(tooltipDiv);
                    
                    item.appendChild(tooltipWrapper);
                }
                
                const children = document.createElement('div');
                children.className = 'children';
                
                Object.keys(data).forEach(k => {
                    renderJSON(data[k], children, k);
                });
                
                item.appendChild(children);
                item.classList.add('expandable');
                
                const toggleFunc = (e) => {
                    if (e) {
                        e.stopPropagation();
                    }
                    toggle.classList.toggle('expanded');
                    children.classList.toggle('expanded');
                };
                
                toggle.onclick = (e) => {
                    e.stopPropagation();
                    toggleFunc();
                };
                item.onclick = (e) => {
                    e.stopPropagation();
                    toggleFunc();
                };
                parent.appendChild(item);
                return;
            }
        }
        
        function expandAll() {
            // Expand JSON display
            const toggles = document.querySelectorAll('.toggle');
            const children = document.querySelectorAll('.children');
            toggles.forEach(toggle => toggle.classList.add('expanded'));
            children.forEach(child => child.classList.add('expanded'));
            
            // Expand filter sections
            // Namespace filters
            const namespaceContainer = document.getElementById('namespace-filters-container');
            const namespaceToggle = document.getElementById('namespace-filter-toggle');
            const namespaceSearchBox = document.getElementById('namespace-search-box');
            if (namespaceContainer && namespaceToggle) {
                namespaceContainer.classList.add('expanded');
                namespaceToggle.classList.add('expanded');
                if (namespaceSearchBox) {
                    namespaceSearchBox.style.display = 'block';
                }
            }
            
            // Workload filters
            const workloadContainer = document.getElementById('workload-filters-container');
            const workloadToggle = document.getElementById('workload-filter-toggle');
            const workloadSearchBox = document.getElementById('workload-search-box');
            if (workloadContainer && workloadToggle) {
                workloadContainer.classList.add('expanded');
                workloadToggle.classList.add('expanded');
                if (workloadSearchBox) {
                    workloadSearchBox.style.display = 'block';
                }
            }
            
            // Language filters
            const languageContainer = document.getElementById('language-filters-container');
            const languageToggle = document.getElementById('language-filter-toggle');
            if (languageContainer && languageToggle) {
                languageContainer.classList.add('expanded');
                languageToggle.classList.add('expanded');
            }
            
            // Condition filters (main container)
            const conditionMainContainer = document.getElementById('condition-filters-container');
            const conditionMainToggle = document.getElementById('condition-filter-main-toggle');
            if (conditionMainContainer && conditionMainToggle) {
                conditionMainContainer.classList.add('expanded');
                conditionMainToggle.classList.add('expanded');
            }
            
            // Individual condition filter groups
            const conditionContainers = document.querySelectorAll('.condition-filter-content');
            const conditionToggles = document.querySelectorAll('.condition-filter-toggle');
            conditionContainers.forEach(container => container.classList.add('expanded'));
            conditionToggles.forEach(toggle => toggle.classList.add('expanded'));
        }
        
        function collapseAll() {
            // Collapse JSON display
            const toggles = document.querySelectorAll('.toggle');
            const children = document.querySelectorAll('.children');
            toggles.forEach(toggle => toggle.classList.remove('expanded'));
            children.forEach(child => child.classList.remove('expanded'));
            
            // Collapse filter sections
            // Namespace filters
            const namespaceContainer = document.getElementById('namespace-filters-container');
            const namespaceToggle = document.getElementById('namespace-filter-toggle');
            const namespaceSearchBox = document.getElementById('namespace-search-box');
            const namespaceSearchMessage = document.getElementById('namespace-search-message');
            if (namespaceContainer && namespaceToggle) {
                namespaceContainer.classList.remove('expanded');
                namespaceToggle.classList.remove('expanded');
                if (namespaceSearchBox) {
                    namespaceSearchBox.style.display = 'none';
                }
                if (namespaceSearchMessage) {
                    namespaceSearchMessage.style.display = 'none';
                }
            }
            
            // Workload filters
            const workloadContainer = document.getElementById('workload-filters-container');
            const workloadToggle = document.getElementById('workload-filter-toggle');
            const workloadSearchBox = document.getElementById('workload-search-box');
            const workloadSearchMessage = document.getElementById('workload-search-message');
            if (workloadContainer && workloadToggle) {
                workloadContainer.classList.remove('expanded');
                workloadToggle.classList.remove('expanded');
                if (workloadSearchBox) {
                    workloadSearchBox.style.display = 'none';
                }
                if (workloadSearchMessage) {
                    workloadSearchMessage.style.display = 'none';
                }
            }
            
            // Language filters
            const languageContainer = document.getElementById('language-filters-container');
            const languageToggle = document.getElementById('language-filter-toggle');
            if (languageContainer && languageToggle) {
                languageContainer.classList.remove('expanded');
                languageToggle.classList.remove('expanded');
            }
            
            // Health status filters
            const healthStatusContainer = document.getElementById('health-status-filters-container');
            const healthStatusToggle = document.getElementById('health-status-filter-toggle');
            if (healthStatusContainer && healthStatusToggle) {
                healthStatusContainer.classList.remove('expanded');
                healthStatusToggle.classList.remove('expanded');
            }
            
            // Condition filters (main container)
            const conditionMainContainer = document.getElementById('condition-filters-container');
            const conditionMainToggle = document.getElementById('condition-filter-main-toggle');
            if (conditionMainContainer && conditionMainToggle) {
                conditionMainContainer.classList.remove('expanded');
                conditionMainToggle.classList.remove('expanded');
            }
            
            // Individual condition filter groups
            const conditionContainers = document.querySelectorAll('.condition-filter-content');
            const conditionToggles = document.querySelectorAll('.condition-filter-toggle');
            conditionContainers.forEach(container => container.classList.remove('expanded'));
            conditionToggles.forEach(toggle => toggle.classList.remove('expanded'));
        }
        
        let lastUpdateTime = null;
        let durationInterval = null;
        
        function formatDuration(seconds) {
            if (seconds < 60) {
                return seconds + ' second' + (seconds !== 1 ? 's' : '');
            }
            
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            
            if (minutes < 60) {
                if (remainingSeconds === 0) {
                    return minutes + ' minute' + (minutes !== 1 ? 's' : '');
                }
                return minutes + ' minute' + (minutes !== 1 ? 's' : '') + ' and ' + 
                       remainingSeconds + ' second' + (remainingSeconds !== 1 ? 's' : '');
            }
            
            const hours = Math.floor(minutes / 60);
            const remainingMinutes = minutes % 60;
            
            if (remainingMinutes === 0) {
                return hours + ' hour' + (hours !== 1 ? 's' : '');
            }
            return hours + ' hour' + (hours !== 1 ? 's' : '') + ' and ' + 
                   remainingMinutes + ' minute' + (remainingMinutes !== 1 ? 's' : '');
        }
        
        function updateDuration() {
            if (!lastUpdateTime) return;
            
            const now = new Date();
            const seconds = Math.floor((now - lastUpdateTime) / 1000);
            const durationEl = document.getElementById('timestamp-duration');
            
            if (durationEl) {
                const durationText = formatDuration(seconds);
                durationEl.textContent = '(' + durationText + ' ago)';
                
                // Color red if more than 5 minutes
                if (seconds > 300) {
                    durationEl.classList.add('old');
                } else {
                    durationEl.classList.remove('old');
                }
            }
        }
        
        function updateTimestamp() {
            const timestampEl = document.getElementById('timestamp');
            const now = new Date();
            lastUpdateTime = now;
            timestampEl.innerHTML = 'Last updated: ' + now.toLocaleString() + 
                ' <span id="timestamp-duration" class="timestamp-duration"></span>';
            
            // Clear existing interval
            if (durationInterval) {
                clearInterval(durationInterval);
            }
            
            // Update duration immediately and then every second
            updateDuration();
            durationInterval = setInterval(updateDuration, 1000);
        }
        
        function refreshData() {
            const output = document.getElementById('json-output');
            output.classList.add('loading');
            output.textContent = 'Loading...';
            
            // Save current filter state before refreshing
            updateUrlParams();
            
            const url = '/workload?verbosity=verbose';
            fetch(url)
                .then(response => response.json())
                .then(data => {
                    loadData(data);
                    updateTimestamp();
                })
                .catch(error => {
                    output.textContent = 'Error: ' + error.message;
                    output.classList.add('error');
                    output.classList.remove('loading');
                });
        }
        
        let allWorkloadData = [];
        
        // URL parameter handling for filter persistence
        function getUrlParams() {
            const params = new URLSearchParams(window.location.search);
            return {
                namespaces: params.getAll('namespace') || [],
                workloads: params.getAll('workload') || [],
                languages: params.getAll('language') || [],
                marked: params.get('marked') || 'true', // default to true
                notMarked: params.get('notMarked') || 'true', // default to true
                conditions: params.getAll('condition') || [],
                healthStatuses: params.getAll('healthStatus') || []
            };
        }
        
        function updateUrlParams() {
            const params = new URLSearchParams();
            
            // Namespace filter(s) - only include if not all are selected
            const selectedNamespaces = getSelectedNamespaces();
            const allNamespaceCheckboxes = document.querySelectorAll('.namespace-checkbox');
            const allNamespaces = Array.from(allNamespaceCheckboxes).map(cb => cb.dataset.namespace);
            if (selectedNamespaces.length > 0 && selectedNamespaces.length < allNamespaces.length) {
                selectedNamespaces.forEach(ns => {
                    params.append('namespace', ns);
                });
            }
            
            // Workload filter(s) - only include if not all are selected
            const selectedWorkloads = getSelectedWorkloads();
            const allWorkloadCheckboxes = document.querySelectorAll('.workload-checkbox');
            if (selectedWorkloads.length > 0 && selectedWorkloads.length < allWorkloadCheckboxes.length) {
                selectedWorkloads.forEach(workload => {
                    params.append('workload', `${workload.namespace}:${workload.name}`);
                });
            }
            
            // Language filter(s) - only include if not all are selected
            const selectedLanguages = getSelectedLanguages();
            const allLanguageCheckboxes = document.querySelectorAll('.language-checkbox');
            const allLanguages = Array.from(allLanguageCheckboxes).map(cb => cb.dataset.language);
            if (selectedLanguages.length > 0 && selectedLanguages.length < allLanguages.length) {
                selectedLanguages.forEach(lang => {
                    params.append('language', lang);
                });
            }
            
            // Marked for instrumentation filters
            const markedChecked = document.getElementById('filter-marked').checked;
            const notMarkedChecked = document.getElementById('filter-not-marked').checked;
            if (!markedChecked) {
                params.set('marked', 'false');
            }
            if (!notMarkedChecked) {
                params.set('notMarked', 'false');
            }
            
            // Condition filters
            const conditionCheckboxes = document.querySelectorAll('.condition-checkbox');
            conditionCheckboxes.forEach(checkbox => {
                if (!checkbox.checked) {
                    const conditionName = checkbox.dataset.conditionName;
                    const reasonEnum = checkbox.dataset.reasonEnum;
                    params.append('condition', `${conditionName}:${reasonEnum}`);
                }
            });
            
            // Health status filters
            const healthStatusCheckboxes = document.querySelectorAll('.health-status-checkbox');
            healthStatusCheckboxes.forEach(checkbox => {
                if (!checkbox.checked) {
                    const status = checkbox.dataset.status;
                    const name = checkbox.dataset.name;
                    const reasonEnum = checkbox.dataset.reasonEnum;
                    params.append('healthStatus', `${status}|${name}|${reasonEnum}`);
                }
            });
            
            // Update URL without reloading
            const newUrl = window.location.pathname + (params.toString() ? '?' + params.toString() : '');
            window.history.replaceState({}, '', newUrl);
        }
        
        function applyUrlParams() {
            const urlParams = getUrlParams();
            
            // Apply namespace filters - will be applied after checkboxes are created
            if (urlParams.namespaces.length > 0) {
                window.pendingNamespaceFilters = urlParams.namespaces;
            }
            
            // Apply workload filters - will be applied after checkboxes are created
            if (urlParams.workloads.length > 0) {
                window.pendingWorkloadFilters = urlParams.workloads;
            }
            
            // Apply language filters - will be applied after checkboxes are created
            if (urlParams.languages.length > 0) {
                window.pendingLanguageFilters = urlParams.languages;
            }
            
            // Apply name filter (after namespace is set)
            if (urlParams.name) {
                const nameSelect = document.getElementById('name');
                if (nameSelect) {
                    nameSelect.value = urlParams.name;
                }
            }
            
            // Apply marked for instrumentation filters
            const markedCheckbox = document.getElementById('filter-marked');
            const notMarkedCheckbox = document.getElementById('filter-not-marked');
            if (markedCheckbox) {
                markedCheckbox.checked = urlParams.marked !== 'false';
            }
            if (notMarkedCheckbox) {
                notMarkedCheckbox.checked = urlParams.notMarked !== 'false';
            }
            
            // Apply health status filters - will be applied after filters are populated
            if (urlParams.healthStatuses.length > 0) {
                window.pendingHealthStatusFilters = urlParams.healthStatuses;
            }
            
            // Apply condition filters
            // This will be called after condition filters are populated
            if (urlParams.conditions.length > 0) {
                // Store conditions to apply after filters are created
                window.pendingConditionFilters = urlParams.conditions;
            }
        }
        
        function applyPendingNamespaceFilters() {
            if (!window.pendingNamespaceFilters || window.pendingNamespaceFilters.length === 0) {
                return;
            }
            
            // First, uncheck all namespace checkboxes
            const allNamespaceCheckboxes = document.querySelectorAll('.namespace-checkbox');
            allNamespaceCheckboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
            
            // Then check the ones specified in URL params
            window.pendingNamespaceFilters.forEach(namespace => {
                const checkbox = document.querySelector(`.namespace-checkbox[data-namespace="${namespace}"]`);
                if (checkbox) {
                    checkbox.checked = true;
                }
            });
            
            // Update and apply filters
            updateNamespaceCounts();
            updateNamespaceCountDisplay();
            updateNamespaceHeaderButton();
            updateWorkloadLabel();
            applyNamespaceFilter();
            
            // Clear pending filters
            window.pendingNamespaceFilters = null;
        }
        
        function applyPendingWorkloadFilters() {
            if (!window.pendingWorkloadFilters || window.pendingWorkloadFilters.length === 0) {
                return;
            }
            
            // First, uncheck all workload checkboxes
            const allWorkloadCheckboxes = document.querySelectorAll('.workload-checkbox');
            allWorkloadCheckboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
            
            // Then check the ones specified in URL params
            window.pendingWorkloadFilters.forEach(workloadParam => {
                const [namespace, name] = workloadParam.split(':');
                const checkbox = document.querySelector(`.workload-checkbox[data-namespace="${namespace}"][data-workload-name="${name}"]`);
                if (checkbox) {
                    checkbox.checked = true;
                }
            });
            
            // Update and apply filters
            updateWorkloadCounts();
            updateWorkloadCountDisplay();
            updateWorkloadHeaderButton();
            applyWorkloadFilter();
            
            // Clear pending filters
            window.pendingWorkloadFilters = null;
        }
        
        function applyPendingLanguageFilters() {
            if (!window.pendingLanguageFilters) return;
            
            const pendingLanguages = window.pendingLanguageFilters;
            const allLanguageCheckboxes = document.querySelectorAll('.language-checkbox');
            
            // Uncheck all first
            allLanguageCheckboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
            
            // Check only the pending languages
            allLanguageCheckboxes.forEach(checkbox => {
                const language = checkbox.dataset.language;
                if (pendingLanguages.includes(language)) {
                    checkbox.checked = true;
                }
            });
            
            // Update and apply filters
            updateLanguageCounts();
            updateLanguageCountDisplay();
            applyLanguageFilter();
            
            // Clear pending filters
            window.pendingLanguageFilters = null;
        }
        
        function applyPendingHealthStatusFilters() {
            if (!window.pendingHealthStatusFilters || window.pendingHealthStatusFilters.length === 0) {
                return;
            }
            
            // First, check all health status checkboxes
            const allHealthStatusCheckboxes = document.querySelectorAll('.health-status-checkbox');
            allHealthStatusCheckboxes.forEach(checkbox => {
                checkbox.checked = true;
            });
            
            // Then uncheck the ones specified in URL params
            window.pendingHealthStatusFilters.forEach(healthStatusParam => {
                const [status, name, reasonEnum] = healthStatusParam.split('|');
                const checkbox = document.querySelector(
                    `.health-status-checkbox[data-status="${status}"][data-name="${name}"][data-reason-enum="${reasonEnum}"]`
                );
                if (checkbox) {
                    checkbox.checked = false;
                }
            });
            
            // Update counts and apply filters
            updateHealthStatusCountDisplay();
            updateHealthStatusHeaderButton();
            applyHealthStatusFilters();
            
            // Clear pending filters
            window.pendingHealthStatusFilters = null;
        }
        
        function applyPendingConditionFilters() {
            if (!window.pendingConditionFilters || window.pendingConditionFilters.length === 0) {
                return;
            }
            
            // First, check all condition checkboxes
            const allConditionCheckboxes = document.querySelectorAll('.condition-checkbox');
            allConditionCheckboxes.forEach(checkbox => {
                checkbox.checked = true;
            });
            
            // Then uncheck the ones specified in URL params
            window.pendingConditionFilters.forEach(conditionParam => {
                const [conditionName, reasonEnum] = conditionParam.split(':');
                const checkbox = document.querySelector(
                    `.condition-checkbox[data-condition-name="${conditionName}"][data-reason-enum="${reasonEnum}"]`
                );
                if (checkbox) {
                    checkbox.checked = false;
                }
            });
            
            // Update counts and apply filters
            updateAllConditionFilterCounts();
            updateAllConditionFilterAllButtons();
            applyConditionFilters();
            
            // Clear pending filters
            window.pendingConditionFilters = null;
        }
        
        function populateNamespaceCheckboxes(data) {
            const filtersContainer = document.getElementById('namespace-filters-container');
            filtersContainer.innerHTML = '';
            
            // Extract unique namespaces with counts
            const namespaceMap = new Map(); // namespace -> count
            if (Array.isArray(data)) {
                data.forEach(item => {
                    if (item && item.id && item.id.namespace) {
                        const ns = item.id.namespace;
                        namespaceMap.set(ns, (namespaceMap.get(ns) || 0) + 1);
                    }
                });
            }
            
            // Get currently checked namespaces
            const checkedNamespaces = new Set();
            const existingCheckboxes = document.querySelectorAll('.namespace-checkbox');
            existingCheckboxes.forEach(cb => {
                if (cb.checked) {
                    checkedNamespaces.add(cb.dataset.namespace);
                }
            });
            
            // Sort namespaces alphabetically
            const sortedNamespaces = Array.from(namespaceMap.entries()).sort((a, b) => 
                a[0].localeCompare(b[0])
            );
            
            // Create checkboxes for each namespace
            sortedNamespaces.forEach(([namespace, count]) => {
                const wrapper = document.createElement('div');
                wrapper.className = 'namespace-checkbox-wrapper';
                wrapper.dataset.namespace = namespace;
                if (count === 0) {
                    wrapper.classList.add('filter-zero-count');
                }
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `filter-namespace-${namespace}`;
                checkbox.className = 'namespace-checkbox';
                checkbox.dataset.namespace = namespace;
                // Check if this namespace was previously checked, or check all by default
                checkbox.checked = checkedNamespaces.has(namespace) || checkedNamespaces.size === 0;
                checkbox.onchange = () => {
                    updateNamespaceCounts();
                    updateNamespaceCountDisplay();
                    updateNamespaceHeaderButton();
                    updateWorkloadLabel();
                    applyNamespaceFilter();
                };
                
                    // Add "only" button
                    const onlyBtn = document.createElement('button');
                    onlyBtn.className = 'namespace-only-btn';
                    onlyBtn.textContent = 'only';
                    onlyBtn.title = 'filter to show only this namespace';
                    onlyBtn.onclick = (e) => {
                        e.stopPropagation();
                        // Uncheck all namespace checkboxes (regardless of search filter)
                        const allNamespaceCheckboxes = document.querySelectorAll('.namespace-checkbox');
                        allNamespaceCheckboxes.forEach(cb => {
                            cb.checked = false;
                        });
                        // Check only this checkbox
                        checkbox.checked = true;
                        // Clear search box
                        const searchBox = document.getElementById('namespace-search-box');
                        if (searchBox) {
                            searchBox.value = '';
                            filterNamespacesBySearch();
                        }
                        updateNamespaceCounts();
                        updateNamespaceCountDisplay();
                        updateNamespaceHeaderButton();
                        updateWorkloadLabel();
                        updateUrlParams();
                        applyNamespaceFilter();
                    };
                    wrapper.appendChild(onlyBtn);
                
                wrapper.appendChild(checkbox);
                
                const label = document.createElement('label');
                label.htmlFor = `filter-namespace-${namespace}`;
                label.className = 'namespace-checkbox-label';
                
                const countSpan = document.createElement('span');
                countSpan.id = `count-namespace-${namespace}`;
                countSpan.className = 'namespace-count';
                countSpan.textContent = `(${count}) `;
                label.appendChild(countSpan);
                
                label.appendChild(document.createTextNode(namespace));
                
                wrapper.appendChild(label);
                
                filtersContainer.appendChild(wrapper);
            });
            
            updateNamespaceCounts();
            updateNamespaceCountDisplay();
            updateNamespaceHeaderButton();
            updateWorkloadLabel();
            updateNamespaceHeaderCount();
        }
        
        function updateNamespaceHeaderCount() {
            const label = document.getElementById('namespace-label');
            if (!label) return;
            const count = document.querySelectorAll('.namespace-checkbox').length;
            label.textContent = `Namespace (${count})`;
        }
        
        function filterNamespacesBySearch() {
            const searchBox = document.getElementById('namespace-search-box');
            if (!searchBox) return;
            
            const searchText = searchBox.value.toLowerCase().trim();
            const allWrappers = document.querySelectorAll('.namespace-checkbox-wrapper');
            const messageElement = document.getElementById('namespace-search-message');
            
            let visibleCount = 0;
            const totalCount = allWrappers.length;
            
            allWrappers.forEach(wrapper => {
                const namespace = wrapper.dataset.namespace || '';
                const searchableText = namespace.toLowerCase();
                
                if (searchText === '' || searchableText.includes(searchText)) {
                    wrapper.classList.remove('hidden');
                    if (searchText !== '') {
                        visibleCount++;
                    }
                } else {
                    wrapper.classList.add('hidden');
                }
            });
            
            // Update search message
            if (messageElement) {
                if (searchText !== '') {
                    if (visibleCount === 0) {
                        messageElement.textContent = `No namespaces matched "${searchText}". Check for typos or try a different search term. Other namespaces may still be selected.`;
                    } else {
                        messageElement.textContent = `Showing ${visibleCount}/${totalCount} namespaces that matched the search term. Other namespaces may still be selected.`;
                    }
                    messageElement.style.display = 'block';
                } else {
                    messageElement.style.display = 'none';
                }
            }
        }
        
        function formatFilterFooter(selectedItems, totalCount, itemType) {
            if (selectedItems.length === totalCount && totalCount > 0) {
                return '';
            }
            
            if (selectedItems.length <= 2 && selectedItems.length > 0) {
                const itemsText = selectedItems.join(', ');
                return `${selectedItems.length}/${totalCount} selected: ${itemsText}`;
            }
            
            return `${selectedItems.length}/${totalCount} selected`;
        }
        
        function updateNamespaceCountDisplay() {
            const footer = document.getElementById('namespace-filter-footer');
            if (!footer) return;
            
            const allNamespaceCheckboxes = document.querySelectorAll('.namespace-checkbox');
            const selectedNamespaces = getSelectedNamespaces();
            const totalNamespaces = allNamespaceCheckboxes.length;
            
            footer.textContent = formatFilterFooter(selectedNamespaces, totalNamespaces, 'namespaces');
        }
        
        function updateNamespaceCounts() {
            // Count workloads per namespace from entire cluster (always show total, not filtered)
            let dataToCount = allWorkloadData;
            
            // Count per namespace from entire cluster
            const namespaceCounts = new Map();
            dataToCount.forEach(item => {
                if (item && item.id && item.id.namespace) {
                    const ns = item.id.namespace;
                    namespaceCounts.set(ns, (namespaceCounts.get(ns) || 0) + 1);
                }
            });
            
            // Update counts and zero-count styling
            const allNamespaceWrappers = document.querySelectorAll('.namespace-checkbox-wrapper');
            allNamespaceWrappers.forEach(wrapper => {
                const namespace = wrapper.dataset.namespace;
                const count = namespaceCounts.get(namespace) || 0;
                const countSpan = document.getElementById(`count-namespace-${namespace}`);
                if (countSpan) {
                    countSpan.textContent = `(${count}) `;
                }
                // Update zero-count class
                if (count === 0) {
                    wrapper.classList.add('filter-zero-count');
                } else {
                    wrapper.classList.remove('filter-zero-count');
                }
            });
        }
        
        function getSelectedNamespaces() {
            const selected = [];
            const checkboxes = document.querySelectorAll('.namespace-checkbox');
            checkboxes.forEach(checkbox => {
                if (checkbox.checked) {
                    selected.push(checkbox.dataset.namespace);
                }
            });
            return selected;
        }
        
        function toggleNamespaceFilters() {
            const container = document.getElementById('namespace-filters-container');
            const toggle = document.getElementById('namespace-filter-toggle');
            const searchBox = document.getElementById('namespace-search-box');
            const messageElement = document.getElementById('namespace-search-message');
            container.classList.toggle('expanded');
            toggle.classList.toggle('expanded');
            // Show/hide search box based on expanded state
            if (searchBox) {
                if (container.classList.contains('expanded')) {
                    searchBox.style.display = 'block';
                } else {
                    searchBox.style.display = 'none';
                    if (messageElement) {
                        messageElement.style.display = 'none';
                    }
                }
            }
        }
        
        function toggleWorkloadFilters() {
            const container = document.getElementById('workload-filters-container');
            const toggle = document.getElementById('workload-filter-toggle');
            const searchBox = document.getElementById('workload-search-box');
            const messageElement = document.getElementById('workload-search-message');
            container.classList.toggle('expanded');
            toggle.classList.toggle('expanded');
            // Show/hide search box based on expanded state
            if (searchBox) {
                if (container.classList.contains('expanded')) {
                    searchBox.style.display = 'block';
                } else {
                    searchBox.style.display = 'none';
                    if (messageElement) {
                        messageElement.style.display = 'none';
                    }
                }
            }
        }
        
        function toggleLanguageFilters() {
            const container = document.getElementById('language-filters-container');
            const toggle = document.getElementById('language-filter-toggle');
            container.classList.toggle('expanded');
            toggle.classList.toggle('expanded');
        }
        
        function toggleConditionFilters() {
            const container = document.getElementById('condition-filters-container');
            const toggle = document.getElementById('condition-filter-main-toggle');
            container.classList.toggle('expanded');
            toggle.classList.toggle('expanded');
        }
        
        function updateNamespaceHeaderButton() {
            const showAllBtn = document.getElementById('namespace-show-all-btn');
            if (!showAllBtn) return;
            
            const allNamespaceCheckboxes = document.querySelectorAll('.namespace-checkbox');
            const selectedNamespaces = getSelectedNamespaces();
            
            // Show button only if not all are selected
            if (selectedNamespaces.length < allNamespaceCheckboxes.length && allNamespaceCheckboxes.length > 0) {
                showAllBtn.style.display = 'inline-block';
            } else {
                showAllBtn.style.display = 'none';
            }
        }
        
        function selectAllNamespaces(event) {
            event.stopPropagation(); // Prevent toggling the filter group
            const allNamespaceCheckboxes = document.querySelectorAll('.namespace-checkbox');
            allNamespaceCheckboxes.forEach(checkbox => {
                checkbox.checked = true;
            });
            updateNamespaceCounts();
            updateNamespaceCountDisplay();
            updateNamespaceHeaderButton();
            updateWorkloadLabel();
            applyNamespaceFilter();
        }
        
        function updateWorkloadLabel() {
            const workloadLabel = document.getElementById('workload-label');
            if (!workloadLabel) return;
            
            const allNamespaceCheckboxes = document.querySelectorAll('.namespace-checkbox');
            const selectedNamespaces = getSelectedNamespaces();
            const count = document.querySelectorAll('.workload-checkbox').length;
            
            // Update label if not all namespaces are selected
            if (selectedNamespaces.length < allNamespaceCheckboxes.length && allNamespaceCheckboxes.length > 0) {
                workloadLabel.textContent = `Workloads (${count}) (in selected namespaces)`;
            } else {
                workloadLabel.textContent = `Workloads (${count})`;
            }
        }
        
        function updateWorkloadHeaderCount() {
            // This is handled by updateWorkloadLabel which already includes the count
            updateWorkloadLabel();
        }
        
        function selectAllWorkloads(event) {
            event.stopPropagation(); // Prevent toggling the filter group
            const allWorkloadCheckboxes = document.querySelectorAll('.workload-checkbox');
            allWorkloadCheckboxes.forEach(checkbox => {
                checkbox.checked = true;
            });
            updateWorkloadCounts();
            updateWorkloadCountDisplay();
            updateWorkloadHeaderButton();
            updateUrlParams();
            applyWorkloadFilter();
        }
        
        function updateWorkloadHeaderButton() {
            const showAllBtn = document.getElementById('workload-show-all-btn');
            if (!showAllBtn) return;
            
            const allWorkloadCheckboxes = document.querySelectorAll('.workload-checkbox');
            const selectedWorkloads = getSelectedWorkloads();
            
            // Show button only if not all are selected
            if (selectedWorkloads.length < allWorkloadCheckboxes.length && allWorkloadCheckboxes.length > 0) {
                showAllBtn.style.display = 'inline-block';
            } else {
                showAllBtn.style.display = 'none';
            }
        }
        
        function selectAllLanguages(event) {
            event.stopPropagation(); // Prevent toggling the filter group
            const allLanguageCheckboxes = document.querySelectorAll('.language-checkbox');
            allLanguageCheckboxes.forEach(checkbox => {
                checkbox.checked = true;
            });
            updateLanguageCounts();
            updateLanguageCountDisplay();
            updateLanguageHeaderButton();
            updateUrlParams();
            applyLanguageFilter();
        }
        
        function updateLanguageHeaderButton() {
            const showAllBtn = document.getElementById('language-show-all-btn');
            if (!showAllBtn) return;
            
            const allLanguageCheckboxes = document.querySelectorAll('.language-checkbox');
            const selectedLanguages = getSelectedLanguages();
            
            // Show button only if not all are selected
            if (selectedLanguages.length < allLanguageCheckboxes.length && allLanguageCheckboxes.length > 0) {
                showAllBtn.style.display = 'inline-block';
            } else {
                showAllBtn.style.display = 'none';
            }
        }
        
        function populateWorkloadCheckboxes(data, selectedNamespaces) {
            const filtersContainer = document.getElementById('workload-filters-container');
            filtersContainer.innerHTML = '';
            
            // Get currently checked workloads
            const checkedWorkloads = new Set();
            const existingCheckboxes = document.querySelectorAll('.workload-checkbox');
            existingCheckboxes.forEach(cb => {
                if (cb.checked) {
                    const namespace = cb.dataset.namespace;
                    const name = cb.dataset.workloadName;
                    if (namespace && name) {
                        checkedWorkloads.add(`${namespace}:${name}`);
                    }
                }
            });
            
            if (!selectedNamespaces || selectedNamespaces.length === 0) {
                return;
            }
            
            // Group workloads by namespace
            const namespaceWorkloads = new Map(); // namespace -> Map<name, count>
            
            if (Array.isArray(data)) {
                data.forEach(item => {
                    if (item && item.id && selectedNamespaces.includes(item.id.namespace) && item.id.name) {
                        const ns = item.id.namespace;
                        const name = item.id.name;
                        if (!namespaceWorkloads.has(ns)) {
                            namespaceWorkloads.set(ns, new Map());
                        }
                        const workloadMap = namespaceWorkloads.get(ns);
                        workloadMap.set(name, (workloadMap.get(name) || 0) + 1);
                    }
                });
            }
            
            // Sort namespaces and create checkboxes
            const sortedNamespaces = Array.from(namespaceWorkloads.entries()).sort((a, b) => 
                a[0].localeCompare(b[0])
            );
            
            sortedNamespaces.forEach(([namespace, workloadMap]) => {
                // Create namespace group header
                const namespaceGroup = document.createElement('div');
                namespaceGroup.className = 'workload-namespace-group';
                namespaceGroup.dataset.namespace = namespace;
                
                const namespaceHeader = document.createElement('div');
                namespaceHeader.className = 'workload-namespace-header';
                namespaceHeader.style.display = 'flex';
                namespaceHeader.style.alignItems = 'center';
                namespaceHeader.style.gap = '4px';
                namespaceHeader.style.fontSize = '11px';
                namespaceHeader.style.fontWeight = '600';
                namespaceHeader.style.color = '#6b7280';
                namespaceHeader.style.marginTop = '4px';
                namespaceHeader.style.marginBottom = '2px';
                namespaceHeader.textContent = namespace;
                namespaceGroup.appendChild(namespaceHeader);
                
                // Sort workloads within namespace
                const sortedWorkloads = Array.from(workloadMap.entries()).sort((a, b) => 
                    a[0].localeCompare(b[0])
                );
                
                sortedWorkloads.forEach(([name, count]) => {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'workload-checkbox-wrapper';
                    wrapper.style.marginLeft = '14px';
                    wrapper.dataset.workloadName = name;
                    wrapper.dataset.namespace = namespace;
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `filter-workload-${namespace}-${name}`;
                    checkbox.className = 'workload-checkbox';
                    checkbox.dataset.namespace = namespace;
                    checkbox.dataset.workloadName = name;
                    // Check if this workload was previously checked, or check all by default
                    checkbox.checked = checkedWorkloads.has(`${namespace}:${name}`) || checkedWorkloads.size === 0;
                    checkbox.onchange = () => {
                        updateWorkloadCounts();
                        updateWorkloadCountDisplay();
                        updateWorkloadHeaderButton();
                        applyWorkloadFilter();
                    };
                    
                    // Add "only" button
                    const onlyBtn = document.createElement('button');
                    onlyBtn.className = 'workload-only-btn';
                    onlyBtn.textContent = 'only';
                    onlyBtn.title = 'filter to show only this workload';
                    onlyBtn.onclick = (e) => {
                        e.stopPropagation();
                        // Uncheck all workload checkboxes (regardless of search filter)
                        const allWorkloadCheckboxes = document.querySelectorAll('.workload-checkbox');
                        allWorkloadCheckboxes.forEach(cb => {
                            cb.checked = false;
                        });
                        // Check only this checkbox
                        checkbox.checked = true;
                        // Clear search box
                        const searchBox = document.getElementById('workload-search-box');
                        if (searchBox) {
                            searchBox.value = '';
                            filterWorkloadsBySearch();
                        }
                        updateWorkloadCounts();
                        updateWorkloadCountDisplay();
                        updateWorkloadHeaderButton();
                        updateUrlParams();
                        applyWorkloadFilter();
                    };
                    wrapper.appendChild(onlyBtn);
                    
                    wrapper.appendChild(checkbox);
                    
                    const label = document.createElement('label');
                    label.htmlFor = `filter-workload-${namespace}-${name}`;
                    label.className = 'workload-checkbox-label';
                    label.textContent = name;
                    
                    wrapper.appendChild(label);
                    
                    namespaceGroup.appendChild(wrapper);
                });
                
                filtersContainer.appendChild(namespaceGroup);
            });
            
            updateWorkloadCounts();
            updateWorkloadCountDisplay();
            updateWorkloadHeaderButton();
            updateWorkloadHeaderCount();
            // Apply search filter after populating
            filterWorkloadsBySearch();
        }
        
        function filterWorkloadsBySearch() {
            const searchBox = document.getElementById('workload-search-box');
            if (!searchBox) return;
            
            const searchText = searchBox.value.toLowerCase().trim();
            const allWrappers = document.querySelectorAll('.workload-checkbox-wrapper');
            const namespaceGroups = new Map(); // namespace -> {visible: count, total: count}
            const messageElement = document.getElementById('workload-search-message');
            
            let visibleCount = 0;
            const totalCount = allWrappers.length;
            
            // Filter workloads and count visible ones per namespace
            allWrappers.forEach(wrapper => {
                const workloadName = wrapper.dataset.workloadName || '';
                const namespace = wrapper.dataset.namespace || '';
                const searchableText = `${namespace}:${workloadName}`.toLowerCase();
                
                if (searchText === '' || searchableText.includes(searchText)) {
                    wrapper.classList.remove('hidden');
                    if (searchText !== '') {
                        visibleCount++;
                    }
                    if (!namespaceGroups.has(namespace)) {
                        namespaceGroups.set(namespace, { visible: 0, total: 0 });
                    }
                    namespaceGroups.get(namespace).visible++;
                } else {
                    wrapper.classList.add('hidden');
                }
                if (!namespaceGroups.has(namespace)) {
                    namespaceGroups.set(namespace, { visible: 0, total: 0 });
                }
                namespaceGroups.get(namespace).total++;
            });
            
            // Hide/show namespace group headers based on visible workloads
            const allNamespaceGroups = document.querySelectorAll('.workload-namespace-group');
            allNamespaceGroups.forEach(group => {
                const namespace = group.dataset.namespace;
                const counts = namespaceGroups.get(namespace);
                if (counts && counts.visible === 0) {
                    group.style.display = 'none';
                } else {
                    group.style.display = 'block';
                }
            });
            
            // Update search message
            if (messageElement) {
                if (searchText !== '') {
                    if (visibleCount === 0) {
                        messageElement.textContent = `No workloads matched "${searchText}". Check for typos or try a different search term. Other workloads may still be selected.`;
                    } else {
                        messageElement.textContent = `Showing ${visibleCount}/${totalCount} workloads that matched the search term. Other workloads may still be selected.`;
                    }
                    messageElement.style.display = 'block';
                } else {
                    messageElement.style.display = 'none';
                }
            }
        }
        
        function getSelectedWorkloads() {
            const selected = [];
            const checkboxes = document.querySelectorAll('.workload-checkbox');
            checkboxes.forEach(checkbox => {
                if (checkbox.checked) {
                    selected.push({
                        namespace: checkbox.dataset.namespace,
                        name: checkbox.dataset.workloadName
                    });
                }
            });
            return selected;
        }
        
        function updateWorkloadCountDisplay() {
            const footer = document.getElementById('workload-filter-footer');
            if (!footer) return;
            
            const allWorkloadCheckboxes = document.querySelectorAll('.workload-checkbox');
            const selectedWorkloads = getSelectedWorkloads();
            const totalWorkloads = allWorkloadCheckboxes.length;
            
            // Format workload names for display (namespace:name)
            const selectedItems = selectedWorkloads.map(w => `${w.namespace}:${w.name}`);
            
            footer.textContent = formatFilterFooter(selectedItems, totalWorkloads, 'workloads');
        }
        
        function updateWorkloadCounts() {
            // Count workloads based on current filters
            const selectedNamespaces = getSelectedNamespaces();
            let dataToCount = allWorkloadData;
            
            // Apply namespace filter
            if (selectedNamespaces.length > 0) {
                dataToCount = dataToCount.filter(item => 
                    item && item.id && selectedNamespaces.includes(item.id.namespace)
                );
            }
            
            // Apply marked for instrumentation filter
            const showMarked = document.getElementById('filter-marked').checked;
            const showNotMarked = document.getElementById('filter-not-marked').checked;
            if (!showMarked || !showNotMarked) {
                dataToCount = dataToCount.filter(item => {
                    if (!item || !item.markedForInstrumentation) {
                        return showNotMarked;
                    }
                    const isMarked = item.markedForInstrumentation.markedForInstrumentation === true;
                    return isMarked ? showMarked : showNotMarked;
                });
            }
            
            // Counts are no longer displayed for workloads (always 1)
        }
        
        function populateLanguageCheckboxes(data) {
            const filtersContainer = document.getElementById('language-filters-container');
            filtersContainer.innerHTML = '';
            
            // Extract all unique languages from workloads
            const languageMap = new Map(); // language -> count
            let notDetectedCount = 0;
            
            if (Array.isArray(data)) {
                data.forEach(item => {
                    if (item && item.runtimeInfo && item.runtimeInfo.detectedLanguages && 
                        Array.isArray(item.runtimeInfo.detectedLanguages) &&
                        item.runtimeInfo.detectedLanguages.length > 0) {
                        item.runtimeInfo.detectedLanguages.forEach(language => {
                            if (language) {
                                languageMap.set(language, (languageMap.get(language) || 0) + 1);
                            }
                        });
                    } else {
                        // Count workloads without detected languages
                        notDetectedCount++;
                    }
                });
            }
            
            // Get currently checked languages
            const checkedLanguages = new Set();
            const existingCheckboxes = document.querySelectorAll('.language-checkbox');
            existingCheckboxes.forEach(cb => {
                if (cb.checked) {
                    checkedLanguages.add(cb.dataset.language);
                }
            });
            
            // Add "language not detected" option if there are workloads without detected languages
            if (notDetectedCount > 0) {
                const LANGUAGE_NOT_DETECTED = '__LANGUAGE_NOT_DETECTED__';
                const wrapper = document.createElement('div');
                wrapper.className = 'language-checkbox-wrapper';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `filter-language-${LANGUAGE_NOT_DETECTED}`;
                checkbox.className = 'language-checkbox';
                checkbox.dataset.language = LANGUAGE_NOT_DETECTED;
                checkbox.checked = checkedLanguages.has(LANGUAGE_NOT_DETECTED) || checkedLanguages.size === 0;
                checkbox.onchange = () => {
                    updateLanguageCounts();
                    updateLanguageCountDisplay();
                    updateLanguageHeaderButton();
                    updateUrlParams();
                    applyLanguageFilter();
                };
                
                // Add "only" button
                const onlyBtn = document.createElement('button');
                onlyBtn.className = 'language-only-btn';
                onlyBtn.textContent = 'only';
                onlyBtn.title = 'filter to show only workloads without detected languages';
                onlyBtn.onclick = (e) => {
                    e.stopPropagation();
                    const allLanguageCheckboxes = document.querySelectorAll('.language-checkbox');
                    allLanguageCheckboxes.forEach(cb => {
                        cb.checked = false;
                    });
                    checkbox.checked = true;
                    updateLanguageCounts();
                    updateLanguageCountDisplay();
                    updateLanguageHeaderButton();
                    updateUrlParams();
                    applyLanguageFilter();
                };
                wrapper.appendChild(onlyBtn);
                
                wrapper.appendChild(checkbox);
                
                const label = document.createElement('label');
                label.htmlFor = `filter-language-${LANGUAGE_NOT_DETECTED}`;
                label.className = 'language-checkbox-label';
                
                const countSpan = document.createElement('span');
                countSpan.id = `count-language-${LANGUAGE_NOT_DETECTED}`;
                countSpan.className = 'language-count';
                countSpan.textContent = `(${notDetectedCount}) `;
                label.appendChild(countSpan);
                
                label.appendChild(document.createTextNode('language not detected'));
                
                wrapper.appendChild(label);
                
                filtersContainer.appendChild(wrapper);
            }
            
            // Sort languages alphabetically
            const sortedLanguages = Array.from(languageMap.entries()).sort((a, b) => 
                a[0].localeCompare(b[0])
            );
            
            // Create checkboxes for each language
            sortedLanguages.forEach(([language, count]) => {
                const wrapper = document.createElement('div');
                wrapper.className = 'language-checkbox-wrapper';
                if (count === 0) {
                    wrapper.classList.add('filter-zero-count');
                }
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `filter-language-${language}`;
                checkbox.className = 'language-checkbox';
                checkbox.dataset.language = language;
                // Check if this language was previously checked, or check all by default
                checkbox.checked = checkedLanguages.has(language) || checkedLanguages.size === 0;
                    checkbox.onchange = () => {
                        updateLanguageCounts();
                        updateLanguageCountDisplay();
                        updateLanguageHeaderButton();
                        updateUrlParams();
                        applyLanguageFilter();
                    };
                
                // Add "only" button
                const onlyBtn = document.createElement('button');
                onlyBtn.className = 'language-only-btn';
                onlyBtn.textContent = 'only';
                onlyBtn.title = 'filter to show only this language';
                onlyBtn.onclick = (e) => {
                    e.stopPropagation();
                    // Uncheck all language checkboxes
                    const allLanguageCheckboxes = document.querySelectorAll('.language-checkbox');
                    allLanguageCheckboxes.forEach(cb => {
                        cb.checked = false;
                    });
                    // Check only this checkbox
                    checkbox.checked = true;
                        updateLanguageCounts();
                        updateLanguageCountDisplay();
                        updateLanguageHeaderButton();
                        updateUrlParams();
                        applyLanguageFilter();
                };
                wrapper.appendChild(onlyBtn);
                
                wrapper.appendChild(checkbox);
                
                const label = document.createElement('label');
                label.htmlFor = `filter-language-${language}`;
                label.className = 'language-checkbox-label';
                
                const countSpan = document.createElement('span');
                countSpan.id = `count-language-${language}`;
                countSpan.className = 'language-count';
                countSpan.textContent = `(${count}) `;
                label.appendChild(countSpan);
                
                label.appendChild(document.createTextNode(language));
                
                wrapper.appendChild(label);
                
                filtersContainer.appendChild(wrapper);
            });
            
            updateLanguageCounts();
            updateLanguageCountDisplay();
            updateLanguageHeaderButton();
            updateLanguageHeaderCount();
        }
        
        function updateLanguageHeaderCount() {
            const label = document.getElementById('language-label');
            if (!label) return;
            const count = document.querySelectorAll('.language-checkbox').length;
            label.textContent = `Programming Language (${count})`;
        }
        
        function getSelectedLanguages() {
            const selected = [];
            const checkboxes = document.querySelectorAll('.language-checkbox');
            checkboxes.forEach(checkbox => {
                if (checkbox.checked) {
                    selected.push(checkbox.dataset.language);
                }
            });
            return selected;
        }
        
        function updateLanguageCountDisplay() {
            const footer = document.getElementById('language-filter-footer');
            if (!footer) return;
            
            const allLanguageCheckboxes = document.querySelectorAll('.language-checkbox');
            const selectedLanguages = getSelectedLanguages();
            const totalLanguages = allLanguageCheckboxes.length;
            
            // Format languages for display (convert special value to readable text)
            const LANGUAGE_NOT_DETECTED = '__LANGUAGE_NOT_DETECTED__';
            const displayLanguages = selectedLanguages.map(lang => 
                lang === LANGUAGE_NOT_DETECTED ? 'language not detected' : lang
            );
            
            footer.textContent = formatFilterFooter(displayLanguages, totalLanguages, 'languages');
        }
        
        function updateLanguageCounts() {
            // Count workloads per language based on current filters
            const selectedLanguages = getSelectedLanguages();
            let dataToCount = allWorkloadData;
            
            // Apply other filters for counting (namespace, workload, marked, conditions)
            const selectedNamespaces = getSelectedNamespaces();
            if (selectedNamespaces.length > 0) {
                dataToCount = dataToCount.filter(item => 
                    item && item.id && selectedNamespaces.includes(item.id.namespace)
                );
            }
            
            const selectedWorkloads = getSelectedWorkloads();
            if (selectedWorkloads.length > 0) {
                const workloadSet = new Set(selectedWorkloads.map(w => `${w.namespace}:${w.name}`));
                dataToCount = dataToCount.filter(item => 
                    item && item.id && workloadSet.has(`${item.id.namespace}:${item.id.name}`)
                );
            }
            
            const showMarked = document.getElementById('filter-marked').checked;
            const showNotMarked = document.getElementById('filter-not-marked').checked;
            if (!showMarked || !showNotMarked) {
                dataToCount = dataToCount.filter(item => {
                    if (!item || !item.markedForInstrumentation) {
                        return showNotMarked;
                    }
                    const isMarked = item.markedForInstrumentation.markedForInstrumentation === true;
                    return isMarked ? showMarked : showNotMarked;
                });
            }
            
            // Apply condition filters for counting
            const conditionCheckboxes = document.querySelectorAll('.condition-checkbox');
            if (conditionCheckboxes.length > 0) {
                const conditionFilters = new Map();
                conditionCheckboxes.forEach(checkbox => {
                    const conditionName = checkbox.dataset.conditionName;
                    const reasonEnum = checkbox.dataset.reasonEnum;
                    if (conditionName && reasonEnum) {
                        if (!conditionFilters.has(conditionName)) {
                            conditionFilters.set(conditionName, { checked: [], all: [] });
                        }
                        conditionFilters.get(conditionName).all.push(reasonEnum);
                        if (checkbox.checked) {
                            conditionFilters.get(conditionName).checked.push(reasonEnum);
                        }
                    }
                });
                conditionFilters.forEach((filterData, conditionName) => {
                    if (filterData.checked.length < filterData.all.length) {
                        // Get the camelCase key for this condition name
                        const conditionKey = Array.from(document.querySelectorAll('.condition-checkbox[data-condition-name="' + conditionName + '"]'))
                            .map(cb => cb.dataset.conditionKey)
                            .find(key => key) || conditionName; // Fallback to conditionName if not found
                        
                        dataToCount = dataToCount.filter(item => {
                            if (!item || !item.conditions || !item.conditions[conditionKey]) {
                                return false;
                            }
                            const condition = item.conditions[conditionKey];
                            const reasonEnum = condition && condition.reasonEnum;
                            return reasonEnum && filterData.checked.includes(reasonEnum);
                        });
                    }
                });
            }
            
            // Count per language
            const languageCounts = new Map();
            const LANGUAGE_NOT_DETECTED = '__LANGUAGE_NOT_DETECTED__';
            let notDetectedCount = 0;
            
            dataToCount.forEach(item => {
                if (item && item.runtimeInfo && item.runtimeInfo.detectedLanguages && 
                    Array.isArray(item.runtimeInfo.detectedLanguages) &&
                    item.runtimeInfo.detectedLanguages.length > 0) {
                    item.runtimeInfo.detectedLanguages.forEach(language => {
                        if (language) {
                            languageCounts.set(language, (languageCounts.get(language) || 0) + 1);
                        }
                    });
                } else {
                    // Count workloads without detected languages
                    notDetectedCount++;
                }
            });
            
            // Update counts and zero-count styling
            const allLanguageCheckboxes = document.querySelectorAll('.language-checkbox');
            allLanguageCheckboxes.forEach(checkbox => {
                const language = checkbox.dataset.language;
                let count = 0;
                if (language === LANGUAGE_NOT_DETECTED) {
                    count = notDetectedCount;
                } else {
                    count = languageCounts.get(language) || 0;
                }
                const countSpan = document.getElementById(`count-language-${language}`);
                if (countSpan) {
                    countSpan.textContent = `(${count}) `;
                }
                // Update zero-count class on wrapper
                const wrapper = checkbox.closest('.language-checkbox-wrapper');
                if (wrapper) {
                    if (count === 0) {
                        wrapper.classList.add('filter-zero-count');
                    } else {
                        wrapper.classList.remove('filter-zero-count');
                    }
                }
            });
        }
        
        function applyLanguageFilter() {
            const selectedNamespaces = getSelectedNamespaces();
            const selectedWorkloads = getSelectedWorkloads();
            populateHealthStatusFilters(allWorkloadData);
            updateHealthStatusCounts();
            displayFilteredData(allWorkloadData, selectedNamespaces, selectedWorkloads);
        }
        
        function applyWorkloadFilter() {
            const selectedNamespaces = getSelectedNamespaces();
            updateInstrumentationCounts(allWorkloadData);
            populateConditionFilters(allWorkloadData);
            populateHealthStatusFilters(allWorkloadData);
            updateConditionCounts(allWorkloadData);
            updateNamespaceCounts();
            updateNamespaceCountDisplay();
            updateWorkloadCounts();
            updateWorkloadCountDisplay();
            updateWorkloadHeaderButton();
            updateUrlParams();
            applyNameFilter();
        }
        
        function applyNamespaceFilter() {
            const selectedNamespaces = getSelectedNamespaces();
            populateWorkloadCheckboxes(allWorkloadData, selectedNamespaces);
            
            // Update counts based on namespace filter
            let dataToCount = allWorkloadData;
            if (selectedNamespaces.length > 0) {
                dataToCount = allWorkloadData.filter(item => 
                    item && item.id && selectedNamespaces.includes(item.id.namespace)
                );
            }
            updateInstrumentationCounts(dataToCount);
            
            // Regenerate condition filters based on new namespace selection
            populateConditionFilters(allWorkloadData);
            // Update condition counts after regenerating filters
            updateConditionCounts(allWorkloadData);
            updateAllConditionFilterCounts();
            updateConditionHeadersCount();
            
            // Regenerate health status filters based on new namespace selection
            populateHealthStatusFilters(allWorkloadData);
            updateHealthStatusCounts();
            
            updateNamespaceCounts();
            updateNamespaceCountDisplay();
            updateLanguageCounts();
            updateLanguageCountDisplay();
            
            updateUrlParams();
            applyNameFilter();
        }
        
        function applyNameFilter() {
            const selectedNamespaces = getSelectedNamespaces();
            const selectedWorkloads = getSelectedWorkloads();
            
            // Update counts based on namespace and workload filters
            let dataToCount = allWorkloadData;
            if (selectedNamespaces.length > 0) {
                dataToCount = dataToCount.filter(item => 
                    item && item.id && selectedNamespaces.includes(item.id.namespace)
                );
            }
            if (selectedWorkloads.length > 0) {
                const workloadSet = new Set(selectedWorkloads.map(w => `${w.namespace}:${w.name}`));
                dataToCount = dataToCount.filter(item => 
                    item && item.id && workloadSet.has(`${item.id.namespace}:${item.id.name}`)
                );
            }
            updateInstrumentationCounts(dataToCount);
            populateConditionFilters(allWorkloadData);
            updateConditionCounts(allWorkloadData);
            updateHealthStatusCounts();
            updateNamespaceCounts();
            updateNamespaceCountDisplay();
            updateWorkloadCounts();
            updateWorkloadCountDisplay();
            updateLanguageCounts();
            updateLanguageCountDisplay();
            
            updateUrlParams();
            displayFilteredData(allWorkloadData, selectedNamespaces, selectedWorkloads);
        }
        
        function applyInstrumentationFilter() {
            const selectedNamespaces = getSelectedNamespaces();
            const selectedWorkloads = getSelectedWorkloads();
            populateHealthStatusFilters(allWorkloadData);
            updateHealthStatusCounts();
            updateUrlParams();
            displayFilteredData(allWorkloadData, selectedNamespaces, selectedWorkloads);
        }
        
        function clearAllFilters() {
            // Check all namespace checkboxes
            const namespaceCheckboxes = document.querySelectorAll('.namespace-checkbox');
            namespaceCheckboxes.forEach(checkbox => {
                checkbox.checked = true;
            });
            
            // Get all selected namespaces after clearing
            const allNamespaces = getSelectedNamespaces();
            
            // Repopulate workload checkboxes with all namespaces
            populateWorkloadCheckboxes(allWorkloadData, allNamespaces);
            
            // Check all workload checkboxes (after repopulation)
            const workloadCheckboxes = document.querySelectorAll('.workload-checkbox');
            workloadCheckboxes.forEach(checkbox => {
                checkbox.checked = true;
            });
            
            // Check both marked for instrumentation checkboxes
            const markedCheckbox = document.getElementById('filter-marked');
            const notMarkedCheckbox = document.getElementById('filter-not-marked');
            if (markedCheckbox) {
                markedCheckbox.checked = true;
            }
            if (notMarkedCheckbox) {
                notMarkedCheckbox.checked = true;
            }
            
            // Check all language checkboxes
            const languageCheckboxes = document.querySelectorAll('.language-checkbox');
            languageCheckboxes.forEach(checkbox => {
                checkbox.checked = true;
            });
            
            // Check all health status checkboxes
            const healthStatusCheckboxes = document.querySelectorAll('.health-status-checkbox');
            healthStatusCheckboxes.forEach(checkbox => {
                checkbox.checked = true;
            });
            
            // Check all condition checkboxes
            const conditionCheckboxes = document.querySelectorAll('.condition-checkbox');
            conditionCheckboxes.forEach(checkbox => {
                checkbox.checked = true;
            });
            
            // Regenerate filter options to reflect cleared filters
            populateConditionFilters(allWorkloadData);
            populateHealthStatusFilters(allWorkloadData);
            
            // Check all condition checkboxes again after repopulation
            const conditionCheckboxesAfter = document.querySelectorAll('.condition-checkbox');
            conditionCheckboxesAfter.forEach(checkbox => {
                checkbox.checked = true;
            });
            
            // Check all health status checkboxes again after repopulation
            const healthStatusCheckboxesAfter = document.querySelectorAll('.health-status-checkbox');
            healthStatusCheckboxesAfter.forEach(checkbox => {
                checkbox.checked = true;
            });
            
            // Update counts
            updateInstrumentationCounts(allWorkloadData);
            updateConditionCounts(allWorkloadData);
            updateHealthStatusCounts();
            updateNamespaceCounts();
            updateNamespaceCountDisplay();
            updateWorkloadCounts();
            updateWorkloadCountDisplay();
            updateWorkloadHeaderButton();
            updateLanguageCounts();
            updateLanguageCountDisplay();
            updateLanguageHeaderButton();
            updateNamespaceHeaderButton();
            updateWorkloadLabel();
            updateHealthStatusCountDisplay();
            updateHealthStatusHeaderButton();
            updateAllConditionFilterCounts();
            updateAllConditionFilterAllButtons();
            // Update header counts
            updateNamespaceHeaderCount();
            updateLanguageHeaderCount();
            updateHealthStatusHeaderCount();
            updateConditionHeadersCount();
            
            // Update URL to clear all parameters
            window.history.replaceState({}, '', window.location.pathname);
            
            // Refresh display
            const allWorkloads = getSelectedWorkloads();
            displayFilteredData(allWorkloadData, allNamespaces, allWorkloads);
        }
        
        function updateInstrumentationCounts(data) {
            let markedCount = 0;
            let notMarkedCount = 0;
            
            if (Array.isArray(data)) {
                data.forEach(item => {
                    if (item && item.markedForInstrumentation && 
                        item.markedForInstrumentation.markedForInstrumentation === true) {
                        markedCount++;
                    } else {
                        notMarkedCount++;
                    }
                });
            }
            
            document.getElementById('count-marked').textContent = `(${markedCount})`;
            document.getElementById('count-not-marked').textContent = `(${notMarkedCount})`;
        }
        
        function getStatusOrder(status) {
            // Order matches enum.graphqls DesiredStateProgress enum
            // Handle case-insensitive matching
            const statusLower = (status || '').toLowerCase();
            const statusOrder = {
                'error': 0,
                'failure': 1,
                'notice': 2,
                'pending': 3,
                'waiting': 4,
                'unsupported': 5,
                'disabled': 6,
                'success': 7,
                'irrelevant': 8,
                'unknown': 9
            };
            return statusOrder[statusLower] !== undefined ? statusOrder[statusLower] : 999;
        }
        
        function populateHealthStatusFilters(data) {
            const filtersContainer = document.getElementById('health-status-filters-container');
            filtersContainer.innerHTML = '';
            
            // Get current filters to determine which workloads to use
            const selectedNamespaces = getSelectedNamespaces();
            const selectedWorkloads = getSelectedWorkloads();
            const selectedLanguages = getSelectedLanguages();
            
            // Filter data based on current filters (same logic as updateHealthStatusCounts)
            let dataToUse = allWorkloadData;
            
            // Get all unique namespaces from the data
            const allNamespacesInData = new Set();
            if (Array.isArray(allWorkloadData)) {
                allWorkloadData.forEach(item => {
                    if (item && item.id && item.id.namespace) {
                        allNamespacesInData.add(item.id.namespace);
                    }
                });
            }
            const allNamespacesArray = Array.from(allNamespacesInData);
            
            // Apply namespace filter - only if not all namespaces are selected
            if (selectedNamespaces.length > 0 && selectedNamespaces.length < allNamespacesArray.length) {
                dataToUse = dataToUse.filter(item => 
                    item && item.id && selectedNamespaces.includes(item.id.namespace)
                );
            }
            
            // Get all unique workloads from the filtered data
            const allWorkloadsInData = new Set();
            dataToUse.forEach(item => {
                if (item && item.id && item.id.namespace && item.id.name) {
                    allWorkloadsInData.add(`${item.id.namespace}:${item.id.name}`);
                }
            });
            
            // Apply workload filter - only if not all workloads are selected
            if (selectedWorkloads.length > 0 && selectedWorkloads.length < allWorkloadsInData.size) {
                const workloadSet = new Set(selectedWorkloads.map(w => `${w.namespace}:${w.name}`));
                dataToUse = dataToUse.filter(item => 
                    item && item.id && workloadSet.has(`${item.id.namespace}:${item.id.name}`)
                );
            }
            
            // Apply marked for instrumentation filter
            const showMarked = document.getElementById('filter-marked');
            const showNotMarked = document.getElementById('filter-not-marked');
            if (showMarked && showNotMarked) {
                const markedChecked = showMarked.checked;
                const notMarkedChecked = showNotMarked.checked;
                if (!markedChecked || !notMarkedChecked) {
                    dataToUse = dataToUse.filter(item => {
                        if (!item || !item.markedForInstrumentation) {
                            return notMarkedChecked;
                        }
                        const isMarked = item.markedForInstrumentation.markedForInstrumentation === true;
                        return isMarked ? markedChecked : notMarkedChecked;
                    });
                }
            }
            
            // Apply language filter - only if not all languages are selected
            const allLanguageCheckboxes = document.querySelectorAll('.language-checkbox');
            const LANGUAGE_NOT_DETECTED = '__LANGUAGE_NOT_DETECTED__';
            if (selectedLanguages && selectedLanguages.length > 0 && selectedLanguages.length < allLanguageCheckboxes.length) {
                const includeNotDetected = selectedLanguages.includes(LANGUAGE_NOT_DETECTED);
                dataToUse = dataToUse.filter(item => {
                    const hasNoDetectedLanguages = !item || !item.runtimeInfo || !item.runtimeInfo.detectedLanguages || 
                        !Array.isArray(item.runtimeInfo.detectedLanguages) || 
                        item.runtimeInfo.detectedLanguages.length === 0;
                    
                    if (hasNoDetectedLanguages) {
                        return includeNotDetected;
                    }
                    
                    return item.runtimeInfo.detectedLanguages.some(lang => selectedLanguages.includes(lang));
                });
            }
            
            // Extract all unique health status combinations from filtered data
            // Structure: status -> Map<"name|reasonEnum", {name, reasonEnum, count}>
            const statusMap = new Map();
            
            if (Array.isArray(dataToUse)) {
                dataToUse.forEach(item => {
                    if (item && item.workloadOdigosHealthStatus) {
                        const name = item.workloadOdigosHealthStatus.name || '';
                        const reasonEnum = item.workloadOdigosHealthStatus.reasonEnum || '';
                        const status = item.workloadOdigosHealthStatus.status || 'Unknown';
                        
                        if (name && reasonEnum && status) {
                            if (!statusMap.has(status)) {
                                statusMap.set(status, new Map());
                            }
                            
                            const nameReasonMap = statusMap.get(status);
                            const key = `${name}|${reasonEnum}`;
                            
                            if (!nameReasonMap.has(key)) {
                                nameReasonMap.set(key, {
                                    name: name,
                                    reasonEnum: reasonEnum,
                                    count: 0
                                });
                            }
                            nameReasonMap.get(key).count++;
                        }
                    }
                });
            }
            
            // Status order from enum.graphqls DesiredStateProgress
            const statusOrder = ['Error', 'Failure', 'Notice', 'Pending', 'Waiting', 'Unsupported', 'Disabled', 'Success', 'Irrelevant', 'Unknown'];
            
            // Sort statuses by enum order
            const sortedStatuses = Array.from(statusMap.keys()).sort((a, b) => {
                const orderA = statusOrder.indexOf(a);
                const orderB = statusOrder.indexOf(b);
                return (orderA === -1 ? 999 : orderA) - (orderB === -1 ? 999 : orderB);
            });
            
            if (sortedStatuses.length === 0) {
                return;
            }
            
            // Get currently checked health status filters from URL or existing checkboxes
            const checkedHealthStatuses = new Set();
            const existingCheckboxes = document.querySelectorAll('.health-status-checkbox');
            existingCheckboxes.forEach(cb => {
                if (cb.checked) {
                    checkedHealthStatuses.add(cb.dataset.healthStatusKey);
                }
            });
            
            // Create status groups (similar to namespace groups in workloads)
            sortedStatuses.forEach(status => {
                const statusGroup = document.createElement('div');
                statusGroup.className = 'health-status-status-group';
                statusGroup.dataset.status = status;
                
                // Create status header (like namespace header in workloads - not collapsible)
                const statusHeader = document.createElement('div');
                statusHeader.className = 'health-status-status-header';
                statusHeader.style.display = 'flex';
                statusHeader.style.alignItems = 'center';
                statusHeader.style.gap = '4px';
                statusHeader.style.fontSize = '11px';
                statusHeader.style.fontWeight = '600';
                statusHeader.style.color = '#6b7280';
                statusHeader.style.marginTop = '4px';
                statusHeader.style.marginBottom = '2px';
                const statusEmoji = getStatusEmoji(status);
                statusHeader.innerHTML = '';
                if (statusEmoji) {
                    const tooltipWrapper = document.createElement('span');
                    tooltipWrapper.className = 'emoji-tooltip-wrapper';
                    tooltipWrapper.style.marginRight = '0';
                    
                    const emojiSpan = document.createElement('span');
                    emojiSpan.textContent = statusEmoji + ' ';
                    emojiSpan.style.cursor = 'help';
                    tooltipWrapper.appendChild(emojiSpan);
                    
                    const tooltipDiv = document.createElement('div');
                    tooltipDiv.className = 'emoji-tooltip';
                    tooltipDiv.textContent = getStatusTooltip(status);
                    tooltipWrapper.appendChild(tooltipDiv);
                    
                    statusHeader.appendChild(tooltipWrapper);
                }
                statusHeader.appendChild(document.createTextNode(status));
                statusGroup.appendChild(statusHeader);
                
                // Create content for name+reasonEnum combinations (always visible, not collapsible)
                const content = document.createElement('div');
                content.className = 'health-status-status-content';
                
                const nameReasonMap = statusMap.get(status);
                const sortedNameReasons = Array.from(nameReasonMap.entries()).sort((a, b) => {
                    // Sort by name first, then reasonEnum
                    const nameCompare = a[1].name.localeCompare(b[1].name);
                    if (nameCompare !== 0) {
                        return nameCompare;
                    }
                    return a[1].reasonEnum.localeCompare(b[1].reasonEnum);
                });
                
                sortedNameReasons.forEach(([key, data]) => {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'health-status-checkbox-wrapper';
                    wrapper.style.marginLeft = '14px';
                    if (data.count === 0) {
                        wrapper.classList.add('filter-zero-count');
                    }
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `filter-health-status-${status}-${key}`;
                    checkbox.className = 'health-status-checkbox';
                    checkbox.dataset.healthStatusKey = `${status}|${key}`;
                    checkbox.dataset.status = status;
                    checkbox.dataset.name = data.name;
                    checkbox.dataset.reasonEnum = data.reasonEnum;
                    checkbox.checked = checkedHealthStatuses.has(`${status}|${key}`) || checkedHealthStatuses.size === 0;
                    checkbox.onchange = () => {
                        updateHealthStatusCounts();
                        updateHealthStatusCountDisplay();
                        updateHealthStatusHeaderButton();
                        updateUrlParams();
                        applyHealthStatusFilters();
                    };
                    
                    // Add "only" button
                    const onlyBtn = document.createElement('button');
                    onlyBtn.className = 'health-status-only-btn';
                    onlyBtn.textContent = 'only';
                    onlyBtn.title = 'filter to show only this health status';
                    onlyBtn.onclick = (e) => {
                        e.stopPropagation();
                        // Uncheck all health status checkboxes
                        const allHealthStatusCheckboxes = document.querySelectorAll('.health-status-checkbox');
                        allHealthStatusCheckboxes.forEach(cb => {
                            cb.checked = false;
                        });
                        // Check only this checkbox
                        checkbox.checked = true;
                        updateHealthStatusCounts();
                        updateHealthStatusCountDisplay();
                        updateHealthStatusHeaderButton();
                        updateUrlParams();
                        applyHealthStatusFilters();
                    };
                    wrapper.appendChild(onlyBtn);
                    
                    wrapper.appendChild(checkbox);
                    
                    const label = document.createElement('label');
                    label.htmlFor = `filter-health-status-${status}-${key}`;
                    label.className = 'health-status-checkbox-label';
                    
                    const countSpan = document.createElement('span');
                    countSpan.id = `count-health-status-${status}-${key}`;
                    countSpan.className = 'health-status-count';
                    countSpan.textContent = `(${data.count}) `;
                    label.appendChild(countSpan);
                    
                    label.appendChild(document.createTextNode(`${parseCamelCase(data.name)}: ${parseCamelCase(data.reasonEnum)}`));
                    
                    wrapper.appendChild(label);
                    
                    content.appendChild(wrapper);
                });
                
                statusGroup.appendChild(content);
                filtersContainer.appendChild(statusGroup);
            });
            
            // Update counts and buttons
            updateHealthStatusCounts();
            updateHealthStatusCountDisplay();
            updateHealthStatusHeaderButton();
            updateHealthStatusHeaderCount();
        }
        
        function updateHealthStatusHeaderCount() {
            const label = document.getElementById('health-status-label');
            if (!label) return;
            const count = document.querySelectorAll('.health-status-checkbox').length;
            label.textContent = `Odigos Health (${count})`;
        }
        
        function toggleHealthStatusFilters() {
            const container = document.getElementById('health-status-filters-container');
            const toggle = document.getElementById('health-status-filter-toggle');
            container.classList.toggle('expanded');
            toggle.classList.toggle('expanded');
        }
        
        function selectAllHealthStatuses(event) {
            event.stopPropagation();
            const allHealthStatusCheckboxes = document.querySelectorAll('.health-status-checkbox');
            allHealthStatusCheckboxes.forEach(checkbox => {
                checkbox.checked = true;
            });
            updateHealthStatusCounts();
            updateHealthStatusCountDisplay();
            updateHealthStatusHeaderButton();
            updateUrlParams();
            applyHealthStatusFilters();
        }
        
        function updateHealthStatusHeaderButton() {
            const showAllBtn = document.getElementById('health-status-show-all-btn');
            if (!showAllBtn) return;
            
            const allHealthStatusCheckboxes = document.querySelectorAll('.health-status-checkbox');
            const selectedHealthStatuses = getSelectedHealthStatuses();
            
            // Show button only if not all are selected
            if (selectedHealthStatuses.length < allHealthStatusCheckboxes.length && allHealthStatusCheckboxes.length > 0) {
                showAllBtn.style.display = 'inline-block';
            } else {
                showAllBtn.style.display = 'none';
            }
        }
        
        function updateHealthStatusCountDisplay() {
            const footer = document.getElementById('health-status-filter-footer');
            if (!footer) return;
            
            const allHealthStatusCheckboxes = document.querySelectorAll('.health-status-checkbox');
            const selectedHealthStatuses = getSelectedHealthStatuses();
            const totalHealthStatuses = allHealthStatusCheckboxes.length;
            
            // Format health statuses for display
            const displayItems = selectedHealthStatuses.map(hs => {
                const statusEmoji = getStatusEmoji(hs.status);
                return `${statusEmoji} ${hs.status}: ${parseCamelCase(hs.name)}: ${parseCamelCase(hs.reasonEnum)}`;
            });
            
            footer.textContent = formatFilterFooter(displayItems, totalHealthStatuses, 'health statuses');
        }
        
        function getSelectedHealthStatuses() {
            const selected = [];
            const checkboxes = document.querySelectorAll('.health-status-checkbox');
            checkboxes.forEach(checkbox => {
                if (checkbox.checked) {
                    selected.push({
                        status: checkbox.dataset.status,
                        name: checkbox.dataset.name,
                        reasonEnum: checkbox.dataset.reasonEnum
                    });
                }
            });
            return selected;
        }
        
        function updateHealthStatusCounts() {
            // Get current filters
            const selectedNamespaces = getSelectedNamespaces();
            const selectedWorkloads = getSelectedWorkloads();
            const selectedLanguages = getSelectedLanguages();
            
            let dataToCount = allWorkloadData;
            
            // Get all unique namespaces from the data
            const allNamespacesInData = new Set();
            if (Array.isArray(allWorkloadData)) {
                allWorkloadData.forEach(item => {
                    if (item && item.id && item.id.namespace) {
                        allNamespacesInData.add(item.id.namespace);
                    }
                });
            }
            const allNamespacesArray = Array.from(allNamespacesInData);
            
            // Apply namespace filter - only if not all namespaces are selected
            if (selectedNamespaces.length > 0 && selectedNamespaces.length < allNamespacesArray.length) {
                dataToCount = dataToCount.filter(item => 
                    item && item.id && selectedNamespaces.includes(item.id.namespace)
                );
            }
            
            // Get all unique workloads from the filtered data
            const allWorkloadsInData = new Set();
            dataToCount.forEach(item => {
                if (item && item.id && item.id.namespace && item.id.name) {
                    allWorkloadsInData.add(`${item.id.namespace}:${item.id.name}`);
                }
            });
            
            // Apply workload filter - only if not all workloads are selected
            if (selectedWorkloads.length > 0 && selectedWorkloads.length < allWorkloadsInData.size) {
                const workloadSet = new Set(selectedWorkloads.map(w => `${w.namespace}:${w.name}`));
                dataToCount = dataToCount.filter(item => 
                    item && item.id && workloadSet.has(`${item.id.namespace}:${item.id.name}`)
                );
            }
            
            // Apply marked for instrumentation filter
            const showMarked = document.getElementById('filter-marked').checked;
            const showNotMarked = document.getElementById('filter-not-marked').checked;
            if (!showMarked || !showNotMarked) {
                dataToCount = dataToCount.filter(item => {
                    if (!item || !item.markedForInstrumentation) {
                        return showNotMarked;
                    }
                    const isMarked = item.markedForInstrumentation.markedForInstrumentation === true;
                    return isMarked ? showMarked : showNotMarked;
                });
            }
            
            // Apply language filter - only if not all languages are selected
            const allLanguageCheckboxes = document.querySelectorAll('.language-checkbox');
            const LANGUAGE_NOT_DETECTED = '__LANGUAGE_NOT_DETECTED__';
            if (selectedLanguages && selectedLanguages.length > 0 && selectedLanguages.length < allLanguageCheckboxes.length) {
                const includeNotDetected = selectedLanguages.includes(LANGUAGE_NOT_DETECTED);
                dataToCount = dataToCount.filter(item => {
                    const hasNoDetectedLanguages = !item || !item.runtimeInfo || !item.runtimeInfo.detectedLanguages || 
                        !Array.isArray(item.runtimeInfo.detectedLanguages) || 
                        item.runtimeInfo.detectedLanguages.length === 0;
                    
                    if (hasNoDetectedLanguages) {
                        return includeNotDetected;
                    }
                    
                    return item.runtimeInfo.detectedLanguages.some(lang => selectedLanguages.includes(lang));
                });
            }
            
            // Apply condition filters
            const conditionFilters = new Map(); // conditionName -> { checked: [], all: [] }
            document.querySelectorAll('.condition-checkbox').forEach(checkbox => {
                const conditionName = checkbox.dataset.conditionName;
                const reasonEnum = checkbox.dataset.reasonEnum;
                if (conditionName && reasonEnum) {
                    if (!conditionFilters.has(conditionName)) {
                        conditionFilters.set(conditionName, { checked: [], all: [] });
                    }
                    conditionFilters.get(conditionName).all.push(reasonEnum);
                    if (checkbox.checked) {
                        conditionFilters.get(conditionName).checked.push(reasonEnum);
                    }
                }
            });
            conditionFilters.forEach((filterData, conditionName) => {
                if (filterData.checked.length < filterData.all.length) {
                    dataToCount = dataToCount.filter(item => {
                        if (!item || !item.conditions || !item.conditions[conditionName]) {
                            return false;
                        }
                        const condition = item.conditions[conditionName];
                        const reasonEnum = condition && condition.reasonEnum;
                        return reasonEnum && filterData.checked.includes(reasonEnum);
                    });
                }
            });
            
            // Count per health status combination
            const healthStatusCounts = new Map();
            dataToCount.forEach(item => {
                if (item && item.workloadOdigosHealthStatus) {
                    const name = item.workloadOdigosHealthStatus.name || '';
                    const reasonEnum = item.workloadOdigosHealthStatus.reasonEnum || '';
                    const status = item.workloadOdigosHealthStatus.status || '';
                    
                    if (name && reasonEnum && status) {
                        const key = `${status}|${name}|${reasonEnum}`;
                        healthStatusCounts.set(key, (healthStatusCounts.get(key) || 0) + 1);
                    }
                }
            });
            
            // Update counts and zero-count styling
            const allHealthStatusCheckboxes = document.querySelectorAll('.health-status-checkbox');
            allHealthStatusCheckboxes.forEach(checkbox => {
                const key = `${checkbox.dataset.status}|${checkbox.dataset.name}|${checkbox.dataset.reasonEnum}`;
                const count = healthStatusCounts.get(key) || 0;
                const countSpan = document.getElementById(`count-health-status-${checkbox.dataset.status}-${key}`);
                if (countSpan) {
                    countSpan.textContent = `(${count}) `;
                }
                // Update zero-count class on wrapper
                const wrapper = checkbox.closest('.health-status-checkbox-wrapper');
                if (wrapper) {
                    if (count === 0) {
                        wrapper.classList.add('filter-zero-count');
                    } else {
                        wrapper.classList.remove('filter-zero-count');
                    }
                }
            });
        }
        
        
        function applyHealthStatusFilters() {
            const selectedNamespaces = getSelectedNamespaces();
            const selectedWorkloads = getSelectedWorkloads();
            updateHealthStatusCounts();
            updateConditionCounts(allWorkloadData);
            updateHealthStatusCountDisplay();
            displayFilteredData(allWorkloadData, selectedNamespaces, selectedWorkloads);
        }
        
        function populateConditionFilters(data) {
            const filtersContainer = document.getElementById('condition-filters-container');
            filtersContainer.innerHTML = '';
            
            // Get current filters to determine which workloads to use
            const selectedNamespaces = getSelectedNamespaces();
            const selectedWorkloads = getSelectedWorkloads();
            const selectedLanguages = getSelectedLanguages();
            const selectedHealthStatuses = getSelectedHealthStatuses();
            
            // Filter data based on current filters (same logic as updateConditionCounts)
            let dataToUse = allWorkloadData;
            
            // Get all unique namespaces from the data
            const allNamespacesInData = new Set();
            if (Array.isArray(allWorkloadData)) {
                allWorkloadData.forEach(item => {
                    if (item && item.id && item.id.namespace) {
                        allNamespacesInData.add(item.id.namespace);
                    }
                });
            }
            const allNamespacesArray = Array.from(allNamespacesInData);
            
            // Apply namespace filter - only if not all namespaces are selected
            if (selectedNamespaces.length > 0 && selectedNamespaces.length < allNamespacesArray.length) {
                dataToUse = dataToUse.filter(item => 
                    item && item.id && selectedNamespaces.includes(item.id.namespace)
                );
            }
            
            // Get all unique workloads from the filtered data
            const allWorkloadsInData = new Set();
            dataToUse.forEach(item => {
                if (item && item.id && item.id.namespace && item.id.name) {
                    allWorkloadsInData.add(`${item.id.namespace}:${item.id.name}`);
                }
            });
            
            // Apply workload filter - only if not all workloads are selected
            if (selectedWorkloads.length > 0 && selectedWorkloads.length < allWorkloadsInData.size) {
                const workloadSet = new Set(selectedWorkloads.map(w => `${w.namespace}:${w.name}`));
                dataToUse = dataToUse.filter(item => 
                    item && item.id && workloadSet.has(`${item.id.namespace}:${item.id.name}`)
                );
            }
            
            // Apply marked for instrumentation filter
            const showMarked = document.getElementById('filter-marked');
            const showNotMarked = document.getElementById('filter-not-marked');
            if (showMarked && showNotMarked && (!showMarked.checked || !showNotMarked.checked)) {
                dataToUse = dataToUse.filter(item => {
                    if (!item || !item.markedForInstrumentation) {
                        return showNotMarked.checked;
                    }
                    const isMarked = item.markedForInstrumentation.markedForInstrumentation === true;
                    return isMarked ? showMarked.checked : showNotMarked.checked;
                });
            }
            
            // Apply language filter - only if not all languages are selected
            const allLanguageCheckboxes = document.querySelectorAll('.language-checkbox');
            const LANGUAGE_NOT_DETECTED = '__LANGUAGE_NOT_DETECTED__';
            if (selectedLanguages && selectedLanguages.length > 0 && selectedLanguages.length < allLanguageCheckboxes.length) {
                const includeNotDetected = selectedLanguages.includes(LANGUAGE_NOT_DETECTED);
                dataToUse = dataToUse.filter(item => {
                    const hasNoDetectedLanguages = !item || !item.runtimeInfo || !item.runtimeInfo.detectedLanguages || 
                        !Array.isArray(item.runtimeInfo.detectedLanguages) || 
                        item.runtimeInfo.detectedLanguages.length === 0;
                    
                    if (hasNoDetectedLanguages) {
                        return includeNotDetected;
                    }
                    
                    return item.runtimeInfo.detectedLanguages.some(lang => selectedLanguages.includes(lang));
                });
            }
            
            // Apply health status filter - only if not all health statuses are selected
            const allHealthStatusCheckboxes = document.querySelectorAll('.health-status-checkbox');
            if (selectedHealthStatuses && selectedHealthStatuses.length > 0 && selectedHealthStatuses.length < allHealthStatusCheckboxes.length) {
                const healthStatusSet = new Set(selectedHealthStatuses.map(hs => `${hs.status}|${hs.name}|${hs.reasonEnum}`));
                dataToUse = dataToUse.filter(item => {
                    if (!item || !item.workloadOdigosHealthStatus) {
                        return false;
                    }
                    const name = item.workloadOdigosHealthStatus.name || '';
                    const reasonEnum = item.workloadOdigosHealthStatus.reasonEnum || '';
                    const status = item.workloadOdigosHealthStatus.status || '';
                    const key = `${status}|${name}|${reasonEnum}`;
                    return healthStatusSet.has(key);
                });
            }
            
            // Extract all unique conditions from filtered workloads
            // Use condition.name (PascalCase) as the key for ordering, but keep mapping to camelCase key for data access
            const conditionMap = new Map(); // conditionName (from condition.name, PascalCase) -> Map<reasonEnum, {reasonEnum, status, count}>
            const conditionNameToKeyMap = new Map(); // conditionName (PascalCase) -> conditionKey (camelCase)
            
            if (Array.isArray(dataToUse)) {
                dataToUse.forEach(item => {
                    if (item && item.conditions) {
                        // Iterate through all conditions
                        Object.keys(item.conditions).forEach(conditionKey => {
                            const condition = item.conditions[conditionKey];
                            if (condition && condition.name && condition.reasonEnum) {
                                // Use condition.name (PascalCase) instead of conditionKey (camelCase)
                                const conditionName = condition.name;
                                
                                // Store mapping from PascalCase name to camelCase key
                                if (!conditionNameToKeyMap.has(conditionName)) {
                                    conditionNameToKeyMap.set(conditionName, conditionKey);
                                }
                                
                                if (!conditionMap.has(conditionName)) {
                                    conditionMap.set(conditionName, new Map());
                                }
                                
                                const reasonEnumMap = conditionMap.get(conditionName);
                                const reasonEnum = condition.reasonEnum;
                                const status = condition.status || 'Unknown';
                                
                                if (!reasonEnumMap.has(reasonEnum)) {
                                    reasonEnumMap.set(reasonEnum, {
                                        reasonEnum: reasonEnum,
                                        status: status,
                                        count: 0
                                    });
                                }
                                reasonEnumMap.get(reasonEnum).count++;
                                // Update status if we find a different one (prefer non-Unknown)
                                if (status !== 'Unknown' && reasonEnumMap.get(reasonEnum).status === 'Unknown') {
                                    reasonEnumMap.get(reasonEnum).status = status;
                                }
                            }
                        });
                    }
                });
            }
            
            // Sort conditions by predefined order (using condition.name values)
            const conditionOrder = [
                'RuntimeDetection',
                'AgentEnabled',
                'WorkloadRollout',
                'AgentInjected',
                'ProcessesHealthStatus',
                'ExpectingTelemetry'
            ];
            
            const sortedConditionNames = Array.from(conditionMap.keys()).sort((a, b) => {
                const orderA = conditionOrder.indexOf(a);
                const orderB = conditionOrder.indexOf(b);
                
                // If both are in the predefined order, sort by that order
                if (orderA !== -1 && orderB !== -1) {
                    return orderA - orderB;
                }
                // If only A is in the order, A comes first
                if (orderA !== -1) {
                    return -1;
                }
                // If only B is in the order, B comes first
                if (orderB !== -1) {
                    return 1;
                }
                // If neither is in the order, sort alphabetically
                return a.localeCompare(b);
            });
            
            // If no conditions found, show a message or return early
            if (sortedConditionNames.length === 0) {
                return; // No conditions to display
            }
            
            // Create filter group for each condition
            sortedConditionNames.forEach(conditionName => {
                const filterGroup = document.createElement('div');
                filterGroup.className = 'condition-filter-group';
                filterGroup.dataset.conditionName = conditionName;
                // Store the camelCase key for data access
                const conditionKey = conditionNameToKeyMap.get(conditionName);
                if (conditionKey) {
                    filterGroup.dataset.conditionKey = conditionKey;
                }
                
                // Create collapsible header
                const header = document.createElement('div');
                header.className = 'condition-filter-header';
                
                const headerLeft = document.createElement('div');
                headerLeft.className = 'condition-filter-header-left';
                headerLeft.onclick = () => {
                    const content = filterGroup.querySelector('.condition-filter-content');
                    const toggle = filterGroup.querySelector('.condition-filter-toggle');
                    content.classList.toggle('expanded');
                    toggle.classList.toggle('expanded');
                };
                
                const toggle = document.createElement('span');
                toggle.className = 'condition-filter-toggle';
                toggle.textContent = '▶';
                headerLeft.appendChild(toggle);
                
                const label = document.createElement('span');
                label.className = 'condition-filter-label';
                label.textContent = parseCamelCase(conditionName);
                headerLeft.appendChild(label);
                
                header.appendChild(headerLeft);
                
                // Add "all" button
                const allBtn = document.createElement('button');
                allBtn.className = 'condition-filter-all-btn';
                allBtn.id = `condition-filter-all-btn-${conditionName}`;
                allBtn.textContent = 'show all';
                allBtn.title = 'select all options for this filter';
                allBtn.onclick = (e) => {
                    e.stopPropagation();
                    // Check all checkboxes in this condition group
                    const allCheckboxes = document.querySelectorAll(`.condition-checkbox[data-condition-name="${conditionName}"]`);
                    allCheckboxes.forEach(cb => {
                        cb.checked = true;
                    });
                    updateConditionFilterCount(conditionName);
                    updateConditionFilterAllButton(conditionName);
                    updateUrlParams();
                    applyConditionFilters();
                };
                header.appendChild(allBtn);
                
                filterGroup.appendChild(header);
                
                // Create footer with count (directly under header)
                const footer = document.createElement('div');
                footer.className = 'condition-filter-footer';
                footer.id = `condition-filter-count-${conditionName}`;
                const reasonEnumMap = conditionMap.get(conditionName);
                const totalOptions = reasonEnumMap.size;
                footer.textContent = '';
                filterGroup.appendChild(footer);
                
                // Create collapsible content
                const filtersDiv = document.createElement('div');
                filtersDiv.className = 'condition-filter-content';
                filtersDiv.id = `condition-filters-${conditionName}`;
                
                const sortedReasons = Array.from(reasonEnumMap.values()).sort((a, b) => {
                    // First sort by status order (from enum.graphqls)
                    const statusOrderDiff = getStatusOrder(a.status) - getStatusOrder(b.status);
                    if (statusOrderDiff !== 0) {
                        return statusOrderDiff;
                    }
                    // If same status, sort by reasonEnum alphabetically
                    return a.reasonEnum.localeCompare(b.reasonEnum);
                });
                
                // Create checkboxes for each reasonEnum
                sortedReasons.forEach(reasonData => {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'condition-checkbox-wrapper';
                    if (reasonData.count === 0) {
                        wrapper.classList.add('filter-zero-count');
                    }
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `filter-condition-${conditionName}__${reasonData.reasonEnum}`;
                    checkbox.className = 'condition-checkbox';
                    checkbox.dataset.conditionName = conditionName; // PascalCase for display/ordering
                    checkbox.dataset.conditionKey = conditionKey; // camelCase for data access
                    checkbox.dataset.reasonEnum = reasonData.reasonEnum;
                    checkbox.checked = true;
                    checkbox.onchange = () => {
                        updateConditionFilterCount(conditionName);
                        updateConditionFilterAllButton(conditionName);
                        updateUrlParams();
                        applyConditionFilters();
                    };
                    
                    // Add "only" button
                    const onlyBtn = document.createElement('button');
                    onlyBtn.className = 'condition-only-btn';
                    onlyBtn.textContent = 'only';
                    onlyBtn.title = 'filter to show only this state';
                    onlyBtn.onclick = (e) => {
                        e.stopPropagation();
                        // Uncheck all checkboxes in this condition group
                        const allCheckboxes = document.querySelectorAll(`.condition-checkbox[data-condition-name="${conditionName}"]`);
                        allCheckboxes.forEach(cb => {
                            cb.checked = false;
                        });
                        // Check only this checkbox
                        checkbox.checked = true;
                        updateConditionFilterCount(conditionName);
                        updateConditionFilterAllButton(conditionName);
                        updateUrlParams();
                        applyConditionFilters();
                    };
                    wrapper.appendChild(onlyBtn);
                    
                    wrapper.appendChild(checkbox);
                    
                    const label = document.createElement('label');
                    label.htmlFor = `filter-condition-${conditionName}__${reasonData.reasonEnum}`;
                    label.className = 'condition-checkbox-label';
                    
                    // Add count at the beginning
                    const countSpan = document.createElement('span');
                    countSpan.id = `count-condition-${conditionName}__${reasonData.reasonEnum}`;
                    countSpan.className = 'condition-count';
                    countSpan.textContent = `(${reasonData.count}) `;
                    label.appendChild(countSpan);
                    
                    // Add emoji based on status with tooltip
                    const statusEmoji = getStatusEmoji(reasonData.status);
                    if (statusEmoji) {
                        const tooltipWrapper = document.createElement('span');
                        tooltipWrapper.className = 'emoji-tooltip-wrapper';
                        tooltipWrapper.style.marginRight = '0';
                        
                        const emojiSpan = document.createElement('span');
                        emojiSpan.textContent = statusEmoji + ' ';
                        emojiSpan.style.cursor = 'help';
                        tooltipWrapper.appendChild(emojiSpan);
                        
                        const tooltipDiv = document.createElement('div');
                        tooltipDiv.className = 'emoji-tooltip';
                        tooltipDiv.textContent = getStatusTooltip(reasonData.status);
                        tooltipWrapper.appendChild(tooltipDiv);
                        
                        label.appendChild(tooltipWrapper);
                    }
                    
                    // Add reasonEnum text
                    const textSpan = document.createElement('span');
                    textSpan.textContent = parseCamelCase(reasonData.reasonEnum);
                    label.appendChild(textSpan);
                    
                    wrapper.appendChild(label);
                    
                    filtersDiv.appendChild(wrapper);
                });
                
                filterGroup.appendChild(filtersDiv);
                
                // Update button visibility after all checkboxes are created
                updateConditionFilterAllButton(conditionName);
                
                filtersContainer.appendChild(filterGroup);
            });
            
            // Update counts based on current filters
            updateConditionCounts(allWorkloadData);
            updateAllConditionFilterCounts();
            updateAllConditionFilterAllButtons();
            updateConditionHeadersCount();
        }
        
        function updateConditionHeadersCount() {
            // Update count for each condition filter group header
            const conditionGroups = document.querySelectorAll('.condition-filter-group');
            conditionGroups.forEach(group => {
                const conditionName = group.dataset.conditionName;
                if (conditionName) {
                    const label = group.querySelector('.condition-filter-label');
                    if (label) {
                        const count = group.querySelectorAll('.condition-checkbox').length;
                        const baseText = parseCamelCase(conditionName);
                        label.textContent = `${baseText} (${count})`;
                    }
                }
            });
        }
        
        function updateConditionFilterAllButton(conditionName) {
            const allBtn = document.getElementById(`condition-filter-all-btn-${conditionName}`);
            if (!allBtn) return;
            
            const checkboxes = document.querySelectorAll(`.condition-checkbox[data-condition-name="${conditionName}"]`);
            let allChecked = true;
            
            checkboxes.forEach(checkbox => {
                if (!checkbox.checked) {
                    allChecked = false;
                }
            });
            
            // Show button only if some are unchecked
            allBtn.style.display = allChecked ? 'none' : 'inline-block';
        }
        
        function updateAllConditionFilterAllButtons() {
            const conditionGroups = document.querySelectorAll('.condition-filter-group');
            conditionGroups.forEach(group => {
                const conditionName = group.dataset.conditionName;
                if (conditionName) {
                    updateConditionFilterAllButton(conditionName);
                }
            });
        }
        
        function updateConditionCounts(data) {
            // Get current filters
            const selectedNamespaces = getSelectedNamespaces();
            const selectedWorkloads = getSelectedWorkloads();
            const selectedLanguages = getSelectedLanguages();
            const selectedHealthStatuses = getSelectedHealthStatuses();
            
            let dataToCount = allWorkloadData;
            
            // Get all unique namespaces from the data
            const allNamespacesInData = new Set();
            if (Array.isArray(allWorkloadData)) {
                allWorkloadData.forEach(item => {
                    if (item && item.id && item.id.namespace) {
                        allNamespacesInData.add(item.id.namespace);
                    }
                });
            }
            const allNamespacesArray = Array.from(allNamespacesInData);
            
            // Apply namespace filter - only if not all namespaces are selected
            if (selectedNamespaces.length > 0 && selectedNamespaces.length < allNamespacesArray.length) {
                dataToCount = dataToCount.filter(item => 
                    item && item.id && selectedNamespaces.includes(item.id.namespace)
                );
            }
            
            // Get all unique workloads from the filtered data
            const allWorkloadsInData = new Set();
            dataToCount.forEach(item => {
                if (item && item.id && item.id.namespace && item.id.name) {
                    allWorkloadsInData.add(`${item.id.namespace}:${item.id.name}`);
                }
            });
            
            // Apply workload filter - only if not all workloads are selected
            if (selectedWorkloads.length > 0 && selectedWorkloads.length < allWorkloadsInData.size) {
                const workloadSet = new Set(selectedWorkloads.map(w => `${w.namespace}:${w.name}`));
                dataToCount = dataToCount.filter(item => 
                    item && item.id && workloadSet.has(`${item.id.namespace}:${item.id.name}`)
                );
            }
            
            // Apply marked for instrumentation filter
            const showMarked = document.getElementById('filter-marked').checked;
            const showNotMarked = document.getElementById('filter-not-marked').checked;
            if (!showMarked || !showNotMarked) {
                dataToCount = dataToCount.filter(item => {
                    if (!item || !item.markedForInstrumentation) {
                        return showNotMarked;
                    }
                    const isMarked = item.markedForInstrumentation.markedForInstrumentation === true;
                    return isMarked ? showMarked : showNotMarked;
                });
            }
            
            // Apply language filter - only if not all languages are selected
            const allLanguageCheckboxes = document.querySelectorAll('.language-checkbox');
            const LANGUAGE_NOT_DETECTED = '__LANGUAGE_NOT_DETECTED__';
            if (selectedLanguages && selectedLanguages.length > 0 && selectedLanguages.length < allLanguageCheckboxes.length) {
                const includeNotDetected = selectedLanguages.includes(LANGUAGE_NOT_DETECTED);
                dataToCount = dataToCount.filter(item => {
                    const hasNoDetectedLanguages = !item || !item.runtimeInfo || !item.runtimeInfo.detectedLanguages || 
                        !Array.isArray(item.runtimeInfo.detectedLanguages) || 
                        item.runtimeInfo.detectedLanguages.length === 0;
                    
                    if (hasNoDetectedLanguages) {
                        return includeNotDetected;
                    }
                    
                    return item.runtimeInfo.detectedLanguages.some(lang => selectedLanguages.includes(lang));
                });
            }
            
            // Apply health status filter - only if not all health statuses are selected
            const allHealthStatusCheckboxes = document.querySelectorAll('.health-status-checkbox');
            if (selectedHealthStatuses && selectedHealthStatuses.length > 0 && selectedHealthStatuses.length < allHealthStatusCheckboxes.length) {
                const healthStatusSet = new Set(selectedHealthStatuses.map(hs => `${hs.status}|${hs.name}|${hs.reasonEnum}`));
                dataToCount = dataToCount.filter(item => {
                    if (!item || !item.workloadOdigosHealthStatus) {
                        return false; // Exclude items without health status if filtering is active
                    }
                    const name = item.workloadOdigosHealthStatus.name || '';
                    const reasonEnum = item.workloadOdigosHealthStatus.reasonEnum || '';
                    const status = item.workloadOdigosHealthStatus.status || '';
                    const key = `${status}|${name}|${reasonEnum}`;
                    return healthStatusSet.has(key);
                });
            }
            
            // Count each condition's reasonEnum
            // Use condition.name (PascalCase) for matching with filter groups
            const conditionCounts = new Map(); // conditionName (PascalCase) -> Map<reasonEnum, count>
            
            if (Array.isArray(dataToCount)) {
                dataToCount.forEach(item => {
                    if (item && item.conditions) {
                        Object.keys(item.conditions).forEach(conditionKey => {
                            const condition = item.conditions[conditionKey];
                            if (condition && condition.name && condition.reasonEnum) {
                                // Use condition.name (PascalCase) for matching with filter groups
                                const conditionName = condition.name;
                                if (!conditionCounts.has(conditionName)) {
                                    conditionCounts.set(conditionName, new Map());
                                }
                                const reasonEnumMap = conditionCounts.get(conditionName);
                                const reasonEnum = condition.reasonEnum;
                                reasonEnumMap.set(reasonEnum, (reasonEnumMap.get(reasonEnum) || 0) + 1);
                            }
                        });
                    }
                });
            }
            
            // Update count displays and zero-count styling
            conditionCounts.forEach((reasonEnumMap, conditionName) => {
                reasonEnumMap.forEach((count, reasonEnum) => {
                    const countEl = document.getElementById(`count-condition-${conditionName}__${reasonEnum}`);
                    if (countEl) {
                        countEl.textContent = `(${count}) `;
                    }
                    // Update zero-count class on wrapper
                    const checkbox = document.querySelector(`.condition-checkbox[data-condition-name="${conditionName}"][data-reason-enum="${reasonEnum.replace(/:/g, '\\:')}"]`);
                    if (!checkbox) {
                        // Try alternative selector
                        const allCheckboxes = document.querySelectorAll(`.condition-checkbox[data-condition-name="${conditionName}"]`);
                        allCheckboxes.forEach(cb => {
                            if (cb.dataset.reasonEnum === reasonEnum) {
                                const wrapper = cb.closest('.condition-checkbox-wrapper');
                                if (wrapper) {
                                    if (count === 0) {
                                        wrapper.classList.add('filter-zero-count');
                                    } else {
                                        wrapper.classList.remove('filter-zero-count');
                                    }
                                }
                            }
                        });
                    } else {
                        const wrapper = checkbox.closest('.condition-checkbox-wrapper');
                        if (wrapper) {
                            if (count === 0) {
                                wrapper.classList.add('filter-zero-count');
                            } else {
                                wrapper.classList.remove('filter-zero-count');
                            }
                        }
                    }
                });
            });
            
            // Update filter count badges
            updateAllConditionFilterCounts();
        }
        
        function updateConditionFilterCount(conditionName) {
            const checkboxes = document.querySelectorAll(`.condition-checkbox[data-condition-name="${conditionName}"]`);
            const selectedItems = [];
            const totalCount = checkboxes.length;
            
            checkboxes.forEach(checkbox => {
                if (checkbox.checked) {
                    const reasonEnum = checkbox.dataset.reasonEnum;
                    if (reasonEnum) {
                        selectedItems.push(parseCamelCase(reasonEnum));
                    }
                }
            });
            
            const footer = document.getElementById(`condition-filter-count-${conditionName}`);
            if (footer) {
                footer.textContent = formatFilterFooter(selectedItems, totalCount, 'options');
            }
        }
        
        function updateAllConditionFilterCounts() {
            const conditionGroups = document.querySelectorAll('.condition-filter-group');
            conditionGroups.forEach(group => {
                const header = group.querySelector('.condition-filter-header');
                const label = header ? header.querySelector('.condition-filter-label') : null;
                if (label) {
                    const conditionName = label.textContent;
                    updateConditionFilterCount(conditionName);
                }
            });
        }
        
        function applyConditionFilters() {
            const selectedNamespaces = getSelectedNamespaces();
            const selectedWorkloads = getSelectedWorkloads();
            
            // Preserve current checkbox states before regenerating
            const currentCheckboxStates = new Map();
            const existingCheckboxes = document.querySelectorAll('.condition-checkbox');
            existingCheckboxes.forEach(checkbox => {
                const key = `${checkbox.dataset.conditionName}__${checkbox.dataset.reasonEnum}`;
                currentCheckboxStates.set(key, checkbox.checked);
            });
            
            populateConditionFilters(allWorkloadData);
            
            // Restore checkbox states after regeneration
            currentCheckboxStates.forEach((checked, key) => {
                const [conditionName, reasonEnum] = key.split('__');
                const checkbox = document.querySelector(
                    `.condition-checkbox[data-condition-name="${conditionName}"][data-reason-enum="${reasonEnum}"]`
                );
                if (checkbox) {
                    checkbox.checked = checked;
                }
            });
            
            updateConditionCounts(allWorkloadData);
            updateHealthStatusCounts();
            updateAllConditionFilterCounts();
            displayFilteredData(allWorkloadData, selectedNamespaces, selectedWorkloads);
        }
        
        function generateK8sCommands(item) {
            if (!item || !item.id) {
                return [{ title: 'Error', command: 'No workload information available' }];
            }
            
            const namespace = item.id.namespace || 'default';
            const kind = item.id.kind || '';
            const name = item.id.name || '';
            
            if (!kind || !name) {
                return [{ title: 'Error', command: 'Incomplete workload information' }];
            }
            
            const kindLower = kind.toLowerCase();
            let commands = [];
            
            // Describe command
            commands.push({
                title: `Describe ${kind}`,
                command: `kubectl describe ${kindLower} ${name} -n ${namespace}`
            });
            
            // Get YAML
            commands.push({
                title: `Get ${kind} YAML`,
                command: `kubectl get ${kindLower} ${name} -n ${namespace} -o yaml`
            });
            
            return commands;
        }
        
        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                // Could add a visual feedback here if needed
            }).catch(err => {
                console.error('Failed to copy:', err);
            });
        }
        
        function switchTab(tabButton, tabContentId) {
            // Remove active class from all tabs in the same container
            const container = tabButton.closest('.workload-item');
            container.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            container.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            // Add active class to clicked tab
            tabButton.classList.add('active');
            document.getElementById(tabContentId).classList.add('active');
        }
        
        function updateStatusLine(totalCount, filteredCount, selectedNamespaces, selectedWorkloads) {
            const statusSection = document.getElementById('status-section');
            if (!statusSection) return;
            
            const activeFilters = [];
            
            // Check namespace filter(s)
            const allNamespaceCheckboxes = document.querySelectorAll('.namespace-checkbox');
            const allNamespaces = Array.from(allNamespaceCheckboxes).map(cb => cb.dataset.namespace);
            if (selectedNamespaces && selectedNamespaces.length > 0 && selectedNamespaces.length < allNamespaces.length) {
                if (selectedNamespaces.length === 1) {
                    activeFilters.push(`namespace: ${selectedNamespaces[0]}`);
                } else {
                    activeFilters.push(`namespaces: ${selectedNamespaces.join(', ')}`);
                }
            }
            
            // Check workload filter(s)
            const allWorkloadCheckboxes = document.querySelectorAll('.workload-checkbox');
            if (selectedWorkloads && selectedWorkloads.length > 0 && selectedWorkloads.length < allWorkloadCheckboxes.length) {
                if (selectedWorkloads.length === 1) {
                    activeFilters.push(`workload: ${selectedWorkloads[0].name} (${selectedWorkloads[0].namespace})`);
                } else {
                    activeFilters.push(`workloads: ${selectedWorkloads.length} selected`);
                }
            }
            
            // Check language filter(s)
            const selectedLanguages = getSelectedLanguages();
            const allLanguageCheckboxes = document.querySelectorAll('.language-checkbox');
            const LANGUAGE_NOT_DETECTED = '__LANGUAGE_NOT_DETECTED__';
            if (selectedLanguages && selectedLanguages.length > 0 && selectedLanguages.length < allLanguageCheckboxes.length) {
                const displayLanguages = selectedLanguages.map(lang => 
                    lang === LANGUAGE_NOT_DETECTED ? 'language not detected' : lang
                );
                if (selectedLanguages.length === 1) {
                    activeFilters.push(`language: ${displayLanguages[0]}`);
                } else {
                    activeFilters.push(`languages: ${displayLanguages.join(', ')}`);
                }
            }
            
            // Check marked for instrumentation filters
            const showMarked = document.getElementById('filter-marked').checked;
            const showNotMarked = document.getElementById('filter-not-marked').checked;
            if (!showMarked) {
                activeFilters.push('not marked for instrumentation');
            }
            if (!showNotMarked) {
                activeFilters.push('marked for instrumentation');
            }
            
            // Check health status filters
            const selectedHealthStatuses = getSelectedHealthStatuses();
            const allHealthStatusCheckboxes = document.querySelectorAll('.health-status-checkbox');
            if (selectedHealthStatuses && selectedHealthStatuses.length > 0 && selectedHealthStatuses.length < allHealthStatusCheckboxes.length) {
                const statusGroups = new Map(); // status -> [combinations]
                selectedHealthStatuses.forEach(hs => {
                    if (!statusGroups.has(hs.status)) {
                        statusGroups.set(hs.status, []);
                    }
                    statusGroups.get(hs.status).push(`${parseCamelCase(hs.name)}: ${parseCamelCase(hs.reasonEnum)}`);
                });
                
                statusGroups.forEach((combinations, status) => {
                    const statusEmoji = getStatusEmoji(status);
                    if (combinations.length === 1) {
                        activeFilters.push(`${statusEmoji} ${status}: ${combinations[0]}`);
                    } else {
                        activeFilters.push(`${statusEmoji} ${status}: ${combinations.join(', ')}`);
                    }
                });
            }
            
            // Check condition filters - show what's displayed (checked), not what's filtered out
            const conditionCheckboxes = document.querySelectorAll('.condition-checkbox');
            const conditionFilters = new Map(); // conditionName -> {checked: [], all: []}
            
            conditionCheckboxes.forEach(checkbox => {
                const conditionName = checkbox.dataset.conditionName;
                const reasonEnum = checkbox.dataset.reasonEnum;
                
                if (conditionName && reasonEnum) {
                    if (!conditionFilters.has(conditionName)) {
                        conditionFilters.set(conditionName, { checked: [], all: [] });
                    }
                    conditionFilters.get(conditionName).all.push(reasonEnum);
                    if (checkbox.checked) {
                        conditionFilters.get(conditionName).checked.push(reasonEnum);
                    }
                }
            });
            
            conditionFilters.forEach((filterData, conditionName) => {
                // Only show if not all options are checked (i.e., some filtering is happening)
                if (filterData.checked.length < filterData.all.length) {
                    const conditionLabel = parseCamelCase(conditionName);
                    if (filterData.checked.length === 1) {
                        activeFilters.push(`"${conditionLabel}" showing only "${parseCamelCase(filterData.checked[0])}"`);
                    } else {
                        const checkedLabels = filterData.checked.map(re => parseCamelCase(re));
                        activeFilters.push(`"${conditionLabel}" showing only: ${checkedLabels.map(l => `"${l}"`).join(', ')}`);
                    }
                }
            });
            
            // Update header text
            const statusHeaderText = document.getElementById('status-header-text');
            const statusHeaderClearBtn = document.getElementById('status-header-clear-btn');
            const statusFiltersList = document.getElementById('status-filters-list');
            
            if (activeFilters.length === 0) {
                // No filters - hide the status section
                if (statusSection) {
                    statusSection.style.display = 'none';
                }
            } else {
                // Filters active - show count in header
                if (statusHeaderText) {
                    if (filteredCount === 0 && totalCount > 0) {
                        statusHeaderText.textContent = `No workloads match the applied filters (${totalCount} total in cluster)`;
                    } else {
                        statusHeaderText.textContent = `showing ${filteredCount}/${totalCount} workloads in the cluster`;
                    }
                }
                if (statusHeaderClearBtn) {
                    statusHeaderClearBtn.style.display = 'block';
                }
                
                // Populate filters list
                if (statusFiltersList) {
                    statusFiltersList.innerHTML = '';
                    activeFilters.forEach(filter => {
                        const li = document.createElement('li');
                        li.textContent = filter;
                        statusFiltersList.appendChild(li);
                    });
                    // Add message about ignored namespaces
                    const infoLi = document.createElement('li');
                    infoLi.style.fontSize = '12px';
                    infoLi.style.color = '#6b7280';
                    infoLi.style.fontStyle = 'italic';
                    infoLi.style.marginTop = '8px';
                    infoLi.style.paddingTop = '8px';
                    infoLi.style.borderTop = '1px solid #e5e7eb';
                    infoLi.textContent = `Total: ${totalCount} kubernetes workloads in the cluster (excluding ignored namespaces)`;
                    statusFiltersList.appendChild(infoLi);
                }
                // Show status section when filters are active
                if (statusSection) {
                    statusSection.style.display = 'block';
                    // Add warning styling if no results match
                    if (filteredCount === 0 && totalCount > 0) {
                        statusSection.classList.add('no-results');
                    } else {
                        statusSection.classList.remove('no-results');
                    }
                }
            }
        }
        
        function toggleStatusSection() {
            const content = document.getElementById('status-content');
            const toggle = document.getElementById('status-toggle');
            if (content && toggle) {
                content.classList.toggle('expanded');
                toggle.classList.toggle('expanded');
            }
        }
        
        function displayFilteredData(data, selectedNamespaces = [], selectedWorkloads = []) {
            const output = document.getElementById('json-output');
            output.classList.remove('loading');
            output.innerHTML = '';
            
            const totalCount = Array.isArray(data) ? data.length : 0;
            
            if (Array.isArray(data)) {
                let filteredData = data;
                
                // Filter by namespace(s)
                if (selectedNamespaces && selectedNamespaces.length > 0) {
                    filteredData = filteredData.filter(item => 
                        item && item.id && selectedNamespaces.includes(item.id.namespace)
                    );
                }
                
                // Filter by workload(s)
                if (selectedWorkloads && selectedWorkloads.length > 0) {
                    const workloadSet = new Set(selectedWorkloads.map(w => `${w.namespace}:${w.name}`));
                    filteredData = filteredData.filter(item => 
                        item && item.id && workloadSet.has(`${item.id.namespace}:${item.id.name}`)
                    );
                }
                
                // Filter by marked for instrumentation
                const showMarked = document.getElementById('filter-marked').checked;
                const showNotMarked = document.getElementById('filter-not-marked').checked;
                
                if (!showMarked || !showNotMarked) {
                    filteredData = filteredData.filter(item => {
                        if (!item || !item.markedForInstrumentation) {
                            return showNotMarked; // If no markedForInstrumentation property, treat as not marked
                        }
                        const isMarked = item.markedForInstrumentation.markedForInstrumentation === true;
                        if (isMarked) {
                            return showMarked;
                        } else {
                            return showNotMarked;
                        }
                    });
                }
                
                // Filter by programming language
                const selectedLanguages = getSelectedLanguages();
                const allLanguageCheckboxes = document.querySelectorAll('.language-checkbox');
                const LANGUAGE_NOT_DETECTED = '__LANGUAGE_NOT_DETECTED__';
                // Only filter by language if not all languages are selected
                if (selectedLanguages && selectedLanguages.length > 0 && selectedLanguages.length < allLanguageCheckboxes.length) {
                    const includeNotDetected = selectedLanguages.includes(LANGUAGE_NOT_DETECTED);
                    filteredData = filteredData.filter(item => {
                        // Check if workload has no detected languages
                        const hasNoDetectedLanguages = !item || !item.runtimeInfo || !item.runtimeInfo.detectedLanguages || 
                            !Array.isArray(item.runtimeInfo.detectedLanguages) || 
                            item.runtimeInfo.detectedLanguages.length === 0;
                        
                        if (hasNoDetectedLanguages) {
                            return includeNotDetected; // Include only if "language not detected" is selected
                        }
                        
                        // Check if any of the workload's languages match the selected languages
                        return item.runtimeInfo.detectedLanguages.some(lang => selectedLanguages.includes(lang));
                    });
                }
                
                // Filter by health status
                const selectedHealthStatuses = getSelectedHealthStatuses();
                const allHealthStatusCheckboxes = document.querySelectorAll('.health-status-checkbox');
                if (selectedHealthStatuses && selectedHealthStatuses.length > 0 && selectedHealthStatuses.length < allHealthStatusCheckboxes.length) {
                    const healthStatusSet = new Set(selectedHealthStatuses.map(hs => `${hs.status}|${hs.name}|${hs.reasonEnum}`));
                    filteredData = filteredData.filter(item => {
                        if (!item || !item.workloadOdigosHealthStatus) {
                            return false; // Exclude items without health status if filtering is active
                        }
                        const name = item.workloadOdigosHealthStatus.name || '';
                        const reasonEnum = item.workloadOdigosHealthStatus.reasonEnum || '';
                        const status = item.workloadOdigosHealthStatus.status || '';
                        const key = `${status}|${name}|${reasonEnum}`;
                        return healthStatusSet.has(key);
                    });
                }
                
                // Filter by condition reasonEnum (generic for all conditions)
                const conditionCheckboxes = document.querySelectorAll('.condition-checkbox');
                if (conditionCheckboxes.length > 0) {
                    // Group checkboxes by condition name
                    const conditionFilters = new Map(); // conditionName -> {checked: [], all: []}
                    
                    conditionCheckboxes.forEach(checkbox => {
                        const conditionName = checkbox.dataset.conditionName;
                        const reasonEnum = checkbox.dataset.reasonEnum;
                        
                        if (conditionName && reasonEnum) {
                            if (!conditionFilters.has(conditionName)) {
                                conditionFilters.set(conditionName, { checked: [], all: [] });
                            }
                            
                            conditionFilters.get(conditionName).all.push(reasonEnum);
                            if (checkbox.checked) {
                                conditionFilters.get(conditionName).checked.push(reasonEnum);
                            }
                        }
                    });
                    
                    // Apply filters for each condition
                    conditionFilters.forEach((filterData, conditionName) => {
                        // Only filter if not all are checked (i.e., some are unchecked)
                        if (filterData.checked.length < filterData.all.length) {
                            filteredData = filteredData.filter(item => {
                                if (!item || !item.conditions || !item.conditions[conditionName]) {
                                    return false; // If no condition, exclude it
                                }
                                const condition = item.conditions[conditionName];
                                const reasonEnum = condition && condition.reasonEnum;
                                return reasonEnum && filterData.checked.includes(reasonEnum);
                            });
                        }
                    });
                }
                
                // Sort workloads by health status (according to enum order) and then by namespace/kind/name
                const statusOrder = {
                    'Error': 0,
                    'Failure': 1,
                    'Notice': 2,
                    'Pending': 3,
                    'Waiting': 4,
                    'Unsupported': 5,
                    'Disabled': 6,
                    'Success': 7,
                    'Irrelevant': 8,
                    'Unknown': 9
                };
                
                filteredData.sort((a, b) => {
                    // Get status values
                    const statusA = a && a.workloadOdigosHealthStatus && a.workloadOdigosHealthStatus.status ? a.workloadOdigosHealthStatus.status : 'Unknown';
                    const statusB = b && b.workloadOdigosHealthStatus && b.workloadOdigosHealthStatus.status ? b.workloadOdigosHealthStatus.status : 'Unknown';
                    
                    // Compare by status order
                    const statusOrderA = statusOrder[statusA] !== undefined ? statusOrder[statusA] : statusOrder['Unknown'];
                    const statusOrderB = statusOrder[statusB] !== undefined ? statusOrder[statusB] : statusOrder['Unknown'];
                    
                    if (statusOrderA !== statusOrderB) {
                        return statusOrderA - statusOrderB;
                    }
                    
                    // If statuses are equal, sort by namespace/kind/name textually
                    const namespaceA = (a && a.id && a.id.namespace) || '';
                    const namespaceB = (b && b.id && b.id.namespace) || '';
                    const namespaceCompare = namespaceA.localeCompare(namespaceB);
                    if (namespaceCompare !== 0) {
                        return namespaceCompare;
                    }
                    
                    const kindA = (a && a.id && a.id.kind) || '';
                    const kindB = (b && b.id && b.id.kind) || '';
                    const kindCompare = kindA.localeCompare(kindB);
                    if (kindCompare !== 0) {
                        return kindCompare;
                    }
                    
                    const nameA = (a && a.id && a.id.name) || '';
                    const nameB = (b && b.id && b.id.name) || '';
                    return nameA.localeCompare(nameB);
                });
                
                let currentNamespace = null;
                filteredData.forEach((item, idx) => {
                    const itemNamespace = (item && item.id && item.id.namespace) || '';
                    
                    // Add namespace indicator if namespace changed
                    if (itemNamespace !== currentNamespace && itemNamespace) {
                        currentNamespace = itemNamespace;
                        
                        const namespaceDivider = document.createElement('div');
                        namespaceDivider.className = 'namespace-divider';
                        namespaceDivider.style.marginTop = idx === 0 ? '0' : '16px';
                        namespaceDivider.style.marginBottom = '8px';
                        namespaceDivider.style.paddingLeft = '4px';
                        namespaceDivider.style.display = 'flex';
                        namespaceDivider.style.alignItems = 'center';
                        namespaceDivider.style.gap = '8px';
                        namespaceDivider.style.position = 'relative';
                        
                        const namespaceLabel = document.createElement('span');
                        namespaceLabel.style.fontSize = '11px';
                        namespaceLabel.style.fontWeight = '500';
                        namespaceLabel.style.color = '#6b7280';
                        namespaceLabel.textContent = `namespace: ${itemNamespace}`;
                        
                        const line = document.createElement('div');
                        line.style.flex = '1';
                        line.style.height = '1px';
                        line.style.backgroundColor = '#e5e7eb';
                        line.style.marginLeft = '4px';
                        
                        namespaceDivider.appendChild(namespaceLabel);
                        namespaceDivider.appendChild(line);
                        output.appendChild(namespaceDivider);
                    }
                    
                    const wrapper = document.createElement('div');
                    wrapper.className = 'workload-item';
                    wrapper.style.marginBottom = '16px';
                    wrapper.style.padding = '20px';
                    wrapper.style.border = '1px solid #e5e7eb';
                    wrapper.style.borderRadius = '6px';
                    wrapper.style.backgroundColor = '#ffffff';
                    wrapper.style.boxShadow = '0 1px 2px rgba(0,0,0,0.05)';
                    wrapper.style.transition = 'border-color 0.2s ease, box-shadow 0.2s ease';
                    wrapper.onmouseenter = () => {
                        wrapper.style.boxShadow = '0 1px 3px rgba(0,0,0,0.1), 0 1px 2px rgba(0,0,0,0.06)';
                        wrapper.style.borderColor = '#d1d5db';
                    };
                    wrapper.onmouseleave = () => {
                        wrapper.style.boxShadow = '0 1px 2px rgba(0,0,0,0.05)';
                        wrapper.style.borderColor = '#e5e7eb';
                    };
                    
                    let label = 'Item ' + idx;
                    if (item && item.id && item.id.namespace && item.id.kind && item.id.name) {
                        label = item.id.namespace + '/' + item.id.kind + '/' + item.id.name;
                    }
                    
                    // Add container instrumentation summary
                    if (item && item.containers && Array.isArray(item.containers)) {
                        const totalContainers = item.containers.length;
                        const instrumentedContainers = item.containers.filter(container => 
                            container && container.agentEnabled && container.agentEnabled.agentEnabled === true
                        );
                        const instrumentedCount = instrumentedContainers.length;
                        
                        // Collect distro names from instrumented containers
                        const distroNames = instrumentedContainers
                            .map(container => container.agentEnabled && container.agentEnabled.otelDistroName)
                            .filter(distro => distro && distro.trim())
                            .filter((distro, index, self) => self.indexOf(distro) === index); // Remove duplicates
                        
                        let summary = `(${instrumentedCount}/${totalContainers} containers instrumented`;
                        if (distroNames.length > 0) {
                            summary += `: ${distroNames.join(', ')}`;
                        }
                        summary += ')';
                        label += ' ' + summary;
                    }
                    
                    // Get pods instrumentation info for conditional styling
                    let podsInstrumentedInfo = null;
                    let agentInjectedStatus = null;
                    if (item && item.pods && Array.isArray(item.pods)) {
                        const totalPods = item.pods.length;
                        const instrumentedPods = item.pods.filter(pod => 
                            pod && pod.agentInjected === true
                        ).length;
                        podsInstrumentedInfo = {
                            instrumented: instrumentedPods,
                            total: totalPods,
                            text: ` (${instrumentedPods}/${totalPods} pods instrumented)`
                        };
                    }
                    
                    // Get agentInjected condition status for color determination
                    if (item && item.conditions && item.conditions.agentInjected && item.conditions.agentInjected.status) {
                        agentInjectedStatus = item.conditions.agentInjected.status;
                    }
                    
                    // Get status emoji from workloadOdigosHealthStatus
                    let statusEmoji = null;
                    let statusMessage = null;
                    if (item && item.workloadOdigosHealthStatus && item.workloadOdigosHealthStatus.status) {
                        statusEmoji = getStatusEmoji(item.workloadOdigosHealthStatus.status);
                        statusMessage = item.workloadOdigosHealthStatus.message || '';
                    }
                    
                    // Create expandable header
                    const headerDiv = document.createElement('div');
                    headerDiv.style.cursor = 'pointer';
                    headerDiv.style.marginBottom = '5px';
                    headerDiv.classList.add('expandable');
                    
                    const toggle = document.createElement('span');
                    toggle.className = 'toggle';
                    toggle.textContent = '';
                    headerDiv.appendChild(toggle);
                    
                    // Add emoji if available
                    if (statusEmoji) {
                        const tooltipWrapper = document.createElement('span');
                        tooltipWrapper.className = 'emoji-tooltip-wrapper';
                        
                        const emojiSpan = document.createElement('span');
                        emojiSpan.textContent = statusEmoji + ' ';
                        emojiSpan.style.cursor = 'help';
                        tooltipWrapper.appendChild(emojiSpan);
                        
                        const tooltipDiv = document.createElement('div');
                        tooltipDiv.className = 'emoji-tooltip';
                        tooltipDiv.textContent = statusMessage || '';
                        tooltipWrapper.appendChild(tooltipDiv);
                        
                        headerDiv.appendChild(tooltipWrapper);
                    }
                    
                    const labelSpan = document.createElement('span');
                    labelSpan.className = 'json-key';
                    labelSpan.textContent = label;
                    headerDiv.appendChild(labelSpan);
                    
                    // Add pods instrumentation summary with conditional styling
                    if (podsInstrumentedInfo) {
                        const podsSpan = document.createElement('span');
                        podsSpan.textContent = podsInstrumentedInfo.text;
                        podsSpan.style.fontSize = '11px';
                        
                        // Color based on agentInjected condition status (desired state or not)
                        if (agentInjectedStatus) {
                            // Desired states: Success, Disabled
                            if (agentInjectedStatus === 'Success' || agentInjectedStatus === 'Disabled') {
                                podsSpan.style.color = '#10b981'; // Green
                            } 
                            // Not desired states: Error, Failure, Notice, Pending, Waiting, Unsupported
                            else if (agentInjectedStatus === 'Error' || agentInjectedStatus === 'Failure' || 
                                     agentInjectedStatus === 'Notice' || agentInjectedStatus === 'Pending' || 
                                     agentInjectedStatus === 'Waiting' || agentInjectedStatus === 'Unsupported') {
                                podsSpan.style.color = '#ef4444'; // Red
                            }
                            // Irrelevant, Unknown - keep default color (black)
                        }
                        // If status not available, keep default color (black)
                        
                        headerDiv.appendChild(podsSpan);
                    }
                    
                    // Add health status message under the title if available
                    if (statusMessage) {
                        const statusMessageSpan = document.createElement('span');
                        statusMessageSpan.className = 'workload-health-message';
                        statusMessageSpan.textContent = statusMessage;
                        headerDiv.appendChild(statusMessageSpan);
                    }
                    
                    // Create collapsible content div
                    const contentDiv = document.createElement('div');
                    contentDiv.className = 'children';
                    contentDiv.style.display = 'none';
                    
                    // Create tabs
                    const tabsDiv = document.createElement('div');
                    tabsDiv.className = 'tabs';
                    
                    // Overview tab
                    const overviewTabButton = document.createElement('button');
                    overviewTabButton.className = 'tab-button active';
                    overviewTabButton.textContent = 'Overview';
                    overviewTabButton.onclick = () => switchTab(overviewTabButton, `overview-content-${idx}`);
                    
                    // Instrumentation tab
                    const instrumentationTabButton = document.createElement('button');
                    instrumentationTabButton.className = 'tab-button';
                    instrumentationTabButton.textContent = 'Instrumentation';
                    instrumentationTabButton.onclick = () => switchTab(instrumentationTabButton, `instrumentation-content-${idx}`);
                    
                    // Containers tab
                    const containersTabButton = document.createElement('button');
                    containersTabButton.className = 'tab-button';
                    const containersCount = (item && item.containers && Array.isArray(item.containers)) ? item.containers.length : 0;
                    containersTabButton.textContent = `Containers (${containersCount})`;
                    containersTabButton.onclick = () => switchTab(containersTabButton, `containers-content-${idx}`);
                    
                    // Pods tab
                    const podsTabButton = document.createElement('button');
                    podsTabButton.className = 'tab-button';
                    podsTabButton.style.display = 'inline-flex';
                    podsTabButton.style.alignItems = 'center';
                    podsTabButton.style.gap = '4px';
                    const podsCount = (item && item.pods && Array.isArray(item.pods)) ? item.pods.length : 0;
                    
                    // Add podsAgentInjectionStatus emoji (odigos) first
                    if (item && item.podsAgentInjectionStatus && item.podsAgentInjectionStatus.status) {
                        const agentStatusEmoji = getStatusEmoji(item.podsAgentInjectionStatus.status);
                        if (agentStatusEmoji) {
                            const agentTooltipWrapper = document.createElement('span');
                            agentTooltipWrapper.className = 'emoji-tooltip-wrapper';
                            agentTooltipWrapper.style.marginRight = '0';
                            
                            const agentEmojiSpan = document.createElement('span');
                            agentEmojiSpan.textContent = agentStatusEmoji;
                            agentEmojiSpan.style.cursor = 'help';
                            agentTooltipWrapper.appendChild(agentEmojiSpan);
                            
                            if (item.podsAgentInjectionStatus.message) {
                                const agentTooltipDiv = document.createElement('div');
                                agentTooltipDiv.className = 'emoji-tooltip';
                                agentTooltipDiv.textContent = item.podsAgentInjectionStatus.message;
                                agentTooltipWrapper.appendChild(agentTooltipDiv);
                            }
                            
                            podsTabButton.appendChild(agentTooltipWrapper);
                        }
                    }
                    
                    // Add podsHealthStatus emoji (application health) second
                    if (item && item.podsHealthStatus && item.podsHealthStatus.status) {
                        const healthStatusEmoji = getStatusEmoji(item.podsHealthStatus.status);
                        if (healthStatusEmoji) {
                            const healthTooltipWrapper = document.createElement('span');
                            healthTooltipWrapper.className = 'emoji-tooltip-wrapper';
                            healthTooltipWrapper.style.marginRight = '0';
                            
                            const healthEmojiSpan = document.createElement('span');
                            healthEmojiSpan.textContent = healthStatusEmoji;
                            healthEmojiSpan.style.cursor = 'help';
                            healthTooltipWrapper.appendChild(healthEmojiSpan);
                            
                            if (item.podsHealthStatus.message) {
                                const healthTooltipDiv = document.createElement('div');
                                healthTooltipDiv.className = 'emoji-tooltip';
                                healthTooltipDiv.textContent = item.podsHealthStatus.message;
                                healthTooltipWrapper.appendChild(healthTooltipDiv);
                            }
                            
                            podsTabButton.appendChild(healthTooltipWrapper);
                        }
                    }
                    
                    const podsText = document.createElement('span');
                    podsText.textContent = `Pods (${podsCount})`;
                    podsTabButton.appendChild(podsText);
                    
                    podsTabButton.onclick = () => switchTab(podsTabButton, `pods-content-${idx}`);
                    
                    // K8s Commands tab
                    const k8sTabButton = document.createElement('button');
                    k8sTabButton.className = 'tab-button';
                    k8sTabButton.textContent = 'K8s Commands';
                    k8sTabButton.onclick = () => switchTab(k8sTabButton, `k8s-content-${idx}`);
                    
                    // Raw tab
                    const rawTabButton = document.createElement('button');
                    rawTabButton.className = 'tab-button';
                    rawTabButton.textContent = 'Raw';
                    rawTabButton.onclick = () => switchTab(rawTabButton, `raw-content-${idx}`);
                    
                    // Append tabs in order: Overview, Instrumentation, Containers, Pods, K8s Commands, Raw
                    tabsDiv.appendChild(overviewTabButton);
                    tabsDiv.appendChild(instrumentationTabButton);
                    tabsDiv.appendChild(containersTabButton);
                    tabsDiv.appendChild(podsTabButton);
                    tabsDiv.appendChild(k8sTabButton);
                    tabsDiv.appendChild(rawTabButton);
                    contentDiv.appendChild(tabsDiv);
                    
                    // Overview content tab
                    const overviewContent = document.createElement('div');
                    overviewContent.id = `overview-content-${idx}`;
                    overviewContent.className = 'tab-content active';
                    
                    // Workload ID section
                    if (item && item.id) {
                        const workloadIdSection = document.createElement('div');
                        workloadIdSection.style.marginBottom = '15px';
                        workloadIdSection.style.padding = '10px';
                        workloadIdSection.style.backgroundColor = '#f9fafb';
                        workloadIdSection.style.border = '1px solid #e5e7eb';
                        workloadIdSection.style.borderRadius = '6px';
                        
                        const workloadIdTitle = document.createElement('div');
                        workloadIdTitle.style.fontSize = '14px';
                        workloadIdTitle.style.fontWeight = '600';
                        workloadIdTitle.style.color = '#333';
                        workloadIdTitle.style.marginBottom = '8px';
                        workloadIdTitle.textContent = 'Workload ID';
                        workloadIdSection.appendChild(workloadIdTitle);
                        
                        // Namespace
                        if (item.id.namespace) {
                            const namespaceDiv = document.createElement('div');
                            namespaceDiv.style.fontSize = '13px';
                            namespaceDiv.style.color = '#666';
                            namespaceDiv.style.marginBottom = '4px';
                            namespaceDiv.style.display = 'flex';
                            namespaceDiv.style.alignItems = 'center';
                            namespaceDiv.style.gap = '6px';
                            
                            const namespaceLabel = document.createElement('strong');
                            namespaceLabel.style.fontWeight = '600';
                            namespaceLabel.style.color = '#333';
                            namespaceLabel.textContent = 'namespace:';
                            namespaceDiv.appendChild(namespaceLabel);
                            namespaceDiv.appendChild(document.createTextNode(' ' + item.id.namespace));
                            
                            const namespaceCopyBtn = document.createElement('button');
                            namespaceCopyBtn.className = 'k8s-copy-btn';
                            namespaceCopyBtn.textContent = 'Copy';
                            namespaceCopyBtn.style.fontSize = '10px';
                            namespaceCopyBtn.style.padding = '2px 6px';
                            namespaceCopyBtn.onclick = (e) => {
                                e.stopPropagation();
                                copyToClipboard(item.id.namespace);
                            };
                            namespaceDiv.appendChild(namespaceCopyBtn);
                            
                            workloadIdSection.appendChild(namespaceDiv);
                        }
                        
                        // Kind
                        if (item.id.kind) {
                            const kindDiv = document.createElement('div');
                            kindDiv.style.fontSize = '13px';
                            kindDiv.style.color = '#666';
                            kindDiv.style.marginBottom = '4px';
                            kindDiv.style.display = 'flex';
                            kindDiv.style.alignItems = 'center';
                            kindDiv.style.gap = '6px';
                            
                            const kindLabel = document.createElement('strong');
                            kindLabel.style.fontWeight = '600';
                            kindLabel.style.color = '#333';
                            kindLabel.textContent = 'kind:';
                            kindDiv.appendChild(kindLabel);
                            kindDiv.appendChild(document.createTextNode(' ' + item.id.kind));
                            
                            workloadIdSection.appendChild(kindDiv);
                        }
                        
                        // Name
                        if (item.id.name) {
                            const nameDiv = document.createElement('div');
                            nameDiv.style.fontSize = '13px';
                            nameDiv.style.color = '#666';
                            nameDiv.style.display = 'flex';
                            nameDiv.style.alignItems = 'center';
                            nameDiv.style.gap = '6px';
                            
                            const nameLabel = document.createElement('strong');
                            nameLabel.style.fontWeight = '600';
                            nameLabel.style.color = '#333';
                            nameLabel.textContent = 'name:';
                            nameDiv.appendChild(nameLabel);
                            nameDiv.appendChild(document.createTextNode(' ' + item.id.name));
                            
                            const nameCopyBtn = document.createElement('button');
                            nameCopyBtn.className = 'k8s-copy-btn';
                            nameCopyBtn.textContent = 'Copy';
                            nameCopyBtn.style.fontSize = '10px';
                            nameCopyBtn.style.padding = '2px 6px';
                            nameCopyBtn.onclick = (e) => {
                                e.stopPropagation();
                                copyToClipboard(item.id.name);
                            };
                            nameDiv.appendChild(nameCopyBtn);
                            
                            workloadIdSection.appendChild(nameDiv);
                        }
                        
                        overviewContent.appendChild(workloadIdSection);
                    }
                    
                    // Odigos Health section
                    if (item && item.workloadOdigosHealthStatus) {
                        const odigosHealthSection = document.createElement('div');
                        odigosHealthSection.style.marginBottom = '15px';
                        odigosHealthSection.style.padding = '10px';
                        odigosHealthSection.style.backgroundColor = '#f9fafb';
                        odigosHealthSection.style.border = '1px solid #e5e7eb';
                        odigosHealthSection.style.borderRadius = '6px';
                        
                        const odigosHealthTitle = document.createElement('div');
                        odigosHealthTitle.style.fontSize = '14px';
                        odigosHealthTitle.style.fontWeight = '600';
                        odigosHealthTitle.style.color = '#333';
                        odigosHealthTitle.style.marginBottom = '8px';
                        odigosHealthTitle.textContent = 'Odigos Health';
                        odigosHealthSection.appendChild(odigosHealthTitle);
                        
                        const healthStatus = item.workloadOdigosHealthStatus;
                        
                        // Message (at the top, without label)
                        if (healthStatus.message) {
                            const messageDiv = document.createElement('div');
                            messageDiv.style.fontSize = '13px';
                            messageDiv.style.color = '#666';
                            messageDiv.style.marginBottom = '8px';
                            messageDiv.textContent = healthStatus.message;
                            odigosHealthSection.appendChild(messageDiv);
                        }
                        
                        // Status
                        if (healthStatus.status) {
                            const statusContainer = document.createElement('div');
                            statusContainer.style.marginBottom = '4px';
                            
                            const statusDiv = document.createElement('div');
                            statusDiv.style.fontSize = '13px';
                            statusDiv.style.color = '#666';
                            statusDiv.style.display = 'flex';
                            statusDiv.style.alignItems = 'center';
                            statusDiv.style.gap = '6px';
                            
                            const statusLabel = document.createElement('strong');
                            statusLabel.style.fontWeight = '600';
                            statusLabel.style.color = '#333';
                            statusLabel.textContent = 'status:';
                            statusDiv.appendChild(statusLabel);
                            
                            const statusEmoji = getStatusEmoji(healthStatus.status);
                            if (statusEmoji) {
                                const tooltipWrapper = document.createElement('span');
                                tooltipWrapper.className = 'emoji-tooltip-wrapper';
                                tooltipWrapper.style.marginRight = '0';
                                
                                const emojiSpan = document.createElement('span');
                                emojiSpan.textContent = statusEmoji + ' ';
                                emojiSpan.style.cursor = 'help';
                                tooltipWrapper.appendChild(emojiSpan);
                                
                                const tooltipDiv = document.createElement('div');
                                tooltipDiv.className = 'emoji-tooltip';
                                tooltipDiv.textContent = getStatusTooltip(healthStatus.status);
                                tooltipWrapper.appendChild(tooltipDiv);
                                
                                statusDiv.appendChild(tooltipWrapper);
                            }
                            statusDiv.appendChild(document.createTextNode(healthStatus.status));
                            
                            statusContainer.appendChild(statusDiv);
                            
                            // Add status description text below status
                            const statusDescription = getStatusTooltip(healthStatus.status);
                            if (statusDescription) {
                                const descriptionDiv = document.createElement('div');
                                descriptionDiv.style.fontSize = '11px';
                                descriptionDiv.style.color = '#9ca3af';
                                descriptionDiv.style.marginTop = '2px';
                                descriptionDiv.style.marginLeft = '20px';
                                descriptionDiv.textContent = statusDescription;
                                statusContainer.appendChild(descriptionDiv);
                            }
                            
                            odigosHealthSection.appendChild(statusContainer);
                        }
                        
                        // Name (changed to "instrumentation phase")
                        if (healthStatus.name) {
                            const nameDiv = document.createElement('div');
                            nameDiv.style.fontSize = '13px';
                            nameDiv.style.color = '#666';
                            nameDiv.style.marginBottom = '4px';
                            nameDiv.style.display = 'flex';
                            nameDiv.style.alignItems = 'center';
                            nameDiv.style.gap = '6px';
                            
                            const nameLabel = document.createElement('strong');
                            nameLabel.style.fontWeight = '600';
                            nameLabel.style.color = '#333';
                            nameLabel.textContent = 'instrumentation phase:';
                            nameDiv.appendChild(nameLabel);
                            nameDiv.appendChild(document.createTextNode(' ' + parseCamelCase(healthStatus.name)));
                            
                            odigosHealthSection.appendChild(nameDiv);
                        }
                        
                        // Reason Enum
                        if (healthStatus.reasonEnum) {
                            const reasonDiv = document.createElement('div');
                            reasonDiv.style.fontSize = '13px';
                            reasonDiv.style.color = '#666';
                            reasonDiv.style.marginBottom = '4px';
                            reasonDiv.style.display = 'flex';
                            reasonDiv.style.alignItems = 'center';
                            reasonDiv.style.gap = '6px';
                            
                            const reasonLabel = document.createElement('strong');
                            reasonLabel.style.fontWeight = '600';
                            reasonLabel.style.color = '#333';
                            reasonLabel.textContent = 'reason:';
                            reasonDiv.appendChild(reasonLabel);
                            reasonDiv.appendChild(document.createTextNode(' ' + parseCamelCase(healthStatus.reasonEnum)));
                            
                            odigosHealthSection.appendChild(reasonDiv);
                        }
                        
                        overviewContent.appendChild(odigosHealthSection);
                    }
                    
                    // Instrumentation section
                    if (item && item.markedForInstrumentation) {
                        const instrumentationSection = document.createElement('div');
                        instrumentationSection.style.marginBottom = '15px';
                        instrumentationSection.style.padding = '10px';
                        instrumentationSection.style.background = 'linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%)';
                        instrumentationSection.style.border = '1px solid #e2e8f0';
                        instrumentationSection.style.borderRadius = '4px';
                        
                        const instrumentationTitle = document.createElement('div');
                        instrumentationTitle.style.fontSize = '14px';
                        instrumentationTitle.style.fontWeight = '600';
                        instrumentationTitle.style.color = '#333';
                        instrumentationTitle.style.marginBottom = '8px';
                        instrumentationTitle.textContent = 'Instrumentation';
                        instrumentationSection.appendChild(instrumentationTitle);
                        
                        // Marked for instrumentation field
                        const markedDiv = document.createElement('div');
                        markedDiv.style.fontSize = '13px';
                        markedDiv.style.color = '#666';
                        markedDiv.style.display = 'flex';
                        markedDiv.style.alignItems = 'center';
                        markedDiv.style.gap = '3px';
                        
                        // Add emoji and text
                        const isMarked = item.markedForInstrumentation.markedForInstrumentation === true;
                        const markedEmoji = isMarked ? '✅' : '➖';
                        markedDiv.appendChild(document.createTextNode(markedEmoji + ' '));
                        
                        if (isMarked) {
                            markedDiv.appendChild(document.createTextNode('marked for instrumentation'));
                        } else {
                            const notSpan = document.createElement('strong');
                            notSpan.style.fontWeight = '600';
                            notSpan.textContent = 'NOT';
                            markedDiv.appendChild(notSpan);
                            markedDiv.appendChild(document.createTextNode('marked for instrumentation'));
                        }
                        
                        instrumentationSection.appendChild(markedDiv);
                        
                        // Runtime Info field
                        if (item && item.runtimeInfo && item.runtimeInfo.completedStatus && item.runtimeInfo.completedStatus.status !== 'Irrelevant') {
                            const runtimeDiv = document.createElement('div');
                            runtimeDiv.style.fontSize = '13px';
                            runtimeDiv.style.color = '#666';
                            runtimeDiv.style.display = 'flex';
                            runtimeDiv.style.alignItems = 'center';
                            runtimeDiv.style.gap = '3px';
                            
                            // Add emoji from completedStatus if available
                            if (item.runtimeInfo.completedStatus && item.runtimeInfo.completedStatus.status) {
                                const statusEmoji = getStatusEmoji(item.runtimeInfo.completedStatus.status);
                                if (statusEmoji) {
                                    const tooltipWrapper = document.createElement('span');
                                    tooltipWrapper.className = 'emoji-tooltip-wrapper';
                                    tooltipWrapper.style.marginRight = '0';
                                    
                                    const emojiSpan = document.createElement('span');
                                    emojiSpan.textContent = statusEmoji;
                                    emojiSpan.style.cursor = 'help';
                                    tooltipWrapper.appendChild(emojiSpan);
                                    
                                    if (item.runtimeInfo.completedStatus.message) {
                                        const tooltipDiv = document.createElement('div');
                                        tooltipDiv.className = 'emoji-tooltip';
                                        tooltipDiv.textContent = item.runtimeInfo.completedStatus.message;
                                        tooltipWrapper.appendChild(tooltipDiv);
                                    }
                                    
                                    runtimeDiv.appendChild(tooltipWrapper);
                                    runtimeDiv.appendChild(document.createTextNode(' '));
                                }
                            }
                            
                            // Add text based on completed property
                            const isCompleted = item.runtimeInfo.completed === true;
                            const runtimeText = isCompleted ? 'runtime detection completed' : 'no runtime info available yet';
                            runtimeDiv.appendChild(document.createTextNode(runtimeText));
                            
                            instrumentationSection.appendChild(runtimeDiv);
                        }
                        
                        // Agent injected enabled field
                        if (item && item.agentEnabled && item.agentEnabled.enabledStatus && item.agentEnabled.enabledStatus.status !== 'Irrelevant') {
                            const agentEnabledDiv = document.createElement('div');
                            agentEnabledDiv.style.fontSize = '13px';
                            agentEnabledDiv.style.color = '#666';
                            agentEnabledDiv.style.display = 'flex';
                            agentEnabledDiv.style.alignItems = 'center';
                            agentEnabledDiv.style.gap = '3px';
                            
                            // Add emoji from enabledStatus if available
                            if (item.agentEnabled.enabledStatus && item.agentEnabled.enabledStatus.status) {
                                const statusEmoji = getStatusEmoji(item.agentEnabled.enabledStatus.status);
                                if (statusEmoji) {
                                    const tooltipWrapper = document.createElement('span');
                                    tooltipWrapper.className = 'emoji-tooltip-wrapper';
                                    tooltipWrapper.style.marginRight = '0';
                                    
                                    const emojiSpan = document.createElement('span');
                                    emojiSpan.textContent = statusEmoji;
                                    emojiSpan.style.cursor = 'help';
                                    tooltipWrapper.appendChild(emojiSpan);
                                    
                                    if (item.agentEnabled.enabledStatus.message) {
                                        const tooltipDiv = document.createElement('div');
                                        tooltipDiv.className = 'emoji-tooltip';
                                        tooltipDiv.textContent = item.agentEnabled.enabledStatus.message;
                                        tooltipWrapper.appendChild(tooltipDiv);
                                    }
                                    
                                    agentEnabledDiv.appendChild(tooltipWrapper);
                                    agentEnabledDiv.appendChild(document.createTextNode(' '));
                                }
                            }
                            
                            // Add text
                            const agentEnabledText = item.agentEnabled.agentEnabled === true ? 'agent injection enabled' : 'agent injection NOT enabled';
                            if (item.agentEnabled.agentEnabled !== true) {
                                const notSpan = document.createElement('strong');
                                notSpan.style.fontWeight = '600';
                                notSpan.textContent = 'agent injection NOT';
                                agentEnabledDiv.appendChild(notSpan);
                                agentEnabledDiv.appendChild(document.createTextNode(' enabled'));
                            } else {
                                agentEnabledDiv.appendChild(document.createTextNode(agentEnabledText));
                            }
                            
                            instrumentationSection.appendChild(agentEnabledDiv);
                        }
                        
                        // Rollout status field
                        if (item && item.rollout && item.rollout.rolloutStatus && item.rollout.rolloutStatus.status !== 'Irrelevant') {
                            const rolloutDiv = document.createElement('div');
                            rolloutDiv.style.fontSize = '13px';
                            rolloutDiv.style.color = '#666';
                            rolloutDiv.style.display = 'flex';
                            rolloutDiv.style.alignItems = 'center';
                            rolloutDiv.style.gap = '3px';
                            
                            // Add emoji from rolloutStatus if available
                            if (item.rollout.rolloutStatus.status) {
                                const statusEmoji = getStatusEmoji(item.rollout.rolloutStatus.status);
                                if (statusEmoji) {
                                    const tooltipWrapper = document.createElement('span');
                                    tooltipWrapper.className = 'emoji-tooltip-wrapper';
                                    tooltipWrapper.style.marginRight = '0';
                                    
                                    const emojiSpan = document.createElement('span');
                                    emojiSpan.textContent = statusEmoji;
                                    emojiSpan.style.cursor = 'help';
                                    tooltipWrapper.appendChild(emojiSpan);
                                    
                                    if (item.rollout.rolloutStatus.message) {
                                        const tooltipDiv = document.createElement('div');
                                        tooltipDiv.className = 'emoji-tooltip';
                                        tooltipDiv.textContent = item.rollout.rolloutStatus.message;
                                        tooltipWrapper.appendChild(tooltipDiv);
                                    }
                                    
                                    rolloutDiv.appendChild(tooltipWrapper);
                                    rolloutDiv.appendChild(document.createTextNode(' '));
                                }
                            }
                            
                            // Add text
                            rolloutDiv.appendChild(document.createTextNode('rollout pods to apply instrumentation agent'));
                            
                            instrumentationSection.appendChild(rolloutDiv);
                        }
                        
                        // Agent injected to running pods status field
                        if (item && item.podsAgentInjectionStatus && item.podsAgentInjectionStatus.status && item.podsAgentInjectionStatus.status !== 'Irrelevant') {
                            const podsAgentDiv = document.createElement('div');
                            podsAgentDiv.style.fontSize = '13px';
                            podsAgentDiv.style.color = '#666';
                            podsAgentDiv.style.display = 'flex';
                            podsAgentDiv.style.alignItems = 'center';
                            podsAgentDiv.style.gap = '3px';
                            
                            // Add emoji from podsAgentInjectionStatus if available
                            if (item.podsAgentInjectionStatus.status) {
                                const statusEmoji = getStatusEmoji(item.podsAgentInjectionStatus.status);
                                if (statusEmoji) {
                                    const tooltipWrapper = document.createElement('span');
                                    tooltipWrapper.className = 'emoji-tooltip-wrapper';
                                    tooltipWrapper.style.marginRight = '0';
                                    
                                    const emojiSpan = document.createElement('span');
                                    emojiSpan.textContent = statusEmoji;
                                    emojiSpan.style.cursor = 'help';
                                    tooltipWrapper.appendChild(emojiSpan);
                                    
                                    if (item.podsAgentInjectionStatus.message) {
                                        const tooltipDiv = document.createElement('div');
                                        tooltipDiv.className = 'emoji-tooltip';
                                        tooltipDiv.textContent = item.podsAgentInjectionStatus.message;
                                        tooltipWrapper.appendChild(tooltipDiv);
                                    }
                                    
                                    podsAgentDiv.appendChild(tooltipWrapper);
                                    podsAgentDiv.appendChild(document.createTextNode(' '));
                                }
                            }
                            
                            // Add text
                            podsAgentDiv.appendChild(document.createTextNode('agent injected to running pods'));
                            
                            instrumentationSection.appendChild(podsAgentDiv);
                        }
                        
                        // Processes health status field
                        if (item && item.processesHealthStatus && item.processesHealthStatus.status && item.processesHealthStatus.status !== 'Irrelevant') {
                            const processesHealthDiv = document.createElement('div');
                            processesHealthDiv.style.fontSize = '13px';
                            processesHealthDiv.style.color = '#666';
                            processesHealthDiv.style.display = 'flex';
                            processesHealthDiv.style.alignItems = 'center';
                            processesHealthDiv.style.gap = '3px';
                            
                            // Add emoji from processesHealthStatus if available
                            if (item.processesHealthStatus.status) {
                                const statusEmoji = getStatusEmoji(item.processesHealthStatus.status);
                                if (statusEmoji) {
                                    const tooltipWrapper = document.createElement('span');
                                    tooltipWrapper.className = 'emoji-tooltip-wrapper';
                                    tooltipWrapper.style.marginRight = '0';
                                    
                                    const emojiSpan = document.createElement('span');
                                    emojiSpan.textContent = statusEmoji;
                                    emojiSpan.style.cursor = 'help';
                                    tooltipWrapper.appendChild(emojiSpan);
                                    
                                    if (item.processesHealthStatus.message) {
                                        const tooltipDiv = document.createElement('div');
                                        tooltipDiv.className = 'emoji-tooltip';
                                        tooltipDiv.textContent = item.processesHealthStatus.message;
                                        tooltipWrapper.appendChild(tooltipDiv);
                                    }
                                    
                                    processesHealthDiv.appendChild(tooltipWrapper);
                                    processesHealthDiv.appendChild(document.createTextNode(' '));
                                }
                            }
                            
                            // Add text
                            processesHealthDiv.appendChild(document.createTextNode('instrumented processes health'));
                            
                            instrumentationSection.appendChild(processesHealthDiv);
                        }
                        
                        overviewContent.appendChild(instrumentationSection);
                    }
                    
                    // Containers section
                    if (item && item.containers && Array.isArray(item.containers) && item.containers.length > 0) {
                        const containersSection = document.createElement('div');
                        containersSection.style.marginBottom = '15px';
                        containersSection.style.padding = '10px';
                        containersSection.style.background = 'linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%)';
                        containersSection.style.border = '1px solid #e2e8f0';
                        containersSection.style.borderRadius = '4px';
                        
                        const containersTitle = document.createElement('div');
                        containersTitle.style.fontSize = '14px';
                        containersTitle.style.fontWeight = '600';
                        containersTitle.style.color = '#333';
                        containersTitle.style.marginBottom = '8px';
                        containersTitle.innerHTML = 'Containers <span style="font-size: 11px; font-weight: 400; color: #888; font-style: italic;">- Runtime detection and instrumentation decisions</span>';
                        containersSection.appendChild(containersTitle);
                        
                        // Add description text
                        const containersDescription = document.createElement('div');
                        containersDescription.style.fontSize = '12px';
                        containersDescription.style.color = '#666';
                        containersDescription.style.marginBottom = '10px';
                        containersDescription.style.lineHeight = '1.5';
                        const workloadKind = (item && item.id && item.id.kind) ? item.id.kind.toLowerCase() : 'workload';
                        containersDescription.innerHTML = '<strong>These settings apply to future pods</strong> that will be created by this ' + workloadKind + '. ' +
                            '<span style="font-style: italic;">Note: Existing pods may show different statuses based on their current state.</span>';
                        containersSection.appendChild(containersDescription);
                        
                        item.containers.forEach((container) => {
                            const containerWrapper = document.createElement('div');
                            containerWrapper.style.marginBottom = '6px';
                            
                            const containerDiv = document.createElement('div');
                            containerDiv.style.fontSize = '13px';
                            containerDiv.style.color = '#666';
                            containerDiv.style.display = 'flex';
                            containerDiv.style.alignItems = 'center';
                            containerDiv.style.gap = '6px';
                            
                            // Get status emoji from agentEnabledStatus
                            let statusEmoji = null;
                            let statusMessage = null;
                            if (container.agentEnabled && container.agentEnabled.agentEnabledStatus) {
                                const agentStatus = container.agentEnabled.agentEnabledStatus;
                                if (agentStatus.status && typeof agentStatus.status === 'string') {
                                    statusEmoji = getStatusEmoji(agentStatus.status);
                                    statusMessage = agentStatus.message || '';
                                }
                            }
                            
                            // Add emoji with tooltip if available
                            if (statusEmoji) {
                                const tooltipWrapper = document.createElement('span');
                                tooltipWrapper.className = 'emoji-tooltip-wrapper';
                                tooltipWrapper.style.marginRight = '0';
                                
                                const emojiSpan = document.createElement('span');
                                emojiSpan.textContent = statusEmoji + ' ';
                                emojiSpan.style.cursor = 'help';
                                tooltipWrapper.appendChild(emojiSpan);
                                
                                const tooltipDiv = document.createElement('div');
                                tooltipDiv.className = 'emoji-tooltip';
                                tooltipDiv.textContent = statusMessage || '';
                                tooltipWrapper.appendChild(tooltipDiv);
                                
                                containerDiv.appendChild(tooltipWrapper);
                            }
                            
                            // Container name with runtime information
                            const containerName = container.containerName || 'Unknown';
                            let containerText = containerName;
                            
                            // Add runtime information - check overrides first, then top-level runtimeInfo
                            let runtimeInfo = null;
                            let isOverride = false;
                            
                            // Check if there's an override with runtimeInfo for this container
                            if (container.overrides && container.overrides.runtimeInfo) {
                                runtimeInfo = container.overrides.runtimeInfo;
                                isOverride = true;
                            }
                            
                            // If no override found, use top-level runtimeInfo
                            if (!runtimeInfo && container.runtimeInfo) {
                                runtimeInfo = container.runtimeInfo;
                            }
                            
                            if (runtimeInfo) {
                                const runtimeParts = [];
                                if (runtimeInfo.language) {
                                    runtimeParts.push(runtimeInfo.language);
                                }
                                if (runtimeInfo.runtimeVersion) {
                                    runtimeParts.push(runtimeInfo.runtimeVersion);
                                }
                                if (runtimeParts.length > 0) {
                                    const suffix = isOverride ? ' - automatic detection overwritten' : ' - automatic detection';
                                    containerText += ' (' + runtimeParts.join(' ') + suffix + ')';
                                }
                            }
                            
                            containerDiv.appendChild(document.createTextNode(containerText));
                            
                            // Add otelDistroName or "uninstrumented"
                            const distroSpan = document.createElement('span');
                            distroSpan.style.marginLeft = '6px';
                            distroSpan.style.color = '#666';
                            distroSpan.style.fontSize = '12px';
                            const otelDistroName = container.agentEnabled && container.agentEnabled.otelDistroName;
                            if (otelDistroName) {
                                distroSpan.textContent = '[' + otelDistroName + ']';
                            } else {
                                distroSpan.textContent = '[uninstrumented]';
                            }
                            containerDiv.appendChild(distroSpan);
                            
                            // Add signal emojis (traces, metrics, logs)
                            if (container.agentEnabled) {
                                const signals = [
                                    { name: 'traces', emoji: '👣', label: 'Traces' },
                                    { name: 'metrics', emoji: '📈', label: 'Metrics' },
                                    { name: 'logs', emoji: '🪵', label: 'Logs' }
                                ];
                                
                                signals.forEach(signal => {
                                    const signalData = container.agentEnabled[signal.name];
                                    if (signalData && signalData !== null && signalData.enabled !== false) {
                                        const tooltipWrapper = document.createElement('span');
                                        tooltipWrapper.className = 'emoji-tooltip-wrapper';
                                        
                                        const emojiSpan = document.createElement('span');
                                        emojiSpan.textContent = signal.emoji + ' ';
                                        emojiSpan.style.cursor = 'help';
                                        tooltipWrapper.appendChild(emojiSpan);
                                        
                                        const tooltipDiv = document.createElement('div');
                                        tooltipDiv.className = 'emoji-tooltip';
                                        tooltipDiv.textContent = signal.label + ' enabled';
                                        tooltipWrapper.appendChild(tooltipDiv);
                                        
                                        containerDiv.appendChild(tooltipWrapper);
                                    }
                                });
                            }
                            
                            containerWrapper.appendChild(containerDiv);
                            
                            // Add instrumentations list (only if it exists)
                            if (container.instrumentations && Array.isArray(container.instrumentations) && container.instrumentations.length > 0) {
                                const instrumentationsContainer = document.createElement('div');
                                instrumentationsContainer.style.marginLeft = '8px';
                                instrumentationsContainer.style.marginTop = '6px';
                                
                                const instrumentationsLabel = document.createElement('div');
                                instrumentationsLabel.style.fontSize = '11px';
                                instrumentationsLabel.style.fontWeight = '600';
                                instrumentationsLabel.style.color = '#333';
                                instrumentationsLabel.style.marginBottom = '2px';
                                instrumentationsLabel.textContent = 'Instrumented libraries:';
                                instrumentationsContainer.appendChild(instrumentationsLabel);
                                
                                container.instrumentations.forEach((inst) => {
                                    const instDiv = document.createElement('div');
                                    instDiv.style.fontSize = '10px';
                                    instDiv.style.color = '#666';
                                    instDiv.style.marginLeft = '8px';
                                    instDiv.style.marginBottom = '1px';
                                    instDiv.style.display = 'flex';
                                    instDiv.style.alignItems = 'center';
                                    instDiv.style.gap = '6px';
                                    
                                    const instNameSpan = document.createElement('span');
                                    instNameSpan.textContent = inst.name;
                                    instDiv.appendChild(instNameSpan);
                                    
                                    if (inst.isStandardLibrary === true) {
                                        const tagSpan = document.createElement('span');
                                        tagSpan.textContent = 'standard library';
                                        tagSpan.style.fontSize = '9px';
                                        tagSpan.style.color = '#1976d2';
                                        tagSpan.style.backgroundColor = '#e3f2fd';
                                        tagSpan.style.padding = '2px 6px';
                                        tagSpan.style.borderRadius = '3px';
                                        tagSpan.style.fontWeight = '500';
                                        instDiv.appendChild(tagSpan);
                                    }
                                    
                                    instrumentationsContainer.appendChild(instDiv);
                                });
                                
                                containerWrapper.appendChild(instrumentationsContainer);
                            }
                            
                            containersSection.appendChild(containerWrapper);
                        });
                        
                        overviewContent.appendChild(containersSection);
                    }
                    
                    contentDiv.appendChild(overviewContent);
                    
                    // Instrumentation content tab
                    const instrumentationContent = document.createElement('div');
                    instrumentationContent.id = `instrumentation-content-${idx}`;
                    instrumentationContent.className = 'tab-content';
                    
                    // Marked for Instrumentation section
                    if (item && item.markedForInstrumentation) {
                        const markedSection = document.createElement('div');
                        markedSection.style.marginBottom = '15px';
                        markedSection.style.padding = '10px';
                        markedSection.style.background = 'linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%)';
                        markedSection.style.borderRadius = '4px';
                        
                        const markedTitle = document.createElement('div');
                        markedTitle.style.fontSize = '14px';
                        markedTitle.style.fontWeight = '600';
                        markedTitle.style.color = '#333';
                        markedTitle.style.marginBottom = '8px';
                        markedTitle.textContent = '#1 Marked for Instrumentation';
                        markedSection.appendChild(markedTitle);
                        
                        // Status field (emoji + text)
                        const statusDiv = document.createElement('div');
                        statusDiv.style.fontSize = '13px';
                        statusDiv.style.color = '#666';
                        statusDiv.style.marginBottom = '8px';
                        statusDiv.style.display = 'flex';
                        statusDiv.style.alignItems = 'center';
                        statusDiv.style.gap = '3px';
                        
                        const isMarked = item.markedForInstrumentation.markedForInstrumentation === true;
                        const markedEmoji = isMarked ? '✅' : '➖';
                        statusDiv.appendChild(document.createTextNode(markedEmoji + ' '));
                        
                        if (isMarked) {
                            statusDiv.appendChild(document.createTextNode('marked for instrumentation'));
                        } else {
                            const notSpan = document.createElement('strong');
                            notSpan.style.fontWeight = '600';
                            notSpan.textContent = 'NOT';
                            statusDiv.appendChild(notSpan);
                            statusDiv.appendChild(document.createTextNode(' marked for instrumentation'));
                        }
                        
                        markedSection.appendChild(statusDiv);
                        
                        // Message field
                        if (item.markedForInstrumentation.message) {
                            const messageDiv = document.createElement('div');
                            messageDiv.style.fontSize = '13px';
                            messageDiv.style.color = '#666';
                            messageDiv.style.marginBottom = '8px';
                            messageDiv.style.display = 'flex';
                            messageDiv.style.alignItems = 'center';
                            messageDiv.style.gap = '6px';
                            
                            const messageLabel = document.createElement('strong');
                            messageLabel.style.fontWeight = '600';
                            messageLabel.style.color = '#333';
                            messageLabel.textContent = 'message:';
                            messageDiv.appendChild(messageLabel);
                            messageDiv.appendChild(document.createTextNode(' ' + item.markedForInstrumentation.message));
                            
                            markedSection.appendChild(messageDiv);
                        }
                        
                        // DecisionEnum field
                        if (item.markedForInstrumentation.decisionEnum) {
                            const decisionDiv = document.createElement('div');
                            decisionDiv.style.fontSize = '13px';
                            decisionDiv.style.color = '#666';
                            decisionDiv.style.display = 'flex';
                            decisionDiv.style.alignItems = 'center';
                            decisionDiv.style.gap = '6px';
                            
                            const decisionLabel = document.createElement('strong');
                            decisionLabel.style.fontWeight = '600';
                            decisionLabel.style.color = '#333';
                            decisionLabel.textContent = 'decisionEnum:';
                            decisionDiv.appendChild(decisionLabel);
                            decisionDiv.appendChild(document.createTextNode(' ' + item.markedForInstrumentation.decisionEnum));
                            
                            markedSection.appendChild(decisionDiv);
                        }
                        
                        instrumentationContent.appendChild(markedSection);
                    }
                    
                    // Runtime Detection section
                    if (item && item.runtimeInfo) {
                        const runtimeSection = document.createElement('div');
                        runtimeSection.style.marginBottom = '15px';
                        runtimeSection.style.padding = '10px';
                        runtimeSection.style.background = 'linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%)';
                        runtimeSection.style.borderRadius = '4px';
                        
                        const runtimeTitle = document.createElement('div');
                        runtimeTitle.style.fontSize = '14px';
                        runtimeTitle.style.fontWeight = '600';
                        runtimeTitle.style.color = '#333';
                        runtimeTitle.style.marginBottom = '8px';
                        runtimeTitle.textContent = '#2 Runtime Detection';
                        runtimeSection.appendChild(runtimeTitle);
                        
                        // Status field (emoji + text)
                        const statusDiv = document.createElement('div');
                        statusDiv.style.fontSize = '13px';
                        statusDiv.style.color = '#666';
                        statusDiv.style.marginBottom = '8px';
                        statusDiv.style.display = 'flex';
                        statusDiv.style.alignItems = 'center';
                        statusDiv.style.gap = '3px';
                        
                        // Add emoji from completedStatus if available
                        if (item.runtimeInfo.completedStatus && item.runtimeInfo.completedStatus.status) {
                            const statusEmoji = getStatusEmoji(item.runtimeInfo.completedStatus.status);
                            if (statusEmoji) {
                                const tooltipWrapper = document.createElement('span');
                                tooltipWrapper.className = 'emoji-tooltip-wrapper';
                                tooltipWrapper.style.marginRight = '0';
                                
                                const emojiSpan = document.createElement('span');
                                emojiSpan.textContent = statusEmoji;
                                emojiSpan.style.cursor = 'help';
                                tooltipWrapper.appendChild(emojiSpan);
                                
                                if (item.runtimeInfo.completedStatus.message) {
                                    const tooltipDiv = document.createElement('div');
                                    tooltipDiv.className = 'emoji-tooltip';
                                    tooltipDiv.textContent = item.runtimeInfo.completedStatus.message;
                                    tooltipWrapper.appendChild(tooltipDiv);
                                }
                                
                                statusDiv.appendChild(tooltipWrapper);
                                statusDiv.appendChild(document.createTextNode(' '));
                            }
                        }
                        
                        // Add text based on completed property
                        const isCompleted = item.runtimeInfo.completed === true;
                        const runtimeText = isCompleted ? 'runtime detection completed' : 'no runtime info available yet';
                        statusDiv.appendChild(document.createTextNode(runtimeText));
                        
                        runtimeSection.appendChild(statusDiv);
                        
                        // Containers summary
                        if (item.runtimeInfo.containers && Array.isArray(item.runtimeInfo.containers)) {
                            const totalContainers = item.runtimeInfo.containers.length;
                            const containersWithLanguage = item.runtimeInfo.containers.filter(container => 
                                container && container.language && container.language.toLowerCase() !== 'unknown'
                            ).length;
                            
                            const containersDiv = document.createElement('div');
                            containersDiv.style.fontSize = '13px';
                            containersDiv.style.color = '#666';
                            containersDiv.style.marginBottom = '8px';
                            containersDiv.style.display = 'flex';
                            containersDiv.style.alignItems = 'center';
                            containersDiv.style.gap = '6px';
                            
                            const resultLabel = document.createElement('strong');
                            resultLabel.style.fontWeight = '600';
                            resultLabel.style.color = '#333';
                            resultLabel.textContent = 'detection result:';
                            containersDiv.appendChild(resultLabel);
                            
                            let containersText = `${containersWithLanguage}/${totalContainers} containers have detected language`;
                            
                            // Add detected languages list if available
                            if (item.runtimeInfo.detectedLanguages && Array.isArray(item.runtimeInfo.detectedLanguages) && item.runtimeInfo.detectedLanguages.length > 0) {
                                const languagesList = item.runtimeInfo.detectedLanguages.join(', ');
                                containersText += ` (${languagesList})`;
                            }
                            
                            containersDiv.appendChild(document.createTextNode(' ' + containersText));
                            runtimeSection.appendChild(containersDiv);
                        }
                        
                        // Message field
                        if (item.runtimeInfo.completedStatus && item.runtimeInfo.completedStatus.message) {
                            const messageDiv = document.createElement('div');
                            messageDiv.style.fontSize = '13px';
                            messageDiv.style.color = '#666';
                            messageDiv.style.marginBottom = '8px';
                            messageDiv.style.display = 'flex';
                            messageDiv.style.alignItems = 'center';
                            messageDiv.style.gap = '6px';
                            
                            const messageLabel = document.createElement('strong');
                            messageLabel.style.fontWeight = '600';
                            messageLabel.style.color = '#333';
                            messageLabel.textContent = 'message:';
                            messageDiv.appendChild(messageLabel);
                            messageDiv.appendChild(document.createTextNode(' ' + item.runtimeInfo.completedStatus.message));
                            
                            runtimeSection.appendChild(messageDiv);
                        }
                        
                        // ReasonEnum field
                        if (item.runtimeInfo.completedStatus && item.runtimeInfo.completedStatus.reasonEnum) {
                            const reasonDiv = document.createElement('div');
                            reasonDiv.style.fontSize = '13px';
                            reasonDiv.style.color = '#666';
                            reasonDiv.style.display = 'flex';
                            reasonDiv.style.alignItems = 'center';
                            reasonDiv.style.gap = '6px';
                            
                            const reasonLabel = document.createElement('strong');
                            reasonLabel.style.fontWeight = '600';
                            reasonLabel.style.color = '#333';
                            reasonLabel.textContent = 'reasonEnum:';
                            reasonDiv.appendChild(reasonLabel);
                            reasonDiv.appendChild(document.createTextNode(' ' + item.runtimeInfo.completedStatus.reasonEnum));
                            
                            runtimeSection.appendChild(reasonDiv);
                        }
                        
                        instrumentationContent.appendChild(runtimeSection);
                    }
                    
                    // Agent Enabled section
                    if (item && item.agentEnabled) {
                        const agentEnabledSection = document.createElement('div');
                        agentEnabledSection.style.marginBottom = '15px';
                        agentEnabledSection.style.padding = '10px';
                        agentEnabledSection.style.background = 'linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%)';
                        agentEnabledSection.style.borderRadius = '4px';
                        
                        const agentEnabledTitle = document.createElement('div');
                        agentEnabledTitle.style.fontSize = '14px';
                        agentEnabledTitle.style.fontWeight = '600';
                        agentEnabledTitle.style.color = '#333';
                        agentEnabledTitle.style.marginBottom = '8px';
                        agentEnabledTitle.textContent = '#3 Instrumentation Agent Injection';
                        agentEnabledSection.appendChild(agentEnabledTitle);
                        
                        // Status field (emoji + text)
                        const statusDiv = document.createElement('div');
                        statusDiv.style.fontSize = '13px';
                        statusDiv.style.color = '#666';
                        statusDiv.style.marginBottom = '8px';
                        statusDiv.style.display = 'flex';
                        statusDiv.style.alignItems = 'center';
                        statusDiv.style.gap = '3px';
                        
                        // Add emoji from enabledStatus if available
                        if (item.agentEnabled.enabledStatus && item.agentEnabled.enabledStatus.status) {
                            const statusEmoji = getStatusEmoji(item.agentEnabled.enabledStatus.status);
                            if (statusEmoji) {
                                const tooltipWrapper = document.createElement('span');
                                tooltipWrapper.className = 'emoji-tooltip-wrapper';
                                tooltipWrapper.style.marginRight = '0';
                                
                                const emojiSpan = document.createElement('span');
                                emojiSpan.textContent = statusEmoji;
                                emojiSpan.style.cursor = 'help';
                                tooltipWrapper.appendChild(emojiSpan);
                                
                                if (item.agentEnabled.enabledStatus.message) {
                                    const tooltipDiv = document.createElement('div');
                                    tooltipDiv.className = 'emoji-tooltip';
                                    tooltipDiv.textContent = item.agentEnabled.enabledStatus.message;
                                    tooltipWrapper.appendChild(tooltipDiv);
                                }
                                
                                statusDiv.appendChild(tooltipWrapper);
                                statusDiv.appendChild(document.createTextNode(' '));
                            }
                        }
                        
                        // Add text based on agentEnabled property
                        const isEnabled = item.agentEnabled.agentEnabled === true;
                        const enabledText = isEnabled ? 'agent injection enabled' : 'agent injection NOT enabled';
                        if (isEnabled) {
                            statusDiv.appendChild(document.createTextNode(enabledText));
                        } else {
                            const notSpan = document.createElement('strong');
                            notSpan.style.fontWeight = '600';
                            notSpan.textContent = 'agent injection NOT';
                            statusDiv.appendChild(notSpan);
                            statusDiv.appendChild(document.createTextNode(' enabled'));
                        }
                        
                        agentEnabledSection.appendChild(statusDiv);
                        
                        // Message field
                        if (item.agentEnabled.enabledStatus && item.agentEnabled.enabledStatus.message) {
                            const messageDiv = document.createElement('div');
                            messageDiv.style.fontSize = '13px';
                            messageDiv.style.color = '#666';
                            messageDiv.style.marginBottom = '8px';
                            messageDiv.style.display = 'flex';
                            messageDiv.style.alignItems = 'center';
                            messageDiv.style.gap = '6px';
                            
                            const messageLabel = document.createElement('strong');
                            messageLabel.style.fontWeight = '600';
                            messageLabel.style.color = '#333';
                            messageLabel.textContent = 'message:';
                            messageDiv.appendChild(messageLabel);
                            messageDiv.appendChild(document.createTextNode(' ' + item.agentEnabled.enabledStatus.message));
                            
                            agentEnabledSection.appendChild(messageDiv);
                        }
                        
                        // ReasonEnum field
                        if (item.agentEnabled.enabledStatus && item.agentEnabled.enabledStatus.reasonEnum) {
                            const reasonDiv = document.createElement('div');
                            reasonDiv.style.fontSize = '13px';
                            reasonDiv.style.color = '#666';
                            reasonDiv.style.display = 'flex';
                            reasonDiv.style.alignItems = 'center';
                            reasonDiv.style.gap = '6px';
                            
                            const reasonLabel = document.createElement('strong');
                            reasonLabel.style.fontWeight = '600';
                            reasonLabel.style.color = '#333';
                            reasonLabel.textContent = 'reasonEnum:';
                            reasonDiv.appendChild(reasonLabel);
                            reasonDiv.appendChild(document.createTextNode(' ' + item.agentEnabled.enabledStatus.reasonEnum));
                            
                            agentEnabledSection.appendChild(reasonDiv);
                        }
                        
                        instrumentationContent.appendChild(agentEnabledSection);
                    }
                    
                    // Rollout section
                    if (item && item.rollout && item.rollout.rolloutStatus) {
                        const rolloutSection = document.createElement('div');
                        rolloutSection.style.marginBottom = '15px';
                        rolloutSection.style.padding = '10px';
                        rolloutSection.style.background = 'linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%)';
                        rolloutSection.style.borderRadius = '4px';
                        
                        const rolloutTitle = document.createElement('div');
                        rolloutTitle.style.fontSize = '14px';
                        rolloutTitle.style.fontWeight = '600';
                        rolloutTitle.style.color = '#333';
                        rolloutTitle.style.marginBottom = '8px';
                        rolloutTitle.textContent = '#4 Rollout Workload Pods to Apply the Instrumentation Agent';
                        rolloutSection.appendChild(rolloutTitle);
                        
                        // Status field (emoji + text)
                        const statusDiv = document.createElement('div');
                        statusDiv.style.fontSize = '13px';
                        statusDiv.style.color = '#666';
                        statusDiv.style.marginBottom = '8px';
                        statusDiv.style.display = 'flex';
                        statusDiv.style.alignItems = 'center';
                        statusDiv.style.gap = '3px';
                        
                        // Add emoji from rolloutStatus if available
                        if (item.rollout.rolloutStatus.status) {
                            const statusEmoji = getStatusEmoji(item.rollout.rolloutStatus.status);
                            if (statusEmoji) {
                                const tooltipWrapper = document.createElement('span');
                                tooltipWrapper.className = 'emoji-tooltip-wrapper';
                                tooltipWrapper.style.marginRight = '0';
                                
                                const emojiSpan = document.createElement('span');
                                emojiSpan.textContent = statusEmoji;
                                emojiSpan.style.cursor = 'help';
                                tooltipWrapper.appendChild(emojiSpan);
                                
                                if (item.rollout.rolloutStatus.message) {
                                    const tooltipDiv = document.createElement('div');
                                    tooltipDiv.className = 'emoji-tooltip';
                                    tooltipDiv.textContent = item.rollout.rolloutStatus.message;
                                    tooltipWrapper.appendChild(tooltipDiv);
                                }
                                
                                statusDiv.appendChild(tooltipWrapper);
                                statusDiv.appendChild(document.createTextNode(' '));
                            }
                        }
                        
                        // Add text
                        statusDiv.appendChild(document.createTextNode('rollout pods to apply instrumentation agent'));
                        
                        rolloutSection.appendChild(statusDiv);
                        
                        // Message field
                        if (item.rollout.rolloutStatus.message) {
                            const messageDiv = document.createElement('div');
                            messageDiv.style.fontSize = '13px';
                            messageDiv.style.color = '#666';
                            messageDiv.style.marginBottom = '8px';
                            messageDiv.style.display = 'flex';
                            messageDiv.style.alignItems = 'center';
                            messageDiv.style.gap = '6px';
                            
                            const messageLabel = document.createElement('strong');
                            messageLabel.style.fontWeight = '600';
                            messageLabel.style.color = '#333';
                            messageLabel.textContent = 'message:';
                            messageDiv.appendChild(messageLabel);
                            messageDiv.appendChild(document.createTextNode(' ' + item.rollout.rolloutStatus.message));
                            
                            rolloutSection.appendChild(messageDiv);
                        }
                        
                        // ReasonEnum field
                        if (item.rollout.rolloutStatus.reasonEnum) {
                            const reasonDiv = document.createElement('div');
                            reasonDiv.style.fontSize = '13px';
                            reasonDiv.style.color = '#666';
                            reasonDiv.style.display = 'flex';
                            reasonDiv.style.alignItems = 'center';
                            reasonDiv.style.gap = '6px';
                            
                            const reasonLabel = document.createElement('strong');
                            reasonLabel.style.fontWeight = '600';
                            reasonLabel.style.color = '#333';
                            reasonLabel.textContent = 'reasonEnum:';
                            reasonDiv.appendChild(reasonLabel);
                            reasonDiv.appendChild(document.createTextNode(' ' + item.rollout.rolloutStatus.reasonEnum));
                            
                            rolloutSection.appendChild(reasonDiv);
                        }
                        
                        instrumentationContent.appendChild(rolloutSection);
                    }
                    
                    // Agent Injected to Running Pods section
                    if (item && item.podsAgentInjectionStatus && item.podsAgentInjectionStatus.status) {
                        const podsAgentSection = document.createElement('div');
                        podsAgentSection.style.marginBottom = '15px';
                        podsAgentSection.style.padding = '10px';
                        podsAgentSection.style.background = 'linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%)';
                        podsAgentSection.style.borderRadius = '4px';
                        
                        const podsAgentTitle = document.createElement('div');
                        podsAgentTitle.style.fontSize = '14px';
                        podsAgentTitle.style.fontWeight = '600';
                        podsAgentTitle.style.color = '#333';
                        podsAgentTitle.style.marginBottom = '8px';
                        podsAgentTitle.textContent = '#5 Agent Injected to Running Pods';
                        podsAgentSection.appendChild(podsAgentTitle);
                        
                        // Status field (emoji + text)
                        const statusDiv = document.createElement('div');
                        statusDiv.style.fontSize = '13px';
                        statusDiv.style.color = '#666';
                        statusDiv.style.marginBottom = '8px';
                        statusDiv.style.display = 'flex';
                        statusDiv.style.alignItems = 'center';
                        statusDiv.style.gap = '3px';
                        
                        // Add emoji from podsAgentInjectionStatus if available
                        if (item.podsAgentInjectionStatus.status) {
                            const statusEmoji = getStatusEmoji(item.podsAgentInjectionStatus.status);
                            if (statusEmoji) {
                                const tooltipWrapper = document.createElement('span');
                                tooltipWrapper.className = 'emoji-tooltip-wrapper';
                                tooltipWrapper.style.marginRight = '0';
                                
                                const emojiSpan = document.createElement('span');
                                emojiSpan.textContent = statusEmoji;
                                emojiSpan.style.cursor = 'help';
                                tooltipWrapper.appendChild(emojiSpan);
                                
                                if (item.podsAgentInjectionStatus.message) {
                                    const tooltipDiv = document.createElement('div');
                                    tooltipDiv.className = 'emoji-tooltip';
                                    tooltipDiv.textContent = item.podsAgentInjectionStatus.message;
                                    tooltipWrapper.appendChild(tooltipDiv);
                                }
                                
                                statusDiv.appendChild(tooltipWrapper);
                                statusDiv.appendChild(document.createTextNode(' '));
                            }
                        }
                        
                        // Add text
                        statusDiv.appendChild(document.createTextNode('agent injected to running pods'));
                        
                        podsAgentSection.appendChild(statusDiv);
                        
                        // Message field
                        if (item.podsAgentInjectionStatus.message) {
                            const messageDiv = document.createElement('div');
                            messageDiv.style.fontSize = '13px';
                            messageDiv.style.color = '#666';
                            messageDiv.style.marginBottom = '8px';
                            messageDiv.style.display = 'flex';
                            messageDiv.style.alignItems = 'center';
                            messageDiv.style.gap = '6px';
                            
                            const messageLabel = document.createElement('strong');
                            messageLabel.style.fontWeight = '600';
                            messageLabel.style.color = '#333';
                            messageLabel.textContent = 'message:';
                            messageDiv.appendChild(messageLabel);
                            messageDiv.appendChild(document.createTextNode(' ' + item.podsAgentInjectionStatus.message));
                            
                            podsAgentSection.appendChild(messageDiv);
                        }
                        
                        // ReasonEnum field
                        if (item.podsAgentInjectionStatus.reasonEnum) {
                            const reasonDiv = document.createElement('div');
                            reasonDiv.style.fontSize = '13px';
                            reasonDiv.style.color = '#666';
                            reasonDiv.style.display = 'flex';
                            reasonDiv.style.alignItems = 'center';
                            reasonDiv.style.gap = '6px';
                            
                            const reasonLabel = document.createElement('strong');
                            reasonLabel.style.fontWeight = '600';
                            reasonLabel.style.color = '#333';
                            reasonLabel.textContent = 'reasonEnum:';
                            reasonDiv.appendChild(reasonLabel);
                            reasonDiv.appendChild(document.createTextNode(' ' + item.podsAgentInjectionStatus.reasonEnum));
                            
                            podsAgentSection.appendChild(reasonDiv);
                        }
                        
                        instrumentationContent.appendChild(podsAgentSection);
                    }
                    
                    // Processes Health section
                    if (item && item.processesHealthStatus && item.processesHealthStatus.status) {
                        const processesHealthSection = document.createElement('div');
                        processesHealthSection.style.marginBottom = '15px';
                        processesHealthSection.style.padding = '10px';
                        processesHealthSection.style.background = 'linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%)';
                        processesHealthSection.style.borderRadius = '4px';
                        
                        const processesHealthTitle = document.createElement('div');
                        processesHealthTitle.style.fontSize = '14px';
                        processesHealthTitle.style.fontWeight = '600';
                        processesHealthTitle.style.color = '#333';
                        processesHealthTitle.style.marginBottom = '8px';
                        processesHealthTitle.textContent = '#6 Instrumented Processes Health';
                        processesHealthSection.appendChild(processesHealthTitle);
                        
                        // Status field (emoji + text)
                        const statusDiv = document.createElement('div');
                        statusDiv.style.fontSize = '13px';
                        statusDiv.style.color = '#666';
                        statusDiv.style.marginBottom = '8px';
                        statusDiv.style.display = 'flex';
                        statusDiv.style.alignItems = 'center';
                        statusDiv.style.gap = '3px';
                        
                        // Add emoji from processesHealthStatus if available
                        if (item.processesHealthStatus.status) {
                            const statusEmoji = getStatusEmoji(item.processesHealthStatus.status);
                            if (statusEmoji) {
                                const tooltipWrapper = document.createElement('span');
                                tooltipWrapper.className = 'emoji-tooltip-wrapper';
                                tooltipWrapper.style.marginRight = '0';
                                
                                const emojiSpan = document.createElement('span');
                                emojiSpan.textContent = statusEmoji;
                                emojiSpan.style.cursor = 'help';
                                tooltipWrapper.appendChild(emojiSpan);
                                
                                if (item.processesHealthStatus.message) {
                                    const tooltipDiv = document.createElement('div');
                                    tooltipDiv.className = 'emoji-tooltip';
                                    tooltipDiv.textContent = item.processesHealthStatus.message;
                                    tooltipWrapper.appendChild(tooltipDiv);
                                }
                                
                                statusDiv.appendChild(tooltipWrapper);
                                statusDiv.appendChild(document.createTextNode(' '));
                            }
                        }
                        
                        // Add text
                        statusDiv.appendChild(document.createTextNode('instrumented processes health'));
                        
                        processesHealthSection.appendChild(statusDiv);
                        
                        // Message field
                        if (item.processesHealthStatus.message) {
                            const messageDiv = document.createElement('div');
                            messageDiv.style.fontSize = '13px';
                            messageDiv.style.color = '#666';
                            messageDiv.style.marginBottom = '8px';
                            messageDiv.style.display = 'flex';
                            messageDiv.style.alignItems = 'center';
                            messageDiv.style.gap = '6px';
                            
                            const messageLabel = document.createElement('strong');
                            messageLabel.style.fontWeight = '600';
                            messageLabel.style.color = '#333';
                            messageLabel.textContent = 'message:';
                            messageDiv.appendChild(messageLabel);
                            messageDiv.appendChild(document.createTextNode(' ' + item.processesHealthStatus.message));
                            
                            processesHealthSection.appendChild(messageDiv);
                        }
                        
                        // ReasonEnum field
                        if (item.processesHealthStatus.reasonEnum) {
                            const reasonDiv = document.createElement('div');
                            reasonDiv.style.fontSize = '13px';
                            reasonDiv.style.color = '#666';
                            reasonDiv.style.display = 'flex';
                            reasonDiv.style.alignItems = 'center';
                            reasonDiv.style.gap = '6px';
                            
                            const reasonLabel = document.createElement('strong');
                            reasonLabel.style.fontWeight = '600';
                            reasonLabel.style.color = '#333';
                            reasonLabel.textContent = 'reasonEnum:';
                            reasonDiv.appendChild(reasonLabel);
                            reasonDiv.appendChild(document.createTextNode(' ' + item.processesHealthStatus.reasonEnum));
                            
                            processesHealthSection.appendChild(reasonDiv);
                        }
                        
                        instrumentationContent.appendChild(processesHealthSection);
                    }
                    
                    contentDiv.appendChild(instrumentationContent);
                    
                    // K8s commands tab
                    const k8sContent = document.createElement('div');
                    k8sContent.id = `k8s-content-${idx}`;
                    k8sContent.className = 'tab-content';
                    const k8sCommandsDiv = document.createElement('div');
                    k8sCommandsDiv.className = 'k8s-commands';
                    
                    const commands = generateK8sCommands(item);
                    commands.forEach(cmd => {
                        const section = document.createElement('div');
                        section.className = 'k8s-command-section';
                        
                        const title = document.createElement('div');
                        title.className = 'k8s-command-title';
                        title.textContent = cmd.title;
                        section.appendChild(title);
                        
                        const commandBlock = document.createElement('div');
                        commandBlock.className = 'k8s-command-block';
                        
                        const copyBtn = document.createElement('button');
                        copyBtn.className = 'k8s-copy-btn';
                        copyBtn.textContent = 'Copy';
                        copyBtn.onclick = () => copyToClipboard(cmd.command);
                        commandBlock.appendChild(copyBtn);
                        
                        const commandText = document.createElement('div');
                        commandText.className = 'k8s-command-text';
                        commandText.textContent = cmd.command;
                        commandBlock.appendChild(commandText);
                        
                        section.appendChild(commandBlock);
                        k8sCommandsDiv.appendChild(section);
                    });
                    
                    k8sContent.appendChild(k8sCommandsDiv);
                    contentDiv.appendChild(k8sContent);
                    
                    // Containers tab
                    const containersContent = document.createElement('div');
                    containersContent.id = `containers-content-${idx}`;
                    containersContent.className = 'tab-content';
                    
                    // Add description text
                    const containersDescription = document.createElement('div');
                    containersDescription.style.fontSize = '12px';
                    containersDescription.style.color = '#666';
                    containersDescription.style.marginBottom = '15px';
                    containersDescription.style.padding = '10px';
                    containersDescription.style.background = 'linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%)';
                    containersDescription.style.borderRadius = '4px';
                    containersDescription.style.lineHeight = '1.5';
                    const workloadKind = (item && item.id && item.id.kind) ? item.id.kind.toLowerCase() : 'workload';
                    containersDescription.innerHTML = 'Shows runtime detection and instrumentation decisions for each container in this ' + workloadKind + '. ' +
                        '<strong>These settings apply to future pods</strong> that will be created by this ' + workloadKind + '. ' +
                        '<span style="font-style: italic;">Note: Existing pods may show different statuses based on their current state.</span>';
                    containersContent.appendChild(containersDescription);
                    
                    if (item && item.containers && Array.isArray(item.containers) && item.containers.length > 0) {
                        item.containers.forEach((container, containerIdx) => {
                            const containerWrapper = document.createElement('div');
                            containerWrapper.style.marginBottom = '15px';
                            containerWrapper.style.padding = '10px';
                            containerWrapper.style.border = '1px solid #e0e0e0';
                            containerWrapper.style.borderRadius = '4px';
                            
                            const containerName = container.containerName || `Container ${containerIdx}`;
                            const containerHeader = document.createElement('div');
                            containerHeader.style.fontWeight = '600';
                            containerHeader.style.fontSize = '16px';
                            containerHeader.style.marginBottom = '10px';
                            containerHeader.style.color = '#333';
                            containerHeader.style.display = 'flex';
                            containerHeader.style.alignItems = 'center';
                            containerHeader.style.gap = '8px';
                            
                            // Get status emoji from agentEnabledStatus
                            let statusEmoji = null;
                            let statusMessage = null;
                            if (container.agentEnabled && container.agentEnabled.agentEnabledStatus) {
                                const agentStatus = container.agentEnabled.agentEnabledStatus;
                                if (agentStatus.status && typeof agentStatus.status === 'string') {
                                    statusEmoji = getStatusEmoji(agentStatus.status);
                                    statusMessage = agentStatus.message || '';
                                }
                            }
                            
                            // Add emoji with tooltip if available
                            if (statusEmoji) {
                                const tooltipWrapper = document.createElement('span');
                                tooltipWrapper.className = 'emoji-tooltip-wrapper';
                                
                                const emojiSpan = document.createElement('span');
                                emojiSpan.textContent = statusEmoji + ' ';
                                emojiSpan.style.cursor = 'help';
                                tooltipWrapper.appendChild(emojiSpan);
                                
                                const tooltipDiv = document.createElement('div');
                                tooltipDiv.className = 'emoji-tooltip';
                                tooltipDiv.textContent = statusMessage || '';
                                tooltipWrapper.appendChild(tooltipDiv);
                                
                                containerHeader.appendChild(tooltipWrapper);
                            }
                            
                            const nameSpan = document.createElement('span');
                            let headerText = containerName;
                            
                            // Add runtime information - check overrides first, then top-level runtimeInfo
                            let runtimeInfo = null;
                            let isOverride = false;
                            
                            // Check if there's an override with runtimeInfo for this container
                            if (container.overrides && container.overrides.runtimeInfo) {
                                runtimeInfo = container.overrides.runtimeInfo;
                                isOverride = true;
                            }
                            
                            // If no override found, use top-level runtimeInfo
                            if (!runtimeInfo && container.runtimeInfo) {
                                runtimeInfo = container.runtimeInfo;
                            }
                            
                            if (runtimeInfo) {
                                const runtimeParts = [];
                                if (runtimeInfo.language) {
                                    runtimeParts.push(runtimeInfo.language);
                                }
                                if (runtimeInfo.runtimeVersion) {
                                    runtimeParts.push(runtimeInfo.runtimeVersion);
                                }
                                if (runtimeParts.length > 0) {
                                    const suffix = isOverride ? ' - automatic detection overwritten' : ' - automatic detection';
                                    headerText += ' (' + runtimeParts.join(' ') + suffix + ')';
                                }
                            }
                            
                            nameSpan.textContent = headerText;
                            containerHeader.appendChild(nameSpan);
                            
                            // Add otelDistroName or "uninstrumented"
                            const distroSpan = document.createElement('span');
                            distroSpan.style.marginLeft = '6px';
                            distroSpan.style.color = '#666';
                            distroSpan.style.fontSize = '12px';
                            const otelDistroName = container.agentEnabled && container.agentEnabled.otelDistroName;
                            if (otelDistroName) {
                                distroSpan.textContent = '[' + otelDistroName + ']';
                            } else {
                                distroSpan.textContent = '[uninstrumented]';
                            }
                            containerHeader.appendChild(distroSpan);
                            
                            // Add signal emojis (traces, metrics, logs)
                            if (container.agentEnabled) {
                                const signals = [
                                    { name: 'traces', emoji: '👣', label: 'Traces' },
                                    { name: 'metrics', emoji: '📈', label: 'Metrics' },
                                    { name: 'logs', emoji: '🪵', label: 'Logs' }
                                ];
                                
                                signals.forEach(signal => {
                                    const signalData = container.agentEnabled[signal.name];
                                    if (signalData && signalData !== null && signalData.enabled !== false) {
                                        const tooltipWrapper = document.createElement('span');
                                        tooltipWrapper.className = 'emoji-tooltip-wrapper';
                                        
                                        const emojiSpan = document.createElement('span');
                                        emojiSpan.textContent = signal.emoji + ' ';
                                        emojiSpan.style.cursor = 'help';
                                        tooltipWrapper.appendChild(emojiSpan);
                                        
                                        const tooltipDiv = document.createElement('div');
                                        tooltipDiv.className = 'emoji-tooltip';
                                        tooltipDiv.textContent = signal.label + ' enabled';
                                        tooltipWrapper.appendChild(tooltipDiv);
                                        
                                        containerHeader.appendChild(tooltipWrapper);
                                    }
                                });
                            }
                            
                            containerWrapper.appendChild(containerHeader);
                            
                            Object.keys(container).forEach(k => {
                                renderJSON(container[k], containerWrapper, k);
                            });
                            
                            containersContent.appendChild(containerWrapper);
                        });
                    } else {
                        const noContainers = document.createElement('div');
                        noContainers.textContent = 'No containers found';
                        noContainers.style.padding = '15px';
                        noContainers.style.color = '#666';
                        containersContent.appendChild(noContainers);
                    }
                    
                    contentDiv.appendChild(containersContent);
                    
                    // Pods tab
                    const podsContent = document.createElement('div');
                    podsContent.id = `pods-content-${idx}`;
                    podsContent.className = 'tab-content';
                    
                    // Pods summary statuses section
                    const podsSummarySection = document.createElement('div');
                    podsSummarySection.style.marginBottom = '15px';
                    podsSummarySection.style.padding = '10px';
                    podsSummarySection.style.background = 'linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%)';
                    podsSummarySection.style.borderRadius = '4px';
                    
                    // Odigos status (podsAgentInjectionStatus)
                    if (item && item.podsAgentInjectionStatus && item.podsAgentInjectionStatus.status) {
                        const odigosStatusDiv = document.createElement('div');
                        odigosStatusDiv.style.marginBottom = '8px';
                        
                        const odigosFirstLine = document.createElement('div');
                        odigosFirstLine.style.display = 'flex';
                        odigosFirstLine.style.alignItems = 'center';
                        odigosFirstLine.style.gap = '8px';
                        
                        const odigosStatusEmoji = getStatusEmoji(item.podsAgentInjectionStatus.status);
                        if (odigosStatusEmoji) {
                            const odigosTooltipWrapper = document.createElement('span');
                            odigosTooltipWrapper.className = 'emoji-tooltip-wrapper';
                            odigosTooltipWrapper.style.marginRight = '0';
                            
                            const odigosEmojiSpan = document.createElement('span');
                            odigosEmojiSpan.textContent = odigosStatusEmoji + ' ';
                            odigosEmojiSpan.style.cursor = 'help';
                            odigosTooltipWrapper.appendChild(odigosEmojiSpan);
                            
                            if (item.podsAgentInjectionStatus.message) {
                                const odigosTooltipDiv = document.createElement('div');
                                odigosTooltipDiv.className = 'emoji-tooltip';
                                odigosTooltipDiv.textContent = item.podsAgentInjectionStatus.message;
                                odigosTooltipWrapper.appendChild(odigosTooltipDiv);
                            }
                            
                            odigosFirstLine.appendChild(odigosTooltipWrapper);
                        }
                        
                        const odigosLabel = document.createElement('span');
                        odigosLabel.style.fontWeight = '600';
                        odigosLabel.style.fontSize = '14px';
                        odigosLabel.style.color = '#333';
                        odigosLabel.textContent = 'odigos:';
                        odigosFirstLine.appendChild(odigosLabel);
                        
                        if (item.podsAgentInjectionStatus.message) {
                            const odigosMessage = document.createElement('span');
                            odigosMessage.style.fontSize = '14px';
                            odigosMessage.style.color = '#666';
                            odigosMessage.textContent = ' ' + item.podsAgentInjectionStatus.message;
                            odigosFirstLine.appendChild(odigosMessage);
                        }
                        
                        odigosStatusDiv.appendChild(odigosFirstLine);
                        
                        if (item.podsAgentInjectionStatus.reasonEnum) {
                            const odigosReason = document.createElement('div');
                            odigosReason.style.fontSize = '12px';
                            odigosReason.style.color = '#666';
                            odigosReason.style.marginLeft = '24px';
                            odigosReason.style.marginTop = '4px';
                            const reasonLabel = document.createElement('strong');
                            reasonLabel.style.fontWeight = '600';
                            reasonLabel.style.color = '#333';
                            reasonLabel.textContent = 'reasonEnum:';
                            odigosReason.appendChild(reasonLabel);
                            odigosReason.appendChild(document.createTextNode(' ' + item.podsAgentInjectionStatus.reasonEnum));
                            odigosStatusDiv.appendChild(odigosReason);
                        }
                        
                        podsSummarySection.appendChild(odigosStatusDiv);
                    }
                    
                    // Application health status (podsHealthStatus)
                    if (item && item.podsHealthStatus && item.podsHealthStatus.status) {
                        const healthStatusDiv = document.createElement('div');
                        
                        const healthFirstLine = document.createElement('div');
                        healthFirstLine.style.display = 'flex';
                        healthFirstLine.style.alignItems = 'center';
                        healthFirstLine.style.gap = '8px';
                        
                        const healthStatusEmoji = getStatusEmoji(item.podsHealthStatus.status);
                        if (healthStatusEmoji) {
                            const healthTooltipWrapper = document.createElement('span');
                            healthTooltipWrapper.className = 'emoji-tooltip-wrapper';
                            healthTooltipWrapper.style.marginRight = '0';
                            
                            const healthEmojiSpan = document.createElement('span');
                            healthEmojiSpan.textContent = healthStatusEmoji + ' ';
                            healthEmojiSpan.style.cursor = 'help';
                            healthTooltipWrapper.appendChild(healthEmojiSpan);
                            
                            if (item.podsHealthStatus.message) {
                                const healthTooltipDiv = document.createElement('div');
                                healthTooltipDiv.className = 'emoji-tooltip';
                                healthTooltipDiv.textContent = item.podsHealthStatus.message;
                                healthTooltipWrapper.appendChild(healthTooltipDiv);
                            }
                            
                            healthFirstLine.appendChild(healthTooltipWrapper);
                        }
                        
                        const healthLabel = document.createElement('span');
                        healthLabel.style.fontWeight = '600';
                        healthLabel.style.fontSize = '14px';
                        healthLabel.style.color = '#333';
                        healthLabel.textContent = 'application:';
                        healthFirstLine.appendChild(healthLabel);
                        
                        if (item.podsHealthStatus.message) {
                            const healthMessage = document.createElement('span');
                            healthMessage.style.fontSize = '14px';
                            healthMessage.style.color = '#666';
                            healthMessage.textContent = ' ' + item.podsHealthStatus.message;
                            healthFirstLine.appendChild(healthMessage);
                        }
                        
                        healthStatusDiv.appendChild(healthFirstLine);
                        
                        if (item.podsHealthStatus.reasonEnum) {
                            const healthReason = document.createElement('div');
                            healthReason.style.fontSize = '12px';
                            healthReason.style.color = '#666';
                            healthReason.style.marginLeft = '24px';
                            healthReason.style.marginTop = '4px';
                            const reasonLabel = document.createElement('strong');
                            reasonLabel.style.fontWeight = '600';
                            reasonLabel.style.color = '#333';
                            reasonLabel.textContent = 'reasonEnum:';
                            healthReason.appendChild(reasonLabel);
                            healthReason.appendChild(document.createTextNode(' ' + item.podsHealthStatus.reasonEnum));
                            healthStatusDiv.appendChild(healthReason);
                        }
                        
                        podsSummarySection.appendChild(healthStatusDiv);
                    }
                    
                    if (podsSummarySection.children.length > 0) {
                        podsContent.appendChild(podsSummarySection);
                    }
                    
                    if (item && item.pods && Array.isArray(item.pods) && item.pods.length > 0) {
                        item.pods.forEach((pod, podIdx) => {
                            const podWrapper = document.createElement('div');
                            podWrapper.style.marginBottom = '15px';
                            podWrapper.style.padding = '10px';
                            podWrapper.style.border = '1px solid #e0e0e0';
                            podWrapper.style.borderRadius = '4px';
                            
                            const podName = pod.podName || `Pod ${podIdx}`;
                            
                            // Create collapsible header
                            const podHeader = document.createElement('div');
                            podHeader.style.fontWeight = '600';
                            podHeader.style.fontSize = '16px';
                            podHeader.style.marginBottom = '4px';
                            podHeader.style.color = '#333';
                            podHeader.style.display = 'flex';
                            podHeader.style.alignItems = 'center';
                            podHeader.style.gap = '6px';
                            podHeader.style.cursor = 'pointer';
                            podHeader.classList.add('expandable');
                            
                            // Toggle arrow
                            const toggle = document.createElement('span');
                            toggle.className = 'toggle';
                            toggle.textContent = '';
                            podHeader.appendChild(toggle);
                            
                            // Get status emoji from agentInjectedStatus (odigos status)
                            let statusEmoji = null;
                            let statusMessage = null;
                            if (pod.agentInjectedStatus && pod.agentInjectedStatus.status) {
                                statusEmoji = getStatusEmoji(pod.agentInjectedStatus.status);
                                statusMessage = pod.agentInjectedStatus.message || '';
                            }
                            
                            // Add odigos emoji with tooltip if available
                            if (statusEmoji) {
                                const odigosContainer = document.createElement('span');
                                odigosContainer.style.display = 'flex';
                                odigosContainer.style.flexDirection = 'column';
                                odigosContainer.style.alignItems = 'center';
                                odigosContainer.style.gap = '1px';
                                
                                const tooltipWrapper = document.createElement('span');
                                tooltipWrapper.className = 'emoji-tooltip-wrapper';
                                tooltipWrapper.style.display = 'inline-block';
                                tooltipWrapper.style.marginRight = '0';
                                
                                const emojiSpan = document.createElement('span');
                                emojiSpan.textContent = statusEmoji;
                                emojiSpan.style.cursor = 'help';
                                tooltipWrapper.appendChild(emojiSpan);
                                
                                const tooltipDiv = document.createElement('div');
                                tooltipDiv.className = 'emoji-tooltip';
                                tooltipDiv.textContent = statusMessage || '';
                                tooltipWrapper.appendChild(tooltipDiv);
                                
                                odigosContainer.appendChild(tooltipWrapper);
                                
                                const odigosLabel = document.createElement('span');
                                odigosLabel.textContent = 'odigos';
                                odigosLabel.style.fontSize = '9px';
                                odigosLabel.style.color = '#666';
                                odigosLabel.style.lineHeight = '1';
                                odigosContainer.appendChild(odigosLabel);
                                
                                podHeader.appendChild(odigosContainer);
                            }
                            
                            // Get application health status emoji from podHealthStatus
                            let appStatusEmoji = null;
                            let appStatusMessage = null;
                            if (pod.podHealthStatus && pod.podHealthStatus.status) {
                                appStatusEmoji = getStatusEmoji(pod.podHealthStatus.status);
                                appStatusMessage = pod.podHealthStatus.message || '';
                            }
                            
                            // Add application health emoji with tooltip if available
                            if (appStatusEmoji) {
                                const appContainer = document.createElement('span');
                                appContainer.style.display = 'flex';
                                appContainer.style.flexDirection = 'column';
                                appContainer.style.alignItems = 'center';
                                appContainer.style.gap = '1px';
                                
                                const appTooltipWrapper = document.createElement('span');
                                appTooltipWrapper.className = 'emoji-tooltip-wrapper';
                                appTooltipWrapper.style.display = 'inline-block';
                                appTooltipWrapper.style.marginRight = '0';
                                
                                const appEmojiSpan = document.createElement('span');
                                appEmojiSpan.textContent = appStatusEmoji;
                                appEmojiSpan.style.cursor = 'help';
                                appTooltipWrapper.appendChild(appEmojiSpan);
                                
                                const appTooltipDiv = document.createElement('div');
                                appTooltipDiv.className = 'emoji-tooltip';
                                appTooltipDiv.textContent = appStatusMessage || '';
                                appTooltipWrapper.appendChild(appTooltipDiv);
                                
                                appContainer.appendChild(appTooltipWrapper);
                                
                                const appLabel = document.createElement('span');
                                appLabel.textContent = 'application';
                                appLabel.style.fontSize = '9px';
                                appLabel.style.color = '#666';
                                appLabel.style.lineHeight = '1';
                                appContainer.appendChild(appLabel);
                                
                                podHeader.appendChild(appContainer);
                            }
                            
                            const nameSpan = document.createElement('span');
                            nameSpan.textContent = podName;
                            podHeader.appendChild(nameSpan);
                            
                            // Add "need restart" label if startedPostAgentMetaHashChange is false
                            if (pod.startedPostAgentMetaHashChange === false) {
                                const restartLabelWrapper = document.createElement('span');
                                restartLabelWrapper.className = 'emoji-tooltip-wrapper';
                                restartLabelWrapper.style.marginLeft = '6px';
                                
                                const restartLabel = document.createElement('span');
                                restartLabel.textContent = 'need restart';
                                restartLabel.style.fontSize = '11px';
                                restartLabel.style.fontWeight = '500';
                                restartLabel.style.color = '#d97706';
                                restartLabel.style.backgroundColor = '#fffbeb';
                                restartLabel.style.padding = '2px 6px';
                                restartLabel.style.borderRadius = '4px';
                                restartLabel.style.border = '1px solid #fde68a';
                                restartLabel.style.cursor = 'help';
                                restartLabelWrapper.appendChild(restartLabel);
                                
                                const restartTooltip = document.createElement('div');
                                restartTooltip.className = 'emoji-tooltip';
                                restartTooltip.textContent = 'This pod was created before recent instrumentation configuration changes. Changes will be applied automatically during rollout, or restart the workload manually to apply them immediately.';
                                restartLabelWrapper.appendChild(restartTooltip);
                                
                                podHeader.appendChild(restartLabelWrapper);
                            }
                            
                            const copyBtn = document.createElement('button');
                            copyBtn.className = 'k8s-copy-btn';
                            copyBtn.textContent = 'Copy';
                            copyBtn.style.fontSize = '11px';
                            copyBtn.style.padding = '4px 8px';
                            copyBtn.onclick = (e) => {
                                e.stopPropagation();
                                copyToClipboard(podName);
                            };
                            podHeader.appendChild(copyBtn);
                            
                            podWrapper.appendChild(podHeader);
                            
                            // Create collapsible content
                            const podContent = document.createElement('div');
                            podContent.className = 'children';
                            podContent.style.display = 'none';
                            
                            // Add warning banner if startedPostAgentMetaHashChange is false
                            if (pod.startedPostAgentMetaHashChange === false) {
                                const warningBanner = document.createElement('div');
                                warningBanner.style.marginBottom = '15px';
                                warningBanner.style.padding = '12px 16px';
                                warningBanner.style.backgroundColor = '#fffbeb';
                                warningBanner.style.border = '1px solid #fde68a';
                                warningBanner.style.borderRadius = '4px';
                                warningBanner.style.display = 'flex';
                                warningBanner.style.alignItems = 'flex-start';
                                warningBanner.style.gap = '10px';
                                
                                const warningIcon = document.createElement('span');
                                warningIcon.textContent = '⚠️';
                                warningIcon.style.fontSize = '18px';
                                warningIcon.style.lineHeight = '1.4';
                                warningBanner.appendChild(warningIcon);
                                
                                const warningText = document.createElement('div');
                                warningText.style.flex = '1';
                                warningText.style.fontSize = '14px';
                                warningText.style.color = '#92400e';
                                warningText.style.lineHeight = '1.5';
                                const warningTitle = document.createElement('div');
                                warningTitle.textContent = 'Pod needs restart';
                                warningTitle.style.fontWeight = '600';
                                warningTitle.style.marginBottom = '4px';
                                warningText.appendChild(warningTitle);
                                const warningMessage = document.createElement('div');
                                warningMessage.textContent = 'This pod was created before recent instrumentation configuration changes. Changes will be applied automatically during rollout, or restart the workload manually to apply them immediately.';
                                warningMessage.style.fontSize = '13px';
                                warningMessage.style.color = '#78350f';
                                warningText.appendChild(warningMessage);
                                warningBanner.appendChild(warningText);
                                
                                podContent.appendChild(warningBanner);
                            }
                            
                            // Create info section
                            const infoSection = document.createElement('div');
                            infoSection.style.marginBottom = '15px';
                            infoSection.style.padding = '10px';
                            infoSection.style.background = 'linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%)';
                            infoSection.style.borderRadius = '4px';
                            
                            // Node name
                            if (pod.nodeName) {
                                const nodeDiv = document.createElement('div');
                                nodeDiv.style.fontSize = '14px';
                                nodeDiv.style.color = '#666';
                                nodeDiv.style.marginBottom = '4px';
                                nodeDiv.style.display = 'flex';
                                nodeDiv.style.alignItems = 'center';
                                nodeDiv.style.gap = '8px';
                                
                                const nodeLabel = document.createElement('span');
                                nodeLabel.textContent = `Node Name: ${pod.nodeName}`;
                                nodeDiv.appendChild(nodeLabel);
                                
                                const copyBtn = document.createElement('button');
                                copyBtn.className = 'k8s-copy-btn';
                                copyBtn.textContent = 'Copy';
                                copyBtn.style.fontSize = '11px';
                                copyBtn.style.padding = '4px 8px';
                                copyBtn.onclick = () => copyToClipboard(pod.nodeName);
                                nodeDiv.appendChild(copyBtn);
                                
                                infoSection.appendChild(nodeDiv);
                            }
                            
                            // Start time with age
                            if (pod.startTime) {
                                const startTimeDiv = document.createElement('div');
                                startTimeDiv.style.fontSize = '14px';
                                startTimeDiv.style.color = '#666';
                                
                                const startTimeDate = new Date(pod.startTime);
                                const startTimeSpan = document.createElement('span');
                                startTimeSpan.textContent = `Started: ${startTimeDate.toLocaleString()}`;
                                startTimeDiv.appendChild(startTimeSpan);
                                
                                const ageSpan = document.createElement('span');
                                ageSpan.id = `pod-age-${idx}-${podIdx}`;
                                ageSpan.style.marginLeft = '8px';
                                ageSpan.style.color = '#666';
                                
                                const updatePodAge = () => {
                                    const now = new Date();
                                    const seconds = Math.floor((now - startTimeDate) / 1000);
                                    const ageText = formatDuration(seconds);
                                    ageSpan.textContent = `(${ageText} ago)`;
                                };
                                
                                updatePodAge();
                                setInterval(updatePodAge, 1000);
                                
                                startTimeDiv.appendChild(ageSpan);
                                infoSection.appendChild(startTimeDiv);
                            }
                            
                            podContent.appendChild(infoSection);
                            
                            // Odigos section
                            if (pod.agentInjectedStatus) {
                                const odigosSection = document.createElement('div');
                                odigosSection.style.marginBottom = '15px';
                                odigosSection.style.padding = '10px';
                                odigosSection.style.background = 'linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%)';
                                odigosSection.style.borderRadius = '4px';
                                
                                const odigosHeader = document.createElement('div');
                                odigosHeader.style.display = 'flex';
                                odigosHeader.style.alignItems = 'center';
                                odigosHeader.style.gap = '8px';
                                odigosHeader.style.marginBottom = '8px';
                                
                                // Add emoji based on status
                                if (pod.agentInjectedStatus.status) {
                                    const statusEmoji = getStatusEmoji(pod.agentInjectedStatus.status);
                                    if (statusEmoji) {
                                        const tooltipWrapper = document.createElement('span');
                                        tooltipWrapper.className = 'emoji-tooltip-wrapper';
                                        
                                        const emojiSpan = document.createElement('span');
                                        emojiSpan.textContent = statusEmoji + ' ';
                                        emojiSpan.style.cursor = 'help';
                                        emojiSpan.style.fontSize = '16px';
                                        tooltipWrapper.appendChild(emojiSpan);
                                        
                                        const tooltipDiv = document.createElement('div');
                                        tooltipDiv.className = 'emoji-tooltip';
                                        tooltipDiv.textContent = pod.agentInjectedStatus.message || '';
                                        tooltipWrapper.appendChild(tooltipDiv);
                                        
                                        odigosHeader.appendChild(tooltipWrapper);
                                    }
                                }
                                
                                const odigosTitle = document.createElement('span');
                                odigosTitle.style.fontWeight = '600';
                                odigosTitle.style.fontSize = '14px';
                                odigosTitle.style.color = '#333';
                                odigosTitle.textContent = 'odigos';
                                odigosHeader.appendChild(odigosTitle);
                                
                                odigosSection.appendChild(odigosHeader);
                                
                                // Agent Injected subsection
                                const agentInjectedSubsection = document.createElement('div');
                                agentInjectedSubsection.style.marginTop = '12px';
                                
                                const agentInjectedHeader = document.createElement('div');
                                agentInjectedHeader.style.fontSize = '13px';
                                agentInjectedHeader.style.fontWeight = '600';
                                agentInjectedHeader.style.color = '#333';
                                agentInjectedHeader.style.marginBottom = '6px';
                                agentInjectedHeader.textContent = 'Agent Injected:';
                                agentInjectedSubsection.appendChild(agentInjectedHeader);
                                
                                // Add agentInjected
                                const agentInjectedDiv = document.createElement('div');
                                agentInjectedDiv.style.fontSize = '13px';
                                agentInjectedDiv.style.color = '#666';
                                agentInjectedDiv.style.marginTop = '4px';
                                agentInjectedDiv.style.display = 'flex';
                                agentInjectedDiv.style.alignItems = 'center';
                                agentInjectedDiv.style.gap = '6px';
                                
                                const agentInjectedLabel = document.createElement('strong');
                                agentInjectedLabel.style.fontWeight = '600';
                                agentInjectedLabel.style.color = '#333';
                                agentInjectedLabel.textContent = 'agentInjected:';
                                agentInjectedDiv.appendChild(agentInjectedLabel);
                                agentInjectedDiv.appendChild(document.createTextNode(' ' + (pod.agentInjected === true ? 'true' : 'false')));
                                agentInjectedSubsection.appendChild(agentInjectedDiv);
                                
                                // Add agentInjectedStatus status
                                if (pod.agentInjectedStatus && pod.agentInjectedStatus.status) {
                                    const statusDiv = document.createElement('div');
                                    statusDiv.style.fontSize = '13px';
                                    statusDiv.style.color = '#666';
                                    statusDiv.style.marginTop = '4px';
                                    statusDiv.style.display = 'flex';
                                    statusDiv.style.alignItems = 'center';
                                    statusDiv.style.gap = '6px';
                                    
                                    const statusLabel = document.createElement('strong');
                                    statusLabel.style.fontWeight = '600';
                                    statusLabel.style.color = '#333';
                                    statusLabel.textContent = 'status:';
                                    statusDiv.appendChild(statusLabel);
                                    statusDiv.appendChild(document.createTextNode(' ' + pod.agentInjectedStatus.status));
                                    agentInjectedSubsection.appendChild(statusDiv);
                                }
                                
                                // Add agentInjectedStatus reasonEnum
                                if (pod.agentInjectedStatus && pod.agentInjectedStatus.reasonEnum) {
                                    const reasonDiv = document.createElement('div');
                                    reasonDiv.style.fontSize = '13px';
                                    reasonDiv.style.color = '#666';
                                    reasonDiv.style.marginTop = '4px';
                                    reasonDiv.style.display = 'flex';
                                    reasonDiv.style.alignItems = 'center';
                                    reasonDiv.style.gap = '6px';
                                    
                                    const reasonLabel = document.createElement('strong');
                                    reasonLabel.style.fontWeight = '600';
                                    reasonLabel.style.color = '#333';
                                    reasonLabel.textContent = 'reasonEnum:';
                                    reasonDiv.appendChild(reasonLabel);
                                    reasonDiv.appendChild(document.createTextNode(' ' + pod.agentInjectedStatus.reasonEnum));
                                    agentInjectedSubsection.appendChild(reasonDiv);
                                }
                                
                                // Add agentInjectedStatus message
                                if (pod.agentInjectedStatus && pod.agentInjectedStatus.message) {
                                    const messageDiv = document.createElement('div');
                                    messageDiv.style.fontSize = '13px';
                                    messageDiv.style.color = '#666';
                                    messageDiv.style.marginTop = '4px';
                                    messageDiv.textContent = pod.agentInjectedStatus.message;
                                    agentInjectedSubsection.appendChild(messageDiv);
                                }
                                
                                odigosSection.appendChild(agentInjectedSubsection);
                                
                                // Containers subsection
                                if (pod.containers && Array.isArray(pod.containers) && pod.containers.length > 0) {
                                    const containersSubsection = document.createElement('div');
                                    containersSubsection.style.marginTop = '12px';
                                    
                                    const containersHeader = document.createElement('div');
                                    containersHeader.style.fontSize = '13px';
                                    containersHeader.style.fontWeight = '600';
                                    containersHeader.style.color = '#333';
                                    containersHeader.style.marginBottom = '6px';
                                    containersHeader.textContent = 'Containers:';
                                    containersSubsection.appendChild(containersHeader);
                                    
                                    pod.containers.forEach((container) => {
                                        if (container.containerName) {
                                            const containerWrapper = document.createElement('div');
                                            containerWrapper.style.marginBottom = '8px';
                                            containerWrapper.style.marginLeft = '12px';
                                            
                                            // Container name
                                            const containerNameDiv = document.createElement('div');
                                            containerNameDiv.style.fontSize = '13px';
                                            containerNameDiv.style.fontWeight = '600';
                                            containerNameDiv.style.color = '#333';
                                            containerNameDiv.style.marginBottom = '4px';
                                            
                                            let containerNameText = container.containerName;
                                            if (!container.otelDistroName) {
                                                containerNameText += ' (not instrumented)';
                                            }
                                            containerNameDiv.textContent = containerNameText;
                                            containerWrapper.appendChild(containerNameDiv);
                                            
                                            // otelDistroName row
                                            if (container.otelDistroName) {
                                                const distroDiv = document.createElement('div');
                                                distroDiv.style.fontSize = '12px';
                                                distroDiv.style.color = '#666';
                                                distroDiv.style.marginLeft = '8px';
                                                distroDiv.style.marginBottom = '2px';
                                                distroDiv.style.display = 'flex';
                                                distroDiv.style.alignItems = 'center';
                                                distroDiv.style.gap = '6px';
                                                
                                                const distroLabel = document.createElement('strong');
                                                distroLabel.style.fontWeight = '600';
                                                distroLabel.style.color = '#333';
                                                distroLabel.textContent = 'otelDistroName:';
                                                distroDiv.appendChild(distroLabel);
                                                distroDiv.appendChild(document.createTextNode(' ' + container.otelDistroName));
                                                
                                                containerWrapper.appendChild(distroDiv);
                                            }
                                            
                                            // odigosInstrumentationDeviceName row
                                            if (container.odigosInstrumentationDeviceName) {
                                                const deviceDiv = document.createElement('div');
                                                deviceDiv.style.fontSize = '12px';
                                                deviceDiv.style.color = '#666';
                                                deviceDiv.style.marginLeft = '8px';
                                                deviceDiv.style.display = 'flex';
                                                deviceDiv.style.alignItems = 'center';
                                                deviceDiv.style.gap = '6px';
                                                
                                                const deviceLabel = document.createElement('strong');
                                                deviceLabel.style.fontWeight = '600';
                                                deviceLabel.style.color = '#333';
                                                deviceLabel.textContent = 'odigosInstrumentationDeviceName:';
                                                deviceDiv.appendChild(deviceLabel);
                                                deviceDiv.appendChild(document.createTextNode(' ' + container.odigosInstrumentationDeviceName));
                                                
                                                containerWrapper.appendChild(deviceDiv);
                                            }
                                            
                                            // Instrumented processes subsection
                                            if (container.processes && Array.isArray(container.processes) && container.processes.length > 0) {
                                                const processesSubsection = document.createElement('div');
                                                processesSubsection.style.marginTop = '8px';
                                                processesSubsection.style.marginLeft = '8px';
                                                
                                                const processesHeader = document.createElement('div');
                                                processesHeader.style.fontSize = '12px';
                                                processesHeader.style.fontWeight = '600';
                                                processesHeader.style.color = '#333';
                                                processesHeader.style.marginBottom = '4px';
                                                processesHeader.textContent = `instrumented processes (${container.processes.length}):`;
                                                processesSubsection.appendChild(processesHeader);
                                                
                                                container.processes.forEach((process, processIdx) => {
                                                    const processWrapper = document.createElement('div');
                                                    processWrapper.style.marginLeft = '12px';
                                                    processWrapper.style.marginBottom = '8px';
                                                    
                                                    // Process header with emoji
                                                    const processHeader = document.createElement('div');
                                                    processHeader.style.fontSize = '11px';
                                                    processHeader.style.color = '#666';
                                                    processHeader.style.display = 'flex';
                                                    processHeader.style.alignItems = 'center';
                                                    processHeader.style.gap = '4px';
                                                    
                                                    // Add emoji based on healthStatus
                                                    if (process.healthStatus && process.healthStatus.status) {
                                                        const statusEmoji = getStatusEmoji(process.healthStatus.status);
                                                        if (statusEmoji) {
                                                            const tooltipWrapper = document.createElement('span');
                                                            tooltipWrapper.className = 'emoji-tooltip-wrapper';
                                                            
                                                            const emojiSpan = document.createElement('span');
                                                            emojiSpan.textContent = statusEmoji + ' ';
                                                            emojiSpan.style.cursor = 'help';
                                                            tooltipWrapper.appendChild(emojiSpan);
                                                            
                                                            if (process.healthStatus.message) {
                                                                const tooltipDiv = document.createElement('div');
                                                                tooltipDiv.className = 'emoji-tooltip';
                                                                tooltipDiv.textContent = process.healthStatus.message;
                                                                tooltipWrapper.appendChild(tooltipDiv);
                                                            }
                                                            
                                                            processHeader.appendChild(tooltipWrapper);
                                                        }
                                                    }
                                                    
                                                    // Build process identifier from attributes
                                                    if (process.identifyingAttributes && Array.isArray(process.identifyingAttributes) && process.identifyingAttributes.length > 0) {
                                                        const validAttrs = process.identifyingAttributes.filter(attr => attr.name && attr.value);
                                                        if (validAttrs.length > 0) {
                                                            // Don't add anything to header, attributes will be shown below
                                                        } else {
                                                            processHeader.appendChild(document.createTextNode(`Process ${processIdx + 1}`));
                                                        }
                                                    } else {
                                                        processHeader.appendChild(document.createTextNode(`Process ${processIdx + 1}`));
                                                    }
                                                    
                                                    processWrapper.appendChild(processHeader);
                                                    
                                                    // Add attributes, each on its own line
                                                    if (process.identifyingAttributes && Array.isArray(process.identifyingAttributes) && process.identifyingAttributes.length > 0) {
                                                        const validAttrs = process.identifyingAttributes.filter(attr => attr.name && attr.value);
                                                        if (validAttrs.length > 0) {
                                                            validAttrs.forEach((attr) => {
                                                                const attrDiv = document.createElement('div');
                                                                attrDiv.style.fontSize = '11px';
                                                                attrDiv.style.color = '#666';
                                                                attrDiv.style.marginLeft = '8px';
                                                                attrDiv.style.display = 'flex';
                                                                attrDiv.style.alignItems = 'center';
                                                                attrDiv.style.gap = '4px';
                                                                
                                                                const nameSpan = document.createElement('strong');
                                                                nameSpan.style.fontWeight = '600';
                                                                nameSpan.textContent = attr.name;
                                                                attrDiv.appendChild(nameSpan);
                                                                attrDiv.appendChild(document.createTextNode(': ' + attr.value));
                                                                
                                                                processWrapper.appendChild(attrDiv);
                                                            });
                                                        }
                                                    }
                                                    
                                                    // Add instrumentations list
                                                    if (process.instrumentations && Array.isArray(process.instrumentations) && process.instrumentations.length > 0) {
                                                        const instrumentationsContainer = document.createElement('div');
                                                        instrumentationsContainer.style.marginLeft = '8px';
                                                        instrumentationsContainer.style.marginTop = '4px';
                                                        
                                                        const instrumentationsLabel = document.createElement('div');
                                                        instrumentationsLabel.style.fontSize = '11px';
                                                        instrumentationsLabel.style.fontWeight = '600';
                                                        instrumentationsLabel.style.color = '#333';
                                                        instrumentationsLabel.style.marginBottom = '2px';
                                                        instrumentationsLabel.textContent = 'instrumentations:';
                                                        instrumentationsContainer.appendChild(instrumentationsLabel);
                                                        
                                                        process.instrumentations.forEach((inst) => {
                                                            const instDiv = document.createElement('div');
                                                            instDiv.style.fontSize = '10px';
                                                            instDiv.style.color = '#666';
                                                            instDiv.style.marginLeft = '8px';
                                                            instDiv.style.marginBottom = '1px';
                                                            
                                                            let instText = inst.name;
                                                            if (inst.isStandardLibrary === true) {
                                                                instText += ' (standard library)';
                                                            }
                                                            instDiv.textContent = instText;
                                                            instrumentationsContainer.appendChild(instDiv);
                                                        });
                                                        
                                                        processWrapper.appendChild(instrumentationsContainer);
                                                    }
                                                    
                                                    processesSubsection.appendChild(processWrapper);
                                                });
                                                
                                                containerWrapper.appendChild(processesSubsection);
                                            }
                                            
                                            containersSubsection.appendChild(containerWrapper);
                                        }
                                    });
                                    
                                    odigosSection.appendChild(containersSubsection);
                                }
                                
                                podContent.appendChild(odigosSection);
                            }
                            
                            // Pod health status section
                            if (pod.podHealthStatus) {
                                const healthSection = document.createElement('div');
                                healthSection.style.marginBottom = '15px';
                                healthSection.style.padding = '10px';
                                healthSection.style.background = 'linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%)';
                                healthSection.style.borderRadius = '4px';
                                
                                const healthHeader = document.createElement('div');
                                healthHeader.style.display = 'flex';
                                healthHeader.style.alignItems = 'center';
                                healthHeader.style.gap = '8px';
                                healthHeader.style.marginBottom = '8px';
                                
                                // Add emoji based on status
                                if (pod.podHealthStatus.status) {
                                    const statusEmoji = getStatusEmoji(pod.podHealthStatus.status);
                                    if (statusEmoji) {
                                        const tooltipWrapper = document.createElement('span');
                                        tooltipWrapper.className = 'emoji-tooltip-wrapper';
                                        
                                        const emojiSpan = document.createElement('span');
                                        emojiSpan.textContent = statusEmoji + ' ';
                                        emojiSpan.style.cursor = 'help';
                                        emojiSpan.style.fontSize = '16px';
                                        tooltipWrapper.appendChild(emojiSpan);
                                        
                                        const tooltipDiv = document.createElement('div');
                                        tooltipDiv.className = 'emoji-tooltip';
                                        tooltipDiv.textContent = pod.podHealthStatus.message || '';
                                        tooltipWrapper.appendChild(tooltipDiv);
                                        
                                        healthHeader.appendChild(tooltipWrapper);
                                    }
                                }
                                
                                const healthTitle = document.createElement('span');
                                healthTitle.style.fontWeight = '600';
                                healthTitle.style.fontSize = '14px';
                                healthTitle.style.color = '#333';
                                healthTitle.textContent = 'application health';
                                healthHeader.appendChild(healthTitle);
                                
                                healthSection.appendChild(healthHeader);
                                
                                // Add message if available
                                if (pod.podHealthStatus.message) {
                                    const messageDiv = document.createElement('div');
                                    messageDiv.style.fontSize = '13px';
                                    messageDiv.style.color = '#666';
                                    messageDiv.style.marginTop = '4px';
                                    messageDiv.textContent = pod.podHealthStatus.message;
                                    healthSection.appendChild(messageDiv);
                                }
                                
                                // Add container health information
                                if (pod.containers && Array.isArray(pod.containers) && pod.containers.length > 0) {
                                    const containersDiv = document.createElement('div');
                                    containersDiv.style.marginTop = '12px';
                                    
                                    pod.containers.forEach((container) => {
                                        if (container.containerName) {
                                            const containerDiv = document.createElement('div');
                                            containerDiv.style.display = 'flex';
                                            containerDiv.style.alignItems = 'center';
                                            containerDiv.style.gap = '8px';
                                            containerDiv.style.marginBottom = '6px';
                                            containerDiv.style.fontSize = '13px';
                                            
                                            // Add emoji based on container healthStatus
                                            if (container.healthStatus && container.healthStatus.status) {
                                                const containerEmoji = getStatusEmoji(container.healthStatus.status);
                                                if (containerEmoji) {
                                                    const tooltipWrapper = document.createElement('span');
                                                    tooltipWrapper.className = 'emoji-tooltip-wrapper';
                                                    
                                                    const emojiSpan = document.createElement('span');
                                                    emojiSpan.textContent = containerEmoji + ' ';
                                                    emojiSpan.style.cursor = 'help';
                                                    tooltipWrapper.appendChild(emojiSpan);
                                                    
                                                    const tooltipDiv = document.createElement('div');
                                                    tooltipDiv.className = 'emoji-tooltip';
                                                    tooltipDiv.textContent = container.healthStatus.message || '';
                                                    tooltipWrapper.appendChild(tooltipDiv);
                                                    
                                                    containerDiv.appendChild(tooltipWrapper);
                                                }
                                            }
                                            
                                            const containerNameSpan = document.createElement('span');
                                            containerNameSpan.textContent = container.containerName;
                                            containerNameSpan.style.color = '#333';
                                            containerDiv.appendChild(containerNameSpan);
                                            
                                            containersDiv.appendChild(containerDiv);
                                            
                                            // Add container details section
                                            const detailsDiv = document.createElement('div');
                                            detailsDiv.style.marginLeft = '24px';
                                            detailsDiv.style.marginTop = '4px';
                                            detailsDiv.style.marginBottom = '8px';
                                            detailsDiv.style.fontSize = '12px';
                                            detailsDiv.style.color = '#666';
                                            
                                            // healthStatus
                                            if (container.healthStatus) {
                                                if (container.healthStatus.status) {
                                                    const healthStatusDiv = document.createElement('div');
                                                    healthStatusDiv.style.display = 'flex';
                                                    healthStatusDiv.style.alignItems = 'center';
                                                    healthStatusDiv.style.gap = '6px';
                                                    healthStatusDiv.style.marginBottom = '2px';
                                                    const healthStatusLabel = document.createElement('strong');
                                                    healthStatusLabel.style.fontWeight = '600';
                                                    healthStatusLabel.style.color = '#333';
                                                    healthStatusLabel.textContent = 'healthStatus.status:';
                                                    healthStatusDiv.appendChild(healthStatusLabel);
                                                    
                                                    // Apply status color
                                                    const statusValue = container.healthStatus.status.toLowerCase();
                                                    const statusClasses = {
                                                        'error': 'status-error',
                                                        'failure': 'status-failure',
                                                        'notice': 'status-notice',
                                                        'pending': 'status-pending',
                                                        'waiting': 'status-waiting',
                                                        'unsupported': 'status-unsupported',
                                                        'disabled': 'status-disabled',
                                                        'success': 'status-success',
                                                        'irrelevant': 'status-irrelevant',
                                                        'unknown': 'status-unknown'
                                                    };
                                                    const statusClass = statusClasses[statusValue] || '';
                                                    
                                                    const statusValueSpan = document.createElement('span');
                                                    if (statusClass) {
                                                        statusValueSpan.className = statusClass;
                                                    }
                                                    statusValueSpan.textContent = ' ' + container.healthStatus.status;
                                                    healthStatusDiv.appendChild(statusValueSpan);
                                                    detailsDiv.appendChild(healthStatusDiv);
                                                }
                                                
                                                if (container.healthStatus.message) {
                                                    const healthMessageDiv = document.createElement('div');
                                                    healthMessageDiv.style.fontSize = '12px';
                                                    healthMessageDiv.style.color = '#666';
                                                    healthMessageDiv.style.marginBottom = '2px';
                                                    const healthMessageLabel = document.createElement('strong');
                                                    healthMessageLabel.style.fontWeight = '600';
                                                    healthMessageLabel.style.color = '#333';
                                                    healthMessageLabel.textContent = 'healthStatus.message:';
                                                    healthMessageDiv.appendChild(healthMessageLabel);
                                                    healthMessageDiv.appendChild(document.createTextNode(' ' + container.healthStatus.message));
                                                    detailsDiv.appendChild(healthMessageDiv);
                                                }
                                                
                                                if (container.healthStatus.reasonEnum) {
                                                    const healthReasonDiv = document.createElement('div');
                                                    healthReasonDiv.style.display = 'flex';
                                                    healthReasonDiv.style.alignItems = 'center';
                                                    healthReasonDiv.style.gap = '6px';
                                                    healthReasonDiv.style.marginBottom = '2px';
                                                    const healthReasonLabel = document.createElement('strong');
                                                    healthReasonLabel.style.fontWeight = '600';
                                                    healthReasonLabel.style.color = '#333';
                                                    healthReasonLabel.textContent = 'healthStatus.reasonEnum:';
                                                    healthReasonDiv.appendChild(healthReasonLabel);
                                                    healthReasonDiv.appendChild(document.createTextNode(' ' + container.healthStatus.reasonEnum));
                                                    detailsDiv.appendChild(healthReasonDiv);
                                                }
                                            }
                                            
                                            // Started
                                            const startedDiv = document.createElement('div');
                                            startedDiv.style.display = 'flex';
                                            startedDiv.style.alignItems = 'center';
                                            startedDiv.style.gap = '6px';
                                            startedDiv.style.marginBottom = '2px';
                                            const startedEmoji = container.started === true ? '✅' : '❌';
                                            const startedLabel = document.createElement('strong');
                                            startedLabel.style.fontWeight = '600';
                                            startedLabel.style.color = '#333';
                                            startedLabel.textContent = 'started (container is running and passing startup probe if defined):';
                                            startedDiv.appendChild(document.createTextNode(startedEmoji + ' '));
                                            startedDiv.appendChild(startedLabel);
                                            startedDiv.appendChild(document.createTextNode(' ' + (container.started === true ? 'true' : 'false')));
                                            detailsDiv.appendChild(startedDiv);
                                            
                                            // Ready
                                            const readyDiv = document.createElement('div');
                                            readyDiv.style.display = 'flex';
                                            readyDiv.style.alignItems = 'center';
                                            readyDiv.style.gap = '6px';
                                            readyDiv.style.marginBottom = '2px';
                                            const readyEmoji = container.ready === true ? '✅' : '❌';
                                            const readyLabel = document.createElement('strong');
                                            readyLabel.style.fontWeight = '600';
                                            readyLabel.style.color = '#333';
                                            readyLabel.textContent = 'ready (container is passing readiness probe/health checks):';
                                            readyDiv.appendChild(document.createTextNode(readyEmoji + ' '));
                                            readyDiv.appendChild(readyLabel);
                                            readyDiv.appendChild(document.createTextNode(' ' + (container.ready === true ? 'true' : 'false')));
                                            detailsDiv.appendChild(readyDiv);
                                            
                                            // isCrashLoop
                                            const crashLoopDiv = document.createElement('div');
                                            crashLoopDiv.style.display = 'flex';
                                            crashLoopDiv.style.alignItems = 'center';
                                            crashLoopDiv.style.gap = '6px';
                                            crashLoopDiv.style.marginBottom = '2px';
                                            const crashLoopEmoji = container.isCrashLoop === true ? '⚠️' : '✅';
                                            const crashLoopLabel = document.createElement('strong');
                                            crashLoopLabel.style.fontWeight = '600';
                                            crashLoopLabel.style.color = container.isCrashLoop === true ? '#d32f2f' : '#333';
                                            crashLoopLabel.textContent = 'isCrashLoop:';
                                            crashLoopDiv.appendChild(document.createTextNode(crashLoopEmoji + ' '));
                                            crashLoopDiv.appendChild(crashLoopLabel);
                                            crashLoopDiv.appendChild(document.createTextNode(' ' + (container.isCrashLoop === true ? 'true' : 'false')));
                                            if (container.isCrashLoop === true) {
                                                crashLoopDiv.style.color = '#d32f2f';
                                                crashLoopDiv.style.fontWeight = '600';
                                            }
                                            detailsDiv.appendChild(crashLoopDiv);
                                            
                                            // restartCount
                                            const restartDiv = document.createElement('div');
                                            restartDiv.style.display = 'flex';
                                            restartDiv.style.alignItems = 'center';
                                            restartDiv.style.gap = '6px';
                                            const restartCount = container.restartCount || 0;
                                            const restartEmoji = restartCount === 0 ? '✅' : '⚠️';
                                            const restartLabel = document.createElement('strong');
                                            restartLabel.style.fontWeight = '600';
                                            restartLabel.style.color = restartCount > 0 ? '#f57c00' : '#333';
                                            restartLabel.textContent = 'restartCount:';
                                            restartDiv.appendChild(document.createTextNode(restartEmoji + ' '));
                                            restartDiv.appendChild(restartLabel);
                                            restartDiv.appendChild(document.createTextNode(' ' + restartCount));
                                            if (restartCount > 0) {
                                                restartDiv.style.color = '#f57c00';
                                            }
                                            detailsDiv.appendChild(restartDiv);
                                            
                                            // Waiting state information
                                            if (container.waitingReasonEnum || container.waitingMessage) {
                                                // Header line
                                                const waitingHeaderDiv = document.createElement('div');
                                                waitingHeaderDiv.style.fontSize = '12px';
                                                waitingHeaderDiv.style.color = '#666';
                                                waitingHeaderDiv.style.marginTop = '4px';
                                                waitingHeaderDiv.textContent = 'container is in waiting state in kubernetes';
                                                detailsDiv.appendChild(waitingHeaderDiv);
                                                
                                                // waitingReasonEnum
                                                if (container.waitingReasonEnum) {
                                                    const waitingReasonDiv = document.createElement('div');
                                                    waitingReasonDiv.style.display = 'flex';
                                                    waitingReasonDiv.style.alignItems = 'center';
                                                    waitingReasonDiv.style.gap = '6px';
                                                    waitingReasonDiv.style.marginTop = '0px';
                                                    const waitingReasonLabel = document.createElement('strong');
                                                    waitingReasonLabel.style.fontWeight = '600';
                                                    waitingReasonLabel.style.color = '#333';
                                                    waitingReasonLabel.textContent = 'waiting state kubernetes reason (enum):';
                                                    waitingReasonDiv.appendChild(waitingReasonLabel);
                                                    waitingReasonDiv.appendChild(document.createTextNode(' ' + container.waitingReasonEnum));
                                                    detailsDiv.appendChild(waitingReasonDiv);
                                                }
                                                
                                                // waitingMessage
                                                if (container.waitingMessage) {
                                                    const waitingMessageDiv = document.createElement('div');
                                                    waitingMessageDiv.style.display = 'flex';
                                                    waitingMessageDiv.style.alignItems = 'center';
                                                    waitingMessageDiv.style.gap = '6px';
                                                    waitingMessageDiv.style.marginTop = '2px';
                                                    const waitingMessageLabel = document.createElement('strong');
                                                    waitingMessageLabel.style.fontWeight = '600';
                                                    waitingMessageLabel.style.color = '#333';
                                                    waitingMessageLabel.textContent = 'waiting state kubernetes message (human readable):';
                                                    waitingMessageDiv.appendChild(waitingMessageLabel);
                                                    waitingMessageDiv.appendChild(document.createTextNode(' ' + container.waitingMessage));
                                                    detailsDiv.appendChild(waitingMessageDiv);
                                                }
                                            }
                                            
                                            // Running state information
                                            if (container.runningStartedTime) {
                                                // Header line
                                                const runningHeaderDiv = document.createElement('div');
                                                runningHeaderDiv.style.fontSize = '12px';
                                                runningHeaderDiv.style.color = '#666';
                                                runningHeaderDiv.style.marginTop = '4px';
                                                runningHeaderDiv.textContent = 'container is in running state in kubernetes';
                                                detailsDiv.appendChild(runningHeaderDiv);
                                                
                                                // Start time and age
                                                const runningTimeDiv = document.createElement('div');
                                                runningTimeDiv.style.display = 'flex';
                                                runningTimeDiv.style.alignItems = 'center';
                                                runningTimeDiv.style.gap = '6px';
                                                runningTimeDiv.style.fontSize = '12px';
                                                runningTimeDiv.style.color = '#666';
                                                runningTimeDiv.style.marginTop = '0px';
                                                
                                                const runningStartTimeDate = new Date(container.runningStartedTime);
                                                
                                                const runningStartTimeLabel = document.createElement('strong');
                                                runningStartTimeLabel.style.fontWeight = '600';
                                                runningStartTimeLabel.style.color = '#333';
                                                runningStartTimeLabel.textContent = 'start time of active container (including restarts):';
                                                runningTimeDiv.appendChild(runningStartTimeLabel);
                                                
                                                const runningStartTimeSpan = document.createElement('span');
                                                runningStartTimeSpan.textContent = runningStartTimeDate.toLocaleString();
                                                runningTimeDiv.appendChild(runningStartTimeSpan);
                                                
                                                const runningAgeSpan = document.createElement('span');
                                                runningAgeSpan.id = `container-age-${idx}-${podIdx}-${container.containerName}`;
                                                runningAgeSpan.style.marginLeft = '8px';
                                                runningAgeSpan.style.color = '#666';
                                                
                                                const updateRunningAge = () => {
                                                    const now = new Date();
                                                    const seconds = Math.floor((now - runningStartTimeDate) / 1000);
                                                    const ageText = formatDuration(seconds);
                                                    runningAgeSpan.textContent = `(${ageText} ago)`;
                                                };
                                                
                                                updateRunningAge();
                                                setInterval(updateRunningAge, 1000);
                                                
                                                runningTimeDiv.appendChild(runningAgeSpan);
                                                detailsDiv.appendChild(runningTimeDiv);
                                            }
                                            
                                            containersDiv.appendChild(detailsDiv);
                                        }
                                    });
                                    
                                    healthSection.appendChild(containersDiv);
                                }
                                
                                podContent.appendChild(healthSection);
                            }
                            
                            // Kubectl commands section
                            const k8sCommandsSection = document.createElement('div');
                            k8sCommandsSection.style.marginBottom = '6px';
                            k8sCommandsSection.style.padding = '6px';
                            k8sCommandsSection.style.background = 'linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%)';
                            k8sCommandsSection.style.borderRadius = '4px';
                            
                            const k8sCommandsTitle = document.createElement('div');
                            k8sCommandsTitle.style.fontSize = '14px';
                            k8sCommandsTitle.style.fontWeight = '600';
                            k8sCommandsTitle.style.color = '#333';
                            k8sCommandsTitle.style.marginBottom = '8px';
                            k8sCommandsTitle.textContent = 'Kubectl Commands';
                            k8sCommandsSection.appendChild(k8sCommandsTitle);
                            
                            const k8sCommandsDiv = document.createElement('div');
                            k8sCommandsDiv.className = 'k8s-commands';
                            
                            const namespace = item && item.id && item.id.namespace ? item.id.namespace : '';
                            
                            // Describe Pod command
                            const describeSection = document.createElement('div');
                            describeSection.className = 'k8s-command-section';
                            describeSection.style.marginBottom = '4px';
                            
                            const describeTitle = document.createElement('div');
                            describeTitle.className = 'k8s-command-title';
                            describeTitle.style.fontSize = '11px';
                            describeTitle.style.marginBottom = '2px';
                            describeTitle.textContent = 'Describe Pod';
                            describeSection.appendChild(describeTitle);
                            
                            const describeBlock = document.createElement('div');
                            describeBlock.className = 'k8s-command-block';
                            describeBlock.style.gap = '4px';
                            
                            const describeCopyBtn = document.createElement('button');
                            describeCopyBtn.className = 'k8s-copy-btn';
                            describeCopyBtn.textContent = 'Copy';
                            describeCopyBtn.onclick = () => copyToClipboard(`kubectl describe pod ${podName} -n ${namespace}`);
                            describeBlock.appendChild(describeCopyBtn);
                            
                            const describeCommandText = document.createElement('div');
                            describeCommandText.className = 'k8s-command-text';
                            describeCommandText.textContent = `kubectl describe pod ${podName} -n ${namespace}`;
                            describeBlock.appendChild(describeCommandText);
                            
                            describeSection.appendChild(describeBlock);
                            k8sCommandsDiv.appendChild(describeSection);
                            
                            // Get Pod YAML command
                            const yamlSection = document.createElement('div');
                            yamlSection.className = 'k8s-command-section';
                            yamlSection.style.marginBottom = '0px';
                            
                            const yamlTitle = document.createElement('div');
                            yamlTitle.className = 'k8s-command-title';
                            yamlTitle.style.fontSize = '11px';
                            yamlTitle.style.marginBottom = '2px';
                            yamlTitle.textContent = 'Get Pod YAML';
                            yamlSection.appendChild(yamlTitle);
                            
                            const yamlBlock = document.createElement('div');
                            yamlBlock.className = 'k8s-command-block';
                            yamlBlock.style.gap = '4px';
                            
                            const yamlCopyBtn = document.createElement('button');
                            yamlCopyBtn.className = 'k8s-copy-btn';
                            yamlCopyBtn.textContent = 'Copy';
                            yamlCopyBtn.onclick = () => copyToClipboard(`kubectl get pod ${podName} -n ${namespace} -o yaml`);
                            yamlBlock.appendChild(yamlCopyBtn);
                            
                            const yamlCommandText = document.createElement('div');
                            yamlCommandText.className = 'k8s-command-text';
                            yamlCommandText.textContent = `kubectl get pod ${podName} -n ${namespace} -o yaml`;
                            yamlBlock.appendChild(yamlCommandText);
                            
                            yamlSection.appendChild(yamlBlock);
                            k8sCommandsDiv.appendChild(yamlSection);
                            
                            k8sCommandsSection.appendChild(k8sCommandsDiv);
                            podContent.appendChild(k8sCommandsSection);
                            
                            // Toggle functionality
                            const toggleFunc = (e) => {
                                if (e) {
                                    e.stopPropagation();
                                }
                                toggle.classList.toggle('expanded');
                                podContent.classList.toggle('expanded');
                                if (podContent.classList.contains('expanded')) {
                                    podContent.style.display = 'block';
                                } else {
                                    podContent.style.display = 'none';
                                }
                            };
                            
                            toggle.onclick = (e) => {
                                e.stopPropagation();
                                toggleFunc();
                            };
                            podHeader.onclick = toggleFunc;
                            
                            podWrapper.appendChild(podContent);
                            podsContent.appendChild(podWrapper);
                        });
                    } else {
                        const noPods = document.createElement('div');
                        noPods.textContent = 'no pods info available';
                        noPods.style.padding = '15px';
                        noPods.style.color = '#666';
                        podsContent.appendChild(noPods);
                    }
                    
                    contentDiv.appendChild(podsContent);
                    
                    // Raw content tab
                    const rawContent = document.createElement('div');
                    rawContent.id = `raw-content-${idx}`;
                    rawContent.className = 'tab-content';
                    // Render object properties directly without extra wrapper
                    Object.keys(item).forEach(k => {
                        renderJSON(item[k], rawContent, k);
                    });
                    contentDiv.appendChild(rawContent);
                    
                    // Toggle functionality
                    const toggleFunc = (e) => {
                        if (e) {
                            e.stopPropagation();
                        }
                        toggle.classList.toggle('expanded');
                        contentDiv.classList.toggle('expanded');
                        if (contentDiv.classList.contains('expanded')) {
                            contentDiv.style.display = 'block';
                        } else {
                            contentDiv.style.display = 'none';
                        }
                    };
                    
                    toggle.onclick = (e) => {
                        e.stopPropagation();
                        toggleFunc();
                    };
                    headerDiv.onclick = toggleFunc;
                    
                    wrapper.appendChild(headerDiv);
                    wrapper.appendChild(contentDiv);
                    
                    output.appendChild(wrapper);
                });
                
                // Check if no workloads found after filtering (only show if there was data to filter)
                if (filteredData.length === 0 && totalCount > 0) {
                    const noResultsDiv = document.createElement('div');
                    noResultsDiv.style.textAlign = 'center';
                    noResultsDiv.style.padding = '60px 20px';
                    noResultsDiv.style.color = '#6b7280';
                    
                    const messageDiv = document.createElement('div');
                    messageDiv.style.fontSize = '16px';
                    messageDiv.style.marginBottom = '16px';
                    messageDiv.textContent = 'No workloads match the applied filters.';
                    noResultsDiv.appendChild(messageDiv);
                    
                    const suggestionDiv = document.createElement('div');
                    suggestionDiv.style.fontSize = '14px';
                    suggestionDiv.style.marginBottom = '24px';
                    suggestionDiv.style.color = '#9ca3af';
                    suggestionDiv.textContent = 'Try adjusting your filters or clear them to see all workloads.';
                    noResultsDiv.appendChild(suggestionDiv);
                    
                    const clearBtn = document.createElement('button');
                    clearBtn.className = 'btn';
                    clearBtn.textContent = 'Clear All Filters';
                    clearBtn.onclick = () => {
                        clearAllFilters();
                    };
                    noResultsDiv.appendChild(clearBtn);
                    
                    output.appendChild(noResultsDiv);
                }
                
                // Update status line
                updateStatusLine(totalCount, filteredData.length, selectedNamespaces, selectedWorkloads);
            } else {
                renderJSON(data, output);
                // Update status line for non-array data
                updateStatusLine(totalCount, 0, selectedNamespaces, selectedWorkloads);
            }
        }
        
        function updateOverview(data) {
            const overviewSection = document.getElementById('overview-section');
            if (!overviewSection) return;
            
            if (!Array.isArray(data) || data.length === 0) {
                overviewSection.style.display = 'none';
                return;
            }
            
            // Calculate total workloads and unique namespaces
            const totalWorkloads = data.length;
            const uniqueNamespaces = new Set();
            let markedCount = 0;
            let notMarkedCount = 0;
            const statusCounts = new Map(); // status -> count
            
            data.forEach(item => {
                if (item && item.id && item.id.namespace) {
                    uniqueNamespaces.add(item.id.namespace);
                }
                if (item && item.markedForInstrumentation && 
                    item.markedForInstrumentation.markedForInstrumentation === true) {
                    markedCount++;
                    // Count status for marked workloads
                    if (item && item.workloadOdigosHealthStatus && item.workloadOdigosHealthStatus.status) {
                        const status = item.workloadOdigosHealthStatus.status.toLowerCase();
                        statusCounts.set(status, (statusCounts.get(status) || 0) + 1);
                    }
                } else {
                    notMarkedCount++;
                }
            });
            
            const namespaceCount = uniqueNamespaces.size;
            const namespaceText = namespaceCount === 1 ? 'namespace' : 'namespaces';
            
            // Update overview header stats
            const headerStats = document.getElementById('overview-header-stats');
            if (headerStats) {
                headerStats.innerHTML = ''; // Clear previous content
                
                const statusOrder = ['error', 'failure', 'notice', 'pending', 'waiting', 'unsupported', 'disabled', 'success', 'irrelevant', 'unknown'];
                
                // Add marked count
                const markedSpan = document.createElement('span');
                markedSpan.textContent = `${markedCount} marked for instrumentation`;
                headerStats.appendChild(markedSpan);
                
                // Add status counts (sorted by enum order)
                const sortedStatuses = Array.from(statusCounts.entries()).sort((a, b) => {
                    const orderA = statusOrder.indexOf(a[0]);
                    const orderB = statusOrder.indexOf(b[0]);
                    return (orderA === -1 ? 999 : orderA) - (orderB === -1 ? 999 : orderB);
                });
                
                sortedStatuses.forEach(([status, count], index) => {
                    // Add separator
                    if (index === 0 || index > 0) {
                        const separator = document.createElement('span');
                        separator.textContent = ' • ';
                        headerStats.appendChild(separator);
                    }
                    
                    const statusContainer = document.createElement('span');
                    statusContainer.style.display = 'inline-flex';
                    statusContainer.style.alignItems = 'center';
                    statusContainer.style.gap = '2px';
                    
                    const emoji = getStatusEmoji(status);
                    if (emoji) {
                        // Add emoji with tooltip
                        const tooltipWrapper = document.createElement('span');
                        tooltipWrapper.className = 'emoji-tooltip-wrapper';
                        tooltipWrapper.style.marginRight = '0';
                        
                        const emojiSpan = document.createElement('span');
                        emojiSpan.textContent = emoji + ' ';
                        emojiSpan.style.cursor = 'help';
                        tooltipWrapper.appendChild(emojiSpan);
                        
                        const tooltipDiv = document.createElement('div');
                        tooltipDiv.className = 'emoji-tooltip';
                        tooltipDiv.textContent = getStatusTooltip(status);
                        tooltipWrapper.appendChild(tooltipDiv);
                        
                        statusContainer.appendChild(tooltipWrapper);
                    }
                    
                    // Add count and status text
                    if (status === 'success') {
                        statusContainer.appendChild(document.createTextNode(`${count} healthy`));
                    } else {
                        const statusDisplay = status.charAt(0).toUpperCase() + status.slice(1);
                        statusContainer.appendChild(document.createTextNode(`${count} ${statusDisplay.toLowerCase()}`));
                    }
                    
                    headerStats.appendChild(statusContainer);
                });
            }
            
            // Update overview display
            document.getElementById('overview-total').textContent = 
                `${totalWorkloads} workload${totalWorkloads !== 1 ? 's' : ''} found in cluster in ${namespaceCount} ${namespaceText} (excluding ignored namespaces)`;
            document.getElementById('overview-marked').textContent = 
                `${markedCount} ${markedCount === 1 ? 'is' : 'are'} marked to be instrumented by odigos`;
            document.getElementById('overview-not-marked').textContent = 
                `${notMarkedCount} ${notMarkedCount === 1 ? 'is' : 'are'} not marked to be instrumented by odigos`;
            
            // Show filter buttons for marked/not marked
            const markedFilterBtn = document.getElementById('overview-marked-filter-btn');
            const notMarkedFilterBtn = document.getElementById('overview-not-marked-filter-btn');
            if (markedFilterBtn) markedFilterBtn.style.display = markedCount > 0 ? 'inline-block' : 'none';
            if (notMarkedFilterBtn) notMarkedFilterBtn.style.display = notMarkedCount > 0 ? 'inline-block' : 'none';
            
            // Calculate workloadOdigosHealthStatus breakdown for marked workloads
            const healthStatusSection = document.getElementById('overview-health-status');
            const healthStatusContent = document.getElementById('overview-health-status-content');
            if (markedCount > 0 && healthStatusSection && healthStatusContent) {
                // Map to store unique combinations: key = "name|reasonEnum|status", value = count
                const healthStatusCounts = new Map();
                let nullHealthStatusCount = 0;
                
                // Status order from enum.graphqls DesiredStateProgress
                const statusOrder = ['Error', 'Failure', 'Notice', 'Pending', 'Waiting', 'Unsupported', 'Disabled', 'Success', 'Irrelevant', 'Unknown'];
                
                // Count workloads by workloadOdigosHealthStatus
                data.forEach(item => {
                    if (item && item.markedForInstrumentation && 
                        item.markedForInstrumentation.markedForInstrumentation === true) {
                        if (!item.workloadOdigosHealthStatus) {
                            nullHealthStatusCount++;
                        } else {
                            const name = item.workloadOdigosHealthStatus.name || '';
                            const reasonEnum = item.workloadOdigosHealthStatus.reasonEnum || '';
                            const status = item.workloadOdigosHealthStatus.status || '';
                            
                            if (name && reasonEnum && status) {
                                const key = `${name}|${reasonEnum}|${status}`;
                                healthStatusCounts.set(key, {
                                    name: name,
                                    reasonEnum: reasonEnum,
                                    status: status,
                                    count: (healthStatusCounts.get(key)?.count || 0) + 1
                                });
                            } else {
                                nullHealthStatusCount++;
                            }
                        }
                    }
                });
                
                // Clear previous content
                healthStatusContent.innerHTML = '';
                
                // Convert map to array and sort by status order
                const healthStatusArray = Array.from(healthStatusCounts.values());
                healthStatusArray.sort((a, b) => {
                    const statusA = statusOrder.indexOf(a.status);
                    const statusB = statusOrder.indexOf(b.status);
                    if (statusA !== statusB) {
                        return statusA - statusB;
                    }
                    // If same status, sort by name, then reasonEnum
                    const nameCompare = a.name.localeCompare(b.name);
                    if (nameCompare !== 0) {
                        return nameCompare;
                    }
                    return a.reasonEnum.localeCompare(b.reasonEnum);
                });
                
                // Show breakdown
                if (nullHealthStatusCount > 0 || healthStatusArray.length > 0) {
                    // Show null health status if any
                    if (nullHealthStatusCount > 0) {
                        const statDiv = document.createElement('div');
                        statDiv.className = 'overview-stat';
                        
                        const labelSpan = document.createElement('span');
                        labelSpan.className = 'overview-stat-label';
                        labelSpan.textContent = '  ';
                        statDiv.appendChild(labelSpan);
                        
                        const valueSpan = document.createElement('span');
                        valueSpan.className = 'overview-stat-value';
                        valueSpan.textContent = `${nullHealthStatusCount} ${nullHealthStatusCount === 1 ? 'has' : 'have'} no health status`;
                        statDiv.appendChild(valueSpan);
                        
                        // Note: No filter button for null health status since we can't filter by it
                        
                        healthStatusContent.appendChild(statDiv);
                    }
                    
                    // Show each unique combination
                    healthStatusArray.forEach(entry => {
                        const statDiv = document.createElement('div');
                        statDiv.className = 'overview-stat';
                        
                        const labelSpan = document.createElement('span');
                        labelSpan.className = 'overview-stat-label';
                        labelSpan.textContent = '  ';
                        statDiv.appendChild(labelSpan);
                        
                        const valueSpan = document.createElement('span');
                        valueSpan.className = 'overview-stat-value';
                        const nameText = parseCamelCase(entry.name);
                        const reasonText = parseCamelCase(entry.reasonEnum);
                        const statusText = entry.status.toLowerCase();
                        const statusEmoji = getStatusEmoji(entry.status);
                        
                        // Add emoji with tooltip if available
                        if (statusEmoji) {
                            const tooltipWrapper = document.createElement('span');
                            tooltipWrapper.className = 'emoji-tooltip-wrapper';
                            tooltipWrapper.style.marginRight = '0';
                            
                            const emojiSpan = document.createElement('span');
                            emojiSpan.textContent = statusEmoji + ' ';
                            emojiSpan.style.cursor = 'help';
                            tooltipWrapper.appendChild(emojiSpan);
                            
                            const tooltipDiv = document.createElement('div');
                            tooltipDiv.className = 'emoji-tooltip';
                            tooltipDiv.textContent = getStatusTooltip(entry.status);
                            tooltipWrapper.appendChild(tooltipDiv);
                            
                            valueSpan.appendChild(tooltipWrapper);
                        }
                        
                        valueSpan.appendChild(document.createTextNode(`${entry.count} ${entry.count === 1 ? 'is' : 'are'} ${statusText} (${nameText}: ${reasonText})`));
                        statDiv.appendChild(valueSpan);
                        
                        // Add "filter these" button
                        const filterBtn = document.createElement('button');
                        filterBtn.className = 'overview-filter-btn';
                        filterBtn.textContent = 'filter these';
                        filterBtn.title = 'Filter to show only workloads with this health status';
                        filterBtn.onclick = (e) => {
                            e.stopPropagation();
                            filterByHealthStatus(entry.status, entry.name, entry.reasonEnum);
                        };
                        statDiv.appendChild(filterBtn);
                        
                        healthStatusContent.appendChild(statDiv);
                    });
                    
                    healthStatusSection.style.display = 'block';
                } else {
                    healthStatusSection.style.display = 'none';
                }
            } else if (healthStatusSection) {
                healthStatusSection.style.display = 'none';
            }
            
            overviewSection.style.display = 'block';
        }
        
        function toggleOverview() {
            const content = document.getElementById('overview-content');
            const toggle = document.getElementById('overview-toggle');
            if (content && toggle) {
                content.classList.toggle('expanded');
                toggle.classList.toggle('expanded');
            }
        }
        
        function filterByHealthStatus(status, name, reasonEnum) {
            // Clear all filters first
            clearAllFilters();
            
            // Wait a bit for filters to clear, then set the specific health status filter
            setTimeout(() => {
                // Uncheck all health status checkboxes
                const allHealthStatusCheckboxes = document.querySelectorAll('.health-status-checkbox');
                allHealthStatusCheckboxes.forEach(checkbox => {
                    checkbox.checked = false;
                });
                
                // Find and check the specific health status checkbox
                const targetCheckbox = Array.from(allHealthStatusCheckboxes).find(checkbox => {
                    return checkbox.dataset.status === status &&
                           checkbox.dataset.name === name &&
                           checkbox.dataset.reasonEnum === reasonEnum;
                });
                
                if (targetCheckbox) {
                    targetCheckbox.checked = true;
                    updateHealthStatusCounts();
                    updateHealthStatusCountDisplay();
                    updateHealthStatusHeaderButton();
                    updateUrlParams();
                    applyHealthStatusFilters();
                }
            }, 50);
        }
        
        function filterByMarkedStatus(isMarked) {
            // Clear all filters first
            clearAllFilters();
            
            // Wait a bit for filters to clear, then set the specific marked status filter
            setTimeout(() => {
                const markedCheckbox = document.getElementById('filter-marked');
                const notMarkedCheckbox = document.getElementById('filter-not-marked');
                
                if (isMarked) {
                    // Show only marked workloads
                    if (markedCheckbox) markedCheckbox.checked = true;
                    if (notMarkedCheckbox) notMarkedCheckbox.checked = false;
                } else {
                    // Show only not marked workloads
                    if (markedCheckbox) markedCheckbox.checked = false;
                    if (notMarkedCheckbox) notMarkedCheckbox.checked = true;
                }
                
                updateUrlParams();
                applyInstrumentationFilter();
            }, 50);
        }
        
        function loadData(data) {
            allWorkloadData = data;
            
            // Apply URL parameters to restore filters (if any)
            applyUrlParams();
            
            const selectedNamespaces = getSelectedNamespaces();
            const selectedWorkloads = getSelectedWorkloads();
            populateNamespaceCheckboxes(data);
            // Apply pending namespace filters from URL after checkboxes are created
            applyPendingNamespaceFilters();
            const finalSelectedNamespaces = getSelectedNamespaces();
            updateNamespaceHeaderButton();
            updateWorkloadLabel();
            populateWorkloadCheckboxes(data, finalSelectedNamespaces);
            // Apply pending workload filters from URL after checkboxes are created
            applyPendingWorkloadFilters();
            const finalSelectedWorkloads = getSelectedWorkloads();
            populateLanguageCheckboxes(data);
            // Apply pending language filters from URL after checkboxes are created
            applyPendingLanguageFilters();
            updateInstrumentationCounts(data);
            populateHealthStatusFilters(data);
            // Apply pending health status filters from URL after filters are populated
            applyPendingHealthStatusFilters();
            populateConditionFilters(data);
            updateConditionCounts(allWorkloadData);
            // Apply pending condition filters from URL after filters are populated
            applyPendingConditionFilters();
            
            // Update overview (shows all workloads regardless of filters)
            updateOverview(data);
            
            displayFilteredData(data, finalSelectedNamespaces, finalSelectedWorkloads);
        }
        
        // Apply URL parameters on page load
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                applyUrlParams();
            });
        } else {
            applyUrlParams();
        }
        
        // Initial load
        refreshData();
    </script>
</body>
</html>


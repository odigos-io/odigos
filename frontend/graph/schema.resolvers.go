package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/odigos-io/odigos/api/k8sconsts"
	"github.com/odigos-io/odigos/api/odigos/v1alpha1"
	"github.com/odigos-io/odigos/common"
	"github.com/odigos-io/odigos/frontend/graph/loaders"
	"github.com/odigos-io/odigos/frontend/graph/model"
	"github.com/odigos-io/odigos/frontend/graph/status"
	"github.com/odigos-io/odigos/frontend/kube"
	"github.com/odigos-io/odigos/frontend/services"
	frontendcommon "github.com/odigos-io/odigos/frontend/services/common"
	"github.com/odigos-io/odigos/frontend/services/describe/odigos_describe"
	"github.com/odigos-io/odigos/frontend/services/describe/source_describe"
	testconnection "github.com/odigos-io/odigos/frontend/services/test_connection"
	"github.com/odigos-io/odigos/k8sutils/pkg/env"
	"github.com/odigos-io/odigos/k8sutils/pkg/pro"
	"github.com/odigos-io/odigos/k8sutils/pkg/workload"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
)

// APITokens is the resolver for the apiTokens field.
func (r *computePlatformResolver) APITokens(ctx context.Context, obj *model.ComputePlatform) ([]*model.APIToken, error) {
	ns := env.GetCurrentNamespace()

	// The result should always be 0 or 1:
	// If it's 0, it means this is the OSS version.
	// If it's 1, it means this is the Enterprise version.

	secret, err := kube.DefaultClient.CoreV1().Secrets(ns).Get(ctx, k8sconsts.OdigosProSecretName, metav1.GetOptions{})
	if err != nil {
		if apierrors.IsNotFound(err) {
			return make([]*model.APIToken, 0), nil
		}
		return nil, err
	}

	token := string(secret.Data[k8sconsts.OdigosOnpremTokenSecretKey])

	// Extract the payload from the JWT
	tokenPayload, err := extractJWTPayload(token)
	if err != nil {
		// We don't want to return an error here, because the user may have provided a bad token.
		// Throwing this will prevent the entire CP from being fetched, and prevent the user from being able to update the token...
		// return nil, fmt.Errorf("failed to extract JWT payload: %w", err)

		return []*model.APIToken{
			{
				Token:     token,
				Name:      "ERROR",
				IssuedAt:  0,
				ExpiresAt: 0,
			},
		}, nil
	}

	// Extract values from the token payload
	aud, _ := tokenPayload["aud"].(string)
	iat, _ := tokenPayload["iat"].(float64)
	exp, _ := tokenPayload["exp"].(float64)

	// We need to return an array (even if it's just 1 token), because in the future we will have to support multiple platforms.
	return []*model.APIToken{
		{
			Token:     token,
			Name:      aud,
			IssuedAt:  int(iat) * 1000, // Convert to milliseconds
			ExpiresAt: int(exp) * 1000, // Convert to milliseconds
		},
	}, nil
}

// K8sActualNamespaces is the resolver for the k8sActualNamespaces field.
func (r *computePlatformResolver) K8sActualNamespaces(ctx context.Context, obj *model.ComputePlatform) ([]*model.K8sActualNamespace, error) {
	return services.GetK8SNamespaces(ctx, nil)
}

// K8sActualNamespace is the resolver for the k8sActualNamespace field.
func (r *computePlatformResolver) K8sActualNamespace(ctx context.Context, obj *model.ComputePlatform, name string) (*model.K8sActualNamespace, error) {
	namespaces, err := services.GetK8SNamespaces(ctx, &name)
	if err != nil {
		return nil, err
	}
	if len(namespaces) == 0 {
		return nil, fmt.Errorf("no namespaces found with name %s", name)
	}
	if len(namespaces) > 1 {
		return nil, fmt.Errorf("multiple namespaces found with name %s", name)
	}
	return namespaces[0], nil
}

// Sources is the resolver for the sources field.
func (r *computePlatformResolver) Sources(ctx context.Context, obj *model.ComputePlatform) ([]*model.K8sActualSource, error) {
	icList, err := kube.DefaultClient.OdigosClient.InstrumentationConfigs("").List(ctx, metav1.ListOptions{})
	if err != nil {
		return nil, err
	}

	sources := make([]*model.K8sActualSource, 0)
	for _, ic := range icList.Items {
		dataStreamNames := services.ExtractDataStreamsFromInstrumentationConfig(&ic)
		source, err := instrumentationConfigToActualSource(ctx, ic, dataStreamNames, "", "")
		if err != nil {
			return nil, err
		}
		sources = append(sources, source)
	}

	return sources, nil
}

// Source is the resolver for the source field.
func (r *computePlatformResolver) Source(ctx context.Context, obj *model.ComputePlatform, sourceID model.K8sSourceID) (*model.K8sActualSource, error) {
	ns := sourceID.Namespace
	kind := sourceID.Kind
	name := sourceID.Name

	ic, err := kube.DefaultClient.OdigosClient.InstrumentationConfigs(ns).Get(ctx, workload.CalculateWorkloadRuntimeObjectName(name, string(kind)), metav1.GetOptions{})
	if err != nil {
		return nil, fmt.Errorf("failed to get InstrumentationConfig: %w", err)
	}
	if ic == nil {
		return nil, fmt.Errorf("InstrumentationConfig not found for %s/%s in namespace %s", kind, name, ns)
	}

	dataStreamNames := services.ExtractDataStreamsFromInstrumentationConfig(ic)

	manifestYAML, err := services.K8sManifest(ctx, ns, model.K8sResourceKind(kind), name)
	if err != nil {
		return nil, fmt.Errorf("failed to get manifest YAML: %w", err)
	}

	instrumentationConfigYAML, err := services.K8sManifest(ctx, ns, model.K8sResourceKindInstrumentationConfig, workload.CalculateWorkloadRuntimeObjectName(name, string(kind)))
	if err != nil {
		return nil, fmt.Errorf("failed to get InstrumentationConfig YAML: %w", err)
	}

	payload, err := instrumentationConfigToActualSource(ctx, *ic, dataStreamNames, manifestYAML, instrumentationConfigYAML)
	if err != nil {
		return nil, fmt.Errorf("failed to get Source: %w", err)
	}

	otherConditions, err := services.GetOtherConditionsForSources(ctx, ns, name, string(kind))
	if err != nil {
		return nil, err
	}
	for _, item := range otherConditions {
		payload.Conditions = append(payload.Conditions, item.Conditions...)
	}

	services.SortConditions(payload.Conditions)

	return payload, nil
}

// Destinations is the resolver for the destinations field.
func (r *computePlatformResolver) Destinations(ctx context.Context, obj *model.ComputePlatform) ([]*model.Destination, error) {
	ns := env.GetCurrentNamespace()

	dests, err := kube.DefaultClient.OdigosClient.Destinations(ns).List(ctx, metav1.ListOptions{})
	if err != nil {
		return nil, err
	}

	var destinations []*model.Destination
	for _, dest := range dests.Items {
		secretFields := make(map[string]string)

		if !services.IsReadonlyMode(ctx) {
			secretFields, err = services.GetDestinationSecretFields(ctx, ns, &dest)
			if err != nil {
				return nil, err
			}
		}

		// Convert the k8s destination format to the expected endpoint format
		endpointDest := services.K8sDestinationToEndpointFormat(dest, secretFields)
		destinations = append(destinations, &endpointDest)
	}

	return destinations, nil
}

// Actions is the resolver for the actions field.
func (r *computePlatformResolver) Actions(ctx context.Context, obj *model.ComputePlatform) ([]*model.Action, error) {
	return services.GetActions(ctx)
}

// InstrumentationRules is the resolver for the instrumentationRules field.
func (r *computePlatformResolver) InstrumentationRules(ctx context.Context, obj *model.ComputePlatform) ([]*model.InstrumentationRule, error) {
	return services.GetInstrumentationRules(ctx)
}

// DataStreams is the resolver for the dataStreams field.
func (r *computePlatformResolver) DataStreams(ctx context.Context, obj *model.ComputePlatform) ([]*model.DataStream, error) {
	ns := env.GetCurrentNamespace()

	dataStreams := make([]*model.DataStream, 0)
	seen := make(map[string]bool) // prevent duplicates

	dataStreams = append(dataStreams, &model.DataStream{Name: "default"})
	seen["default"] = true

	instrumentationConfigs, err := kube.DefaultClient.OdigosClient.InstrumentationConfigs("").List(ctx, metav1.ListOptions{})
	if err != nil {
		return nil, err
	}
	for _, ic := range instrumentationConfigs.Items {
		for _, name := range services.ExtractDataStreamsFromInstrumentationConfig(&ic) {
			if !seen[*name] {
				seen[*name] = true
				dataStreams = append(dataStreams, &model.DataStream{
					Name: *name,
				})
			}
		}
	}

	destinations, err := kube.DefaultClient.OdigosClient.Destinations(ns).List(ctx, metav1.ListOptions{})
	if err != nil {
		return nil, err
	}
	for _, dest := range destinations.Items {
		for _, name := range services.ExtractDataStreamsFromDestination(dest) {
			if !seen[*name] {
				seen[*name] = true
				dataStreams = append(dataStreams, &model.DataStream{
					Name: *name,
				})
			}
		}
	}

	return dataStreams, nil
}

// Sources is the resolver for the sources field.
func (r *k8sActualNamespaceResolver) Sources(ctx context.Context, obj *model.K8sActualNamespace) ([]*model.K8sActualSource, error) {
	ns := obj.Name

	workloads, err := services.GetWorkloadsInNamespace(ctx, ns)
	if err != nil {
		return nil, err
	}

	sourceList, err := kube.DefaultClient.OdigosClient.Sources(ns).List(ctx, metav1.ListOptions{})
	if err != nil {
		return nil, err
	}

	var namespaceSource *v1alpha1.Source
	sourceObjects := make(map[string]*v1alpha1.Source)

	for _, source := range sourceList.Items {
		if model.K8sResourceKind(source.Spec.Workload.Kind) == services.WorkloadKindNamespace {
			namespaceSource = &source
		} else {
			key := fmt.Sprintf("%s/%s/%s", source.Spec.Workload.Namespace, source.Spec.Workload.Name, source.Spec.Workload.Kind)
			sourceObjects[key] = &source
		}
	}

	// Convert workloads to []*model.K8sActualSource
	sources := make([]*model.K8sActualSource, len(workloads))
	for i, workload := range workloads {
		key := fmt.Sprintf("%s/%s/%s", workload.Namespace, workload.Name, workload.Kind)
		workloadSource := sourceObjects[key]

		namespaceInstrumented := namespaceSource != nil && !namespaceSource.Spec.DisableInstrumentation
		sourceInstrumented := workloadSource != nil && !workloadSource.Spec.DisableInstrumentation
		isInstrumented := (namespaceInstrumented && (sourceInstrumented || workloadSource == nil)) || (!namespaceInstrumented && sourceInstrumented)

		sources[i] = &workload
		sources[i].Selected = &isInstrumented
		sources[i].DataStreamNames = make([]*string, 0)

		if workloadSource != nil {
			sources[i].DataStreamNames = services.ExtractDataStreamsFromSource(workloadSource, namespaceSource)
		}
	}

	return sources, nil
}

// WorkloadOdigosHealthStatus is the resolver for the workloadOdigosHealthStatus field.
func (r *k8sActualSourceResolver) WorkloadOdigosHealthStatus(ctx context.Context, obj *model.K8sActualSource) (*model.DesiredConditionStatus, error) {
	// Create a workload ID from the K8sActualSource
	workloadID := &model.K8sWorkloadID{
		Namespace: obj.Namespace,
		Kind:      obj.Kind,
		Name:      obj.Name,
	}

	// Set up loaders with a filter for this specific workload
	l := loaders.For(ctx)
	filter := &model.WorkloadFilter{
		Namespace: &obj.Namespace,
		Kind:      &obj.Kind,
		Name:      &obj.Name,
	}
	err := l.SetFilters(ctx, filter)
	if err != nil {
		return nil, err
	}

	// Get the instrumentation config
	ic, err := l.GetInstrumentationConfig(ctx, *workloadID)
	if err != nil {
		return nil, err
	}

	// Get the pods
	pods, err := l.GetWorkloadPods(ctx, *workloadID)
	if err != nil {
		return nil, err
	}

	// Calculate the health status using the same logic as K8sWorkload resolver
	conditions := []*model.DesiredConditionStatus{}
	if ic != nil {
		conditions = append(conditions, status.CalculateRuntimeInspectionStatus(ic))
		conditions = append(conditions, status.CalculateAgentInjectionEnabledStatus(ic))
		conditions = append(conditions, status.CalculateRolloutStatus(ic))
	} else {
		reasonStr := string(status.WorkloadOdigosHealthStatusReasonDisabled)
		conditions = append(conditions, &model.DesiredConditionStatus{
			Name:       status.WorkloadOdigosHealthStatus,
			Status:     model.DesiredStateProgressDisabled,
			ReasonEnum: &reasonStr,
			Message:    "workload is not marked for instrumentation",
		})
	}

	containerNamesWithOptionalPodManifestInjection := getContainerNamesWithOptionalPodManifestInjection(ic)

	// always report if agent is injected or not, even if the workload is not marked for instrumentation.
	// this is to detect if uninstrumented pods have agent injected when it should not.
	conditions = append(conditions, status.CalculateAgentInjectedStatus(ic, pods))
	aggregateContainerProcessesHealth, err := aggregateProcessesHealthForWorkload(ctx, workloadID, containerNamesWithOptionalPodManifestInjection)
	if err != nil {
		return nil, err
	}
	conditions = append(conditions, aggregateContainerProcessesHealth)

	mostSevereCondition := aggregateConditionsBySeverity(conditions)
	if mostSevereCondition == nil {
		mostSevereCondition = &model.DesiredConditionStatus{
			Name:       status.WorkloadOdigosHealthStatus,
			Status:     model.DesiredStateProgressUnknown,
			ReasonEnum: nil,
			Message:    "",
		}
	}

	// exception, if all is well, we return a special condition to denote it
	if mostSevereCondition.Status == model.DesiredStateProgressSuccess {

		workloadMetrics, ok := r.MetricsConsumer.GetSingleSourceMetrics(frontendcommon.SourceID{
			Namespace: obj.Namespace,
			Kind:      k8sconsts.WorkloadKind(obj.Kind),
			Name:      obj.Name,
		})
		var totalDataSent *int
		if ok {
			tds := int(workloadMetrics.TotalDataSent())
			totalDataSent = &tds
		}

		// consider the telemetry metrics status if relevant.
		telemetryMetrics := status.CalculateExpectingTelemetryStatus(ic, pods, totalDataSent)
		expectingTelemetry := telemetryMetrics != nil && telemetryMetrics.IsExpectingTelemetry != nil && *telemetryMetrics.IsExpectingTelemetry

		var reasonStr, message string
		if expectingTelemetry {
			if telemetryMetrics.TelemetryObservedStatus.Status == model.DesiredStateProgressSuccess {
				reasonStr = string(status.WorkloadOdigosHealthStatusReasonSuccessAndEmittingTelemetry)
				message = "source is instrumented, healthy and telemetry has been observed"
			} else {
				reasonStr = string(status.WorkloadOdigosHealthStatusReasonSuccess)
				message = "source is instrumented and healthy, no telemetry recorded yet"
			}
		} else {
			reasonStr = string(status.WorkloadOdigosHealthStatusReasonSuccess)
			message = "source is healthy, no telemetry is expected"
		}
		return &model.DesiredConditionStatus{
			Name:       status.WorkloadOdigosHealthStatus,
			Status:     model.DesiredStateProgressSuccess,
			ReasonEnum: &reasonStr,
			Message:    message,
		}, nil
	}

	return mostSevereCondition, nil
}

// UpdateAPIToken is the resolver for the updateApiToken field.
func (r *mutationResolver) UpdateAPIToken(ctx context.Context, token string) (bool, error) {
	ns := env.GetCurrentNamespace()
	err := pro.UpdateOdigosToken(ctx, kube.DefaultClient, ns, token)
	return err == nil, nil
}

// UninstrumentCluster is the resolver for the uninstrumentCluster field.
func (r *mutationResolver) UninstrumentCluster(ctx context.Context) (bool, error) {
	err := services.UninstrumentCluster(ctx)
	if err != nil {
		return false, fmt.Errorf("failed to uninstrument cluster: %v", err)
	}
	return true, nil
}

// PauseOdigos is the resolver for the pauseOdigos field.
func (r *mutationResolver) PauseOdigos(ctx context.Context) (bool, error) {
	if err := services.PauseOdigos(ctx); err != nil {
		return false, fmt.Errorf("failed to pause odigos: %v", err)
	}
	return true, nil
}

// PersistK8sNamespaces is the resolver for the persistK8sNamespaces field.
func (r *mutationResolver) PersistK8sNamespaces(ctx context.Context, namespaces []*model.PersistNamespaceItemInput) (bool, error) {
	persistObjects := []*model.PersistNamespaceSourceInput{}
	for _, namespace := range namespaces {
		persistObjects = append(persistObjects, &model.PersistNamespaceSourceInput{
			Namespace:         namespace.Namespace,
			Name:              namespace.Namespace,
			Kind:              model.K8sResourceKind(services.WorkloadKindNamespace),
			Selected:          namespace.Selected,
			CurrentStreamName: namespace.CurrentStreamName,
		})
	}

	err := services.SyncWorkloadsInNamespace(ctx, persistObjects)
	if err != nil {
		return false, fmt.Errorf("failed to sync workloads: %v", err)
	}

	return true, nil
}

// PersistK8sSources is the resolver for the persistK8sSources field.
func (r *mutationResolver) PersistK8sSources(ctx context.Context, sources []*model.PersistNamespaceSourceInput) (bool, error) {
	err := services.SyncWorkloadsInNamespace(ctx, sources)
	if err != nil {
		return false, fmt.Errorf("failed to sync workloads: %v", err)
	}

	return true, nil
}

// UpdateK8sActualSource is the resolver for the updateK8sActualSource field.
func (r *mutationResolver) UpdateK8sActualSource(ctx context.Context, sourceID model.K8sSourceID, patchSourceRequest model.PatchSourceRequestInput) (bool, error) {
	nsName := sourceID.Namespace
	workloadName := sourceID.Name
	workloadKind := sourceID.Kind
	source, err := services.GetSourceCRD(ctx, nsName, workloadName, workloadKind)
	if err != nil {
		if !apierrors.IsNotFound(err) {
			// unexpected error occurred while trying to get the source
			return false, err
		}
		source, err = services.EnsureSourceCRD(ctx, nsName, workloadName, workloadKind, patchSourceRequest.CurrentStreamName)
		if err != nil {
			// unexpected error occurred while trying to create the source
			return false, err
		}
	}

	otelServiceName := patchSourceRequest.OtelServiceName
	if otelServiceName != nil {
		_, err = services.UpdateSourceCRDSpec(ctx, nsName, source.Name, "otelServiceName", fmt.Sprintf("\"%s\"", *otelServiceName))
		if err != nil {
			// unexpected error occurred while trying to update the source
			return false, err
		}
	}

	cont := patchSourceRequest.ContainerName
	lang := patchSourceRequest.Language
	vers := patchSourceRequest.Version
	if cont != nil {
		containerOverrides := make([]v1alpha1.ContainerOverride, 0)
		// get previous overrides (except the one we are updating)
		if source.Spec.ContainerOverrides != nil {
			for _, override := range source.Spec.ContainerOverrides {
				if override.ContainerName != *cont {
					containerOverrides = append(containerOverrides, override)
				}
			}
		}
		// add the new override
		var overrideRuntimeInfo *v1alpha1.RuntimeDetailsByContainer
		if lang == nil || *lang == "" {
			overrideRuntimeInfo = nil
		} else {
			runtimeVersion := ""
			if vers != nil && *vers != "" {
				if common.GetVersion(*vers) == nil {
					return false, fmt.Errorf("invalid runtime version: %s", *vers)
				}
				runtimeVersion = *vers
			}
			overrideRuntimeInfo = &v1alpha1.RuntimeDetailsByContainer{
				ContainerName:  *cont,
				Language:       common.ProgrammingLanguage(*lang),
				RuntimeVersion: runtimeVersion,
			}
		}
		containerOverrides = append(containerOverrides, v1alpha1.ContainerOverride{
			ContainerName:  *cont,
			OtelDistroName: patchSourceRequest.OtelDistroName,
			RuntimeInfo:    overrideRuntimeInfo,
		})
		// patch the source with the new container overrides
		patchBytes, err := json.Marshal([]map[string]interface{}{
			{
				"op":    "replace",
				"path":  "/spec/containerOverrides",
				"value": containerOverrides,
			},
		})
		if err != nil {
			return false, err
		}
		_, err = kube.DefaultClient.OdigosClient.Sources(nsName).Patch(ctx, source.Name, types.JSONPatchType, []byte(patchBytes), metav1.PatchOptions{})
		if err != nil {
			return false, err
		}
	}

	return true, nil
}

// CreateNewDestination is the resolver for the createNewDestination field.
func (r *mutationResolver) CreateNewDestination(ctx context.Context, destination model.DestinationInput) (*model.Destination, error) {
	ns := env.GetCurrentNamespace()
	destType := common.DestinationType(destination.Type)
	destName := destination.Name

	destTypeConfig, err := services.GetDestinationTypeConfig(destType)
	if err != nil {
		return nil, fmt.Errorf("destination type %s not found", destType)
	}

	// Convert fields to map[string]string
	fieldsMap := make(map[string]string)
	for _, field := range destination.Fields {
		fieldsMap[field.Key] = field.Value
	}

	errors := services.VerifyDestinationDataScheme(destType, destTypeConfig, fieldsMap)
	if len(errors) > 0 {
		return nil, fmt.Errorf("invalid destination data scheme: %v", errors)
	}

	dataField, secretFields := services.TransformFieldsToDataAndSecrets(destTypeConfig, fieldsMap)
	generateNamePrefix := "odigos.io.dest." + string(destType) + "-"

	disabled := false
	if destination.Disabled != nil {
		disabled = *destination.Disabled
	}

	k8sDestination := v1alpha1.Destination{
		ObjectMeta: metav1.ObjectMeta{
			GenerateName: generateNamePrefix,
		},
		Spec: v1alpha1.DestinationSpec{
			Type:            destType,
			DestinationName: destName,
			Data:            dataField,
			Signals:         services.ExportedSignalsObjectToSlice(destination.ExportedSignals),
			Disabled:        &disabled,
		},
	}
	if destination.CurrentStreamName != "" {
		k8sDestination.Spec.SourceSelector = &v1alpha1.SourceSelector{
			DataStreams: []string{destination.CurrentStreamName},
		}
	}

	createSecret := len(secretFields) > 0
	if createSecret {
		secretRef, err := services.CreateDestinationSecret(ctx, destType, secretFields, ns)
		if err != nil {
			return nil, err
		}
		k8sDestination.Spec.SecretRef = secretRef
	}

	dest, err := services.CreateResourceWithGenerateName(ctx, func() (*v1alpha1.Destination, error) {
		return kube.DefaultClient.OdigosClient.Destinations(ns).Create(ctx, &k8sDestination, metav1.CreateOptions{})
	})
	if err != nil {
		if createSecret {
			kube.DefaultClient.CoreV1().Secrets(ns).Delete(ctx, destName, metav1.DeleteOptions{})
		}
		return nil, err
	}

	if dest.Spec.SecretRef != nil {
		err = services.AddDestinationOwnerReferenceToSecret(ctx, ns, dest)
		if err != nil {
			return nil, err
		}
	}

	secretFieldsMap, err := services.GetDestinationSecretFields(ctx, ns, dest)
	if err != nil {
		return nil, err
	}

	endpointDest := services.K8sDestinationToEndpointFormat(*dest, secretFieldsMap)
	return &endpointDest, nil
}

// UpdateDestination is the resolver for the updateDestination field.
func (r *mutationResolver) UpdateDestination(ctx context.Context, id string, destination model.DestinationInput) (*model.Destination, error) {
	ns := env.GetCurrentNamespace()
	destType := common.DestinationType(destination.Type)
	destName := destination.Name

	// Get the destination type configuration
	destTypeConfig, err := services.GetDestinationTypeConfig(destType)
	if err != nil {
		return nil, fmt.Errorf("destination type %s not found: %v", destType, err)
	}

	// Convert fields from input to map[string]string
	fields := make(map[string]string)
	for _, field := range destination.Fields {
		fields[field.Key] = field.Value
	}

	// Validate the destination data schema
	validationErrors := services.VerifyDestinationDataScheme(destType, destTypeConfig, fields)
	if len(validationErrors) > 0 {
		var errMsg string
		for _, e := range validationErrors {
			errMsg += e.Error() + "; "
		}
		return nil, fmt.Errorf("validation errors: %s", errMsg)
	}

	// Separate data fields and secret fields
	dataFields, secretFields := services.TransformFieldsToDataAndSecrets(destTypeConfig, fields)

	// Retrieve the existing destination
	dest, err := kube.DefaultClient.OdigosClient.Destinations(ns).Get(ctx, id, metav1.GetOptions{})
	if err != nil {
		return nil, fmt.Errorf("failed to get destination: %v", err)
	}

	// Handle secrets
	destUpdateHasSecrets := len(secretFields) > 0
	destCurrentlyHasSecrets := dest.Spec.SecretRef != nil

	if !destUpdateHasSecrets && destCurrentlyHasSecrets {
		// Delete the secret if it's not needed anymore
		err := kube.DefaultClient.CoreV1().Secrets(ns).Delete(ctx, dest.Spec.SecretRef.Name, metav1.DeleteOptions{})
		if err != nil {
			return nil, fmt.Errorf("failed to delete secret: %v", err)
		}
		dest.Spec.SecretRef = nil
	} else if destUpdateHasSecrets && !destCurrentlyHasSecrets {
		// Create the secret if it was added in this update
		secretRef, err := services.CreateDestinationSecret(ctx, destType, secretFields, ns)
		if err != nil {
			return nil, fmt.Errorf("failed to create secret: %v", err)
		}
		dest.Spec.SecretRef = secretRef
		// Add owner reference to the secret
		err = services.AddDestinationOwnerReferenceToSecret(ctx, ns, dest)
		if err != nil {
			return nil, fmt.Errorf("failed to add owner reference to secret: %v", err)
		}
	} else if destUpdateHasSecrets && destCurrentlyHasSecrets {
		// Update the secret in case it is modified
		secret, err := kube.DefaultClient.CoreV1().Secrets(ns).Get(ctx, dest.Spec.SecretRef.Name, metav1.GetOptions{})
		if err != nil {
			return nil, fmt.Errorf("failed to get secret: %v", err)
		}
		origSecret := secret.DeepCopy()

		secret.StringData = secretFields
		_, err = kube.DefaultClient.CoreV1().Secrets(ns).Update(ctx, secret, metav1.UpdateOptions{})
		if err != nil {
			// Rollback secret if needed
			_, rollbackErr := kube.DefaultClient.CoreV1().Secrets(ns).Update(ctx, origSecret, metav1.UpdateOptions{})
			if rollbackErr != nil {
				fmt.Printf("Failed to rollback secret: %v\n", rollbackErr)
			}
			return nil, fmt.Errorf("failed to update secret: %v", err)
		}
	}

	// Update the destination specification
	dest.Spec.Type = destType
	dest.Spec.DestinationName = destName
	dest.Spec.Data = dataFields
	dest.Spec.Signals = services.ExportedSignalsObjectToSlice(destination.ExportedSignals)
	if destination.Disabled != nil {
		dest.Spec.Disabled = destination.Disabled
	}

	if destination.CurrentStreamName != "" {
		// Init empty struct if nil
		if dest.Spec.SourceSelector == nil {
			dest.Spec.SourceSelector = &v1alpha1.SourceSelector{DataStreams: make([]string, 0)}
		}
		// Init empty slice if nil
		if dest.Spec.SourceSelector.DataStreams == nil {
			dest.Spec.SourceSelector.DataStreams = make([]string, 0)
		}
		// Add the current stream name to the source selector
		if !services.ArrayContains(dest.Spec.SourceSelector.DataStreams, destination.CurrentStreamName) {
			dest.Spec.SourceSelector.DataStreams = append(dest.Spec.SourceSelector.DataStreams, destination.CurrentStreamName)
		}
	}

	// Update the destination in Kubernetes
	updatedDest, err := kube.DefaultClient.OdigosClient.Destinations(ns).Update(ctx, dest, metav1.UpdateOptions{})
	if err != nil {
		return nil, fmt.Errorf("failed to update destination: %v", err)
	}

	// Get the secret fields for the updated destination
	secretFields, err = services.GetDestinationSecretFields(ctx, ns, updatedDest)
	if err != nil {
		return nil, fmt.Errorf("failed to get secret fields: %v", err)
	}

	// Convert the updated destination to the GraphQL model
	resp := services.K8sDestinationToEndpointFormat(*updatedDest, secretFields)

	return &resp, nil
}

// DeleteDestination is the resolver for the deleteDestination field.
func (r *mutationResolver) DeleteDestination(ctx context.Context, id string, currentStreamName string) (bool, error) {
	ns := env.GetCurrentNamespace()

	dest, err := kube.DefaultClient.OdigosClient.Destinations(ns).Get(ctx, id, metav1.GetOptions{})
	if err != nil {
		return false, fmt.Errorf("failed to get destination: %v", err)
	}

	err = services.DeleteDestinationOrRemoveStreamName(ctx, dest, currentStreamName)
	if err != nil {
		return false, fmt.Errorf("failed to delete destination or remove stream name: %v", err)
	}

	return true, nil
}

// TestConnectionForDestination is the resolver for the testConnectionForDestination field.
func (r *mutationResolver) TestConnectionForDestination(ctx context.Context, destination model.DestinationInput) (*model.TestConnectionResponse, error) {
	destType := common.DestinationType(destination.Type)

	destConfig, err := services.GetDestinationTypeConfig(destType)
	if err != nil {
		return nil, err
	}

	if !destConfig.Spec.TestConnectionSupported {
		return nil, fmt.Errorf("destination type %s does not support test connection", destination.Type)
	}

	// Validate URLs for test connection based on AllowedTestConnectionHosts configuration
	err = services.ValidateDestinationURLs(ctx, destination)
	if err != nil {
		errMsg := err.Error()
		reason := string(testconnection.FailedToConnect)
		return &model.TestConnectionResponse{
			Succeeded:       false,
			StatusCode:      403,
			DestinationType: (*string)(&destType),
			Message:         &errMsg,
			Reason:          &reason,
		}, nil
	}

	configurer, err := testconnection.ConvertDestinationToConfigurer(destination)
	if err != nil {
		return nil, err
	}

	// temporary workaround for honeycomb which does not allow empty payload in otlp export.
	// they have a ticket open to fix that, but for now, we are using a specific honeycomb api for test connection
	// "Permanent error: rpc error: code = InvalidArgument desc = request body should not be empty"
	// TODO: remove once honeycomb fixes the issue
	var res testconnection.TestConnectionResult
	if destType == common.HoneycombDestinationType {
		res = testconnection.TestConnectionHoneycomb(ctx, configurer)
	} else {
		res = testconnection.TestConnection(ctx, configurer)
	}

	if !res.Succeeded {
		return &model.TestConnectionResponse{
			Succeeded:       false,
			StatusCode:      res.StatusCode,
			DestinationType: (*string)(&res.DestinationType),
			Message:         &res.Message,
			Reason:          (*string)(&res.Reason),
		}, nil
	}

	return &model.TestConnectionResponse{
		Succeeded:       true,
		StatusCode:      200,
		DestinationType: (*string)(&res.DestinationType),
	}, nil
}

// CreateAction is the resolver for the createAction field.
func (r *mutationResolver) CreateAction(ctx context.Context, action model.ActionInput) (*model.Action, error) {
	return services.CreateAction(ctx, action)
}

// UpdateAction is the resolver for the updateAction field.
func (r *mutationResolver) UpdateAction(ctx context.Context, id string, action model.ActionInput) (*model.Action, error) {
	return services.UpdateAction(ctx, id, action)
}

// DeleteAction is the resolver for the deleteAction field.
func (r *mutationResolver) DeleteAction(ctx context.Context, id string, actionType string) (bool, error) {
	return services.DeleteAction(ctx, id)
}

// CreateInstrumentationRule is the resolver for the createInstrumentationRule field.
func (r *mutationResolver) CreateInstrumentationRule(ctx context.Context, instrumentationRule model.InstrumentationRuleInput) (*model.InstrumentationRule, error) {
	return services.CreateInstrumentationRule(ctx, instrumentationRule)
}

// UpdateInstrumentationRule is the resolver for the updateInstrumentationRule field.
func (r *mutationResolver) UpdateInstrumentationRule(ctx context.Context, ruleID string, instrumentationRule model.InstrumentationRuleInput) (*model.InstrumentationRule, error) {
	return services.UpdateInstrumentationRule(ctx, ruleID, instrumentationRule)
}

// DeleteInstrumentationRule is the resolver for the deleteInstrumentationRule field.
func (r *mutationResolver) DeleteInstrumentationRule(ctx context.Context, ruleID string) (bool, error) {
	_, err := services.DeleteInstrumentationRule(ctx, ruleID)
	if err != nil {
		return false, err
	}

	return true, nil
}

// UpdateDataStream is the resolver for the updateDataStream field.
func (r *mutationResolver) UpdateDataStream(ctx context.Context, id string, dataStream model.DataStreamInput) (*model.DataStream, error) {
	idNew := dataStream.Name
	if id == idNew {
		return &model.DataStream{Name: idNew}, nil
	}

	ns := env.GetCurrentNamespace()
	kubeClient := kube.DefaultClient.OdigosClient

	destinations, err := kubeClient.Destinations(ns).List(ctx, metav1.ListOptions{})
	if err != nil {
		return nil, err
	}
	err = services.UpdateDestinationsCurrentStreamName(ctx, destinations, id, idNew)
	if err != nil {
		return nil, fmt.Errorf("failed to update destinations: %v", err)
	}

	sources, err := kubeClient.Sources("").List(ctx, metav1.ListOptions{})
	if err != nil {
		return nil, err
	}
	err = services.UpdateSourcesCurrentStreamName(ctx, sources, id, idNew)
	if err != nil {
		return nil, fmt.Errorf("failed to update sources: %v", err)
	}

	return &model.DataStream{Name: idNew}, nil
}

// DeleteDataStream is the resolver for the deleteDataStream field.
func (r *mutationResolver) DeleteDataStream(ctx context.Context, id string) (bool, error) {
	kubeClient := kube.DefaultClient.OdigosClient

	destinations, err := kubeClient.Destinations(env.GetCurrentNamespace()).List(ctx, metav1.ListOptions{})
	if err != nil {
		return false, err
	}
	err = services.DeleteDestinationsOrRemoveStreamName(ctx, destinations, id)
	if err != nil {
		return false, fmt.Errorf("failed to delete destinations or remove stream name: %v", err)
	}

	sources, err := kubeClient.Sources("").List(ctx, metav1.ListOptions{})
	if err != nil {
		return false, err
	}
	err = services.DeleteSourcesOrRemoveStreamName(ctx, sources, id)
	if err != nil {
		return false, fmt.Errorf("failed to delete sources or remove stream name: %v", err)
	}

	return true, nil
}

// RestartWorkloads is the resolver for the restartWorkloads field.
func (r *mutationResolver) RestartWorkloads(ctx context.Context, sourceIds []*model.K8sSourceID) (bool, error) {
	err := services.WithGoroutine(ctx, len(sourceIds), func(goFunc func(func() error)) {
		for _, sourceID := range sourceIds {
			goFunc(func() error {
				err := services.RolloutRestartWorkload(ctx, sourceID.Namespace, sourceID.Name, sourceID.Kind)
				if err != nil {
					return fmt.Errorf("failed to restart workload %s/%s/%s: %v", sourceID.Namespace, sourceID.Name, sourceID.Kind, err)
				}
				return nil
			})
		}
	})

	if err != nil {
		return false, err
	}
	return true, nil
}

// DeleteCentralProxy is the resolver for the deleteCentralProxy field.
func (r *mutationResolver) DeleteCentralProxy(ctx context.Context) (bool, error) {
	return services.DeleteCentralProxy(ctx)
}

// ComputePlatform is the resolver for the computePlatform field.
func (r *queryResolver) ComputePlatform(ctx context.Context) (*model.ComputePlatform, error) {
	return &model.ComputePlatform{
		ComputePlatformType: model.ComputePlatformTypeK8s,
	}, nil
}

// K8sManifest is the resolver for the k8sManifest field.
func (r *queryResolver) K8sManifest(ctx context.Context, namespace string, kind model.K8sResourceKind, name string) (string, error) {
	return services.K8sManifest(ctx, namespace, kind, name)
}

// DestinationCategories is the resolver for the destinationCategories field.
func (r *queryResolver) DestinationCategories(ctx context.Context) (*model.GetDestinationCategories, error) {
	destTypes := services.GetDestinationCategories()

	return &destTypes, nil
}

// PotentialDestinations is the resolver for the potentialDestinations field.
func (r *queryResolver) PotentialDestinations(ctx context.Context) ([]*model.DestinationDetails, error) {
	result := make([]*model.DestinationDetails, 0)

	potentialDestinations := services.PotentialDestinations(ctx)
	if potentialDestinations == nil {
		return result, nil
	}

	for _, dest := range potentialDestinations {
		fieldsString, err := json.Marshal(dest.Fields)
		if err != nil {
			return nil, fmt.Errorf("error marshalling fields: %v", err)
		}

		result = append(result, &model.DestinationDetails{
			Type:   string(dest.Type),
			Fields: string(fieldsString),
		})
	}

	return result, nil
}

// GetOverviewMetrics is the resolver for the getOverviewMetrics field.
func (r *queryResolver) GetOverviewMetrics(ctx context.Context) (*model.OverviewMetricsResponse, error) {
	if r.MetricsConsumer == nil {
		return nil, fmt.Errorf("metrics consumer not initialized")
	}

	sourcesMetrics := r.MetricsConsumer.GetSourcesMetrics()
	destinationsMetrics := r.MetricsConsumer.GetDestinationsMetrics()

	var sourcesResp []*model.SingleSourceMetricsResponse
	for sID, metric := range sourcesMetrics {
		sourcesResp = append(sourcesResp, &model.SingleSourceMetricsResponse{
			Namespace:     sID.Namespace,
			Kind:          string(sID.Kind),
			Name:          sID.Name,
			TotalDataSent: int(metric.TotalDataSent()),
			Throughput:    int(metric.TotalThroughput()),
		})
	}

	var destinationsResp []*model.SingleDestinationMetricsResponse
	for destId, metric := range destinationsMetrics {
		destinationsResp = append(destinationsResp, &model.SingleDestinationMetricsResponse{
			ID:            destId,
			TotalDataSent: int(metric.TotalDataSent()),
			Throughput:    int(metric.TotalThroughput()),
		})
	}

	return &model.OverviewMetricsResponse{
		Sources:      sourcesResp,
		Destinations: destinationsResp,
	}, nil
}

// GetServiceMap is the resolver for the getServiceMap field.
func (r *queryResolver) GetServiceMap(ctx context.Context) (*model.ServiceMap, error) {
	if r.MetricsConsumer == nil {
		return nil, fmt.Errorf("metrics consumer not initialized")
	}

	serviceMap := r.MetricsConsumer.GetServiceGraphEdges()
	services := make([]*model.ServiceMapFromSource, 0)

	for serviceName, toServices := range serviceMap {
		to := make([]*model.ServiceMapToSource, 0)

		for toServiceName, info := range toServices {
			to = append(to, &model.ServiceMapToSource{
				ServiceName: toServiceName,
				Requests:    int(info.RequestCount),
				DateTime:    info.LastUpdated.Format(time.RFC3339),
			})
		}

		services = append(services, &model.ServiceMapFromSource{
			ServiceName: serviceName,
			Services:    to,
		})
	}

	return &model.ServiceMap{Services: services}, nil
}

// DescribeOdigos is the resolver for the describeOdigos field.
func (r *queryResolver) DescribeOdigos(ctx context.Context) (*model.OdigosAnalyze, error) {
	return odigos_describe.GetOdigosDescription(ctx)
}

// DescribeSource is the resolver for the describeSource field.
func (r *queryResolver) DescribeSource(ctx context.Context, namespace string, kind string, name string) (*model.SourceAnalyze, error) {
	return source_describe.GetSourceDescription(ctx, namespace, kind, name)
}

// SourceConditions is the resolver for the sourceConditions field.
func (r *queryResolver) SourceConditions(ctx context.Context) ([]*model.SourceConditions, error) {
	return services.GetOtherConditionsForSources(ctx, "", "", "")
}

// InstrumentationInstanceComponents is the resolver for the instrumentationInstanceComponents field.
func (r *queryResolver) InstrumentationInstanceComponents(ctx context.Context, namespace string, kind string, name string) ([]*model.InstrumentationInstanceComponent, error) {
	instances, err := services.GetInstrumentationInstances(ctx, namespace, name, kind)
	if err != nil {
		return nil, err
	}

	// Return empty components if no instrumentation instances found
	if len(instances) == 0 {
		return []*model.InstrumentationInstanceComponent{}, nil
	}

	components := make([]*model.InstrumentationInstanceComponent, 0)
	seenNames := make(map[string]bool)

	for _, instance := range instances {
		for _, component := range instance.Status.Components {
			if _, ok := seenNames[component.Name]; !ok {
				seenNames[component.Name] = true

				var typeStr *string
				if component.Type != "" {
					t := string(component.Type)
					typeStr = &t
				}

				var healthy *bool
				if component.Healthy != nil {
					healthy = component.Healthy
				}

				var lastStatusTime *string
				if !component.LastStatusTime.IsZero() {
					t := component.LastStatusTime.Format(time.RFC3339)
					lastStatusTime = &t
				}

				nonIdentifyingAttributes := make([]*model.NonIdentifyingAttribute, 0)
				for _, attribute := range component.NonIdentifyingAttributes {
					nonIdentifyingAttributes = append(nonIdentifyingAttributes, &model.NonIdentifyingAttribute{
						Key:   attribute.Key,
						Value: attribute.Value,
					})
				}

				components = append(components, &model.InstrumentationInstanceComponent{
					Name:                     component.Name,
					Type:                     typeStr,
					Healthy:                  healthy,
					Message:                  &component.Message,
					LastStatusTime:           lastStatusTime,
					NonIdentifyingAttributes: nonIdentifyingAttributes,
				})
			}
		}
	}

	return components, nil
}

// Workloads is the resolver for the workloads field.
func (r *queryResolver) Workloads(ctx context.Context, filter *model.WorkloadFilter) ([]*model.K8sWorkload, error) {
	l := loaders.For(ctx)
	err := l.SetFilters(ctx, filter)
	if err != nil {
		return nil, err
	}
	sources := make([]*model.K8sWorkload, 0)
	for _, sourceId := range l.GetWorkloadIds() {
		sources = append(sources, &model.K8sWorkload{
			ID: &sourceId,
		})
	}
	return sources, nil
}

// Diagnose is the resolver for the diagnose field.
func (r *queryResolver) Diagnose(ctx context.Context, input *model.DiagnoseInput, dryRun *bool) (*model.DiagnoseResponse, error) {
	return services.DiagnoseGraphQL(ctx, input, dryRun)
}

// ComputePlatform returns ComputePlatformResolver implementation.
func (r *Resolver) ComputePlatform() ComputePlatformResolver { return &computePlatformResolver{r} }

// K8sActualNamespace returns K8sActualNamespaceResolver implementation.
func (r *Resolver) K8sActualNamespace() K8sActualNamespaceResolver {
	return &k8sActualNamespaceResolver{r}
}

// K8sActualSource returns K8sActualSourceResolver implementation.
func (r *Resolver) K8sActualSource() K8sActualSourceResolver { return &k8sActualSourceResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type computePlatformResolver struct{ *Resolver }
type k8sActualNamespaceResolver struct{ *Resolver }
type k8sActualSourceResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

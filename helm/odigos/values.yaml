# User should be specifying the signals they want to collect.
signals:
  - traces
  - metrics
  - logs

image:
  tag: ''
imagePullSecrets: []

# By default, images are pulled from odigos registry at `registry.odigos.io`
# If you use custom or internal registry to serve in your cluster, you can set the imagePrefix to your registry.
# For example, if you set imagePrefix to `myregistry.io/odigos`, the images will be pulled from `myregistry.io/odigos/odigos-<component>:<tag>`
imagePrefix:

# Per-component image overrides. When set, these full image URLs take precedence over
# the constructed image name (imagePrefix + component + tag).
# This is primarily used by the OpenShift operator with RELATED_IMAGE_* env vars.
# Example:
#   images:
#     autoscaler: registry.connect.redhat.com/odigos/odigos-autoscaler-ubi9:v1.0.0
#     collector: registry.connect.redhat.com/odigos/odigos-collector-ubi9:v1.0.0
# Supported component names: autoscaler, collector, ui, instrumentor, enterprise-instrumentor,
#   odiglet, enterprise-odiglet, scheduler, agents, enterprise-agents
images: {}

# namespaces list not to show in odigos ui
# set by default: odigos-system, kube-system, local-path-storage, istio-system, linkerd, kube-node-lease
# you can add additional namespaces to ignore by adding them to the list
ignoredNamespaces:

# Whether to automatically ignore the namespace where Odigos is installed.
# By default (true), the Odigos namespace is automatically added to ignoredNamespaces.
# Set to false to allow the Odigos namespace to be visible in the UI.
# Default: true
ignoreOdigosNamespace: true

# container names to never instrument
# useful for sidecars which are not interesting to be instrumented
# set by default: istio-proxy, vault-agent, filebeat, linkerd-proxy, fluentd, akeyless-init
# you can add additional container names to ignore by adding them to the list
ignoredContainers:

# Name of the cluster, will be used to identify this cluster in the centralized backend
clusterName: ''

userInstrumentationEnvs:
  # Configuration for OpenTelemetry (OTEL) agents instrumentation.
  # These settings enable and configure OTEL agents for programming languages supported by Odigos.
  # See the official OTEL documentation for language-specific configuration details:
  # https://opentelemetry.io/docs/zero-code/
  # Example:
  # languages:
  #   java:
  #     enabled: true
  #     env:
  #       OTEL_INSTRUMENTATION_COMMON_EXPERIMENTAL_VIEW_TELEMETRY_ENABLED: "true"
  # Note: For eBPF-based distributions, exporting and batching cannot be configured here, as they are managed by the Odiglet.
  # Warning: This is an advanced feature. Only modify these settings if you are familiar with OTEL and its implications.
  languages:
    java:
      enabled: false
      env: {}
    python:
      enabled: false
      env: {}
    nodejs:
      enabled: false
      env: {}
    go:
      enabled: false
      env: {}
    dotnet:
      enabled: false
      env: {}
    php:
      enabled: false
      env: {}

# Sizing Configurations size_s, size_m, size_l are pre-defined configurations designed to simplify pipeline configurations.
# The default value is 'size_m', which is the medium size configuration.
# See https://docs.odigos.io/pipeline/configuration#1-using-sizing-configuration for more details.
ResourceSizePreset: size_m

# HYBRID CONFIGURATION APPROACH:
# By default, all values below are automatically set based on the ResourceSizePreset above.
# Uncomment and modify any value to override the automatic sizing for that specific parameter.
#
# IMPORTANT CONSTRAINTS:
# 1. minReplicas must be less or equal to maxReplicas
# 2. If you set limitMemoryMiB without requestMemoryMiB, request will equal limit
# 3. If you set requestMemoryMiB without limitMemoryMiB, limit will equal request
# 4. Same logic applies to CPU settings
collectorGateway:
  # the memory request for the cluster gateway collector deployment.
  # it will be embedded in the deployment as a resource request
  # of the form "memory: <value>Mi".
  # default value is 500Mi
  # If you set only requestMemoryMiB, the limitMemoryMiB will be set to the same value.
  # requestMemoryMiB: 625

  # the memory limit for the cluster gateway collector deployment.
  # it will be embedded in the deployment as a resource limit
  # of the form "memory: <value>Mi".
  # default value is 625Mi
  # If you set only limitMemoryMiB, the requestMemoryMiB will be set to the same value.
  # limitMemoryMiB: 625

  # the CPU request for the cluster gateway collector deployment.
  # it will be embedded in the deployment as a resource request
  # of the form "cpu: <value>m".
  # default value is 500m
  # If you set only requestCPUm, the limitCPUm will be set to the same value.
  # requestCPUm: 500

  # the CPU limit for the cluster gateway collector deployment.
  # it will be embedded in the deployment as a resource limit
  # of the form "cpu: <value>m".
  # default value is 1000m
  # If you set only limitCPUm, the requestCPUm will be set to the same value.
  # limitCPUm: 1000

  # The number of replicas for the cluster gateway collector deployment.
  # Also uses in MinReplicas the HPA config.
  # minReplicas: 1
  # The maxReplicas in the HPA config.
  # maxReplicas: 10

  # sets the "limit_mib" parameter in the memory limiter configuration for the collector gateway.
  # it is the hard limit after which a force garbage collection will be performed.
  # if not set, it will be 50Mi below the memory limit.
  # memoryLimiterLimitMiB: 575

  # sets the "spike_limit_mib" parameter in the memory limiter configuration for the collector gateway.
  # note that this is not the processor soft limit, but the diff in MiB between the hard limit and the soft limit.
  # if not specified, this value will be set to 20% of the hard limit (so the soft limit will be 80% of the hard limit).
  # memoryLimiterSpikeLimitMiB: 110

  # the GOMEMLIMIT environment variable value for the collector gateway deployment.
  # this is when go runtime will start garbage collection.
  # if not specified, it will be set to 80% of the hard limit of the memory limiter.
  # goMemLimitMiB: 460

  # Service Graph settings
  # Service Graph is a feature that allows you to visualize the service graph of your application.
  # It is enabled by default and can be disabled by setting the disabled flag to true.
  serviceGraphDisabled: false
  # Cluster Metrics settings
  # Cluster Metrics is a feature that allows you to enable the cluster metrics.
  # [https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/receiver/k8sclusterreceiver]
  # It is disabled by default and can be enabled by setting the enabled flag to true.
  clusterMetricsEnabled: false

  # for destinations that uses https for exporting data, this value can be used to set the address for an https proxy.
  # when unset or empty, no proxy will be used.
  # httpsProxyAddress: ''


  # Node selector for the cluster gateway collector deployment.
  # Uncomment to override the global nodeSelector (values.nodeSelector) for this component
  # nodeSelector:
  #   kubernetes.io/os: linux

# Settings for Odigos data-collection (node) Collectors
collectorNode:
  # The port to use for exposing the collector's own metrics as a prometheus endpoint.
  # This can be used to resolve conflicting ports when a collector is using the host network.
  collectorOwnMetricsPort: 55682

  # RequestMemoryMiB is the memory request for the node collector daemonset.
  # it will be embedded in the daemonset as a resource request of the form "memory: <value>Mi"
  # default value is 250Mi
  # If you set only requestMemoryMiB, the limitMemoryMiB will be set to the same value.
  # requestMemoryMiB: 250

  # LimitMemoryMiB is the memory limit for the node collector daemonset.
  # it will be embedded in the daemonset as a resource limit of the form "memory: <value>Mi"
  # default value is 500Mi
  # If you set only limitMemoryMiB, the requestMemoryMiB will be set to the same value.
  # limitMemoryMiB: 500

  # the CPU request for the node collector daemonset.
  # it will be embedded in the daemonset as a resource request
  # of the form "cpu: <value>m".
  # default value is 250m
  # If you set only requestCPUm, the limitCPUm will be set to the same value.
  # requestCPUm: 250

  # the CPU limit for the node collector daemonset.
  # it will be embedded in the daemonset as a resource limit
  # of the form "cpu: <value>m".
  # default value is 500m
  # If you set only limitCPUm, the requestCPUm will be set to the same value.
  # limitCPUm: 500

  # this parameter sets the "limit_mib" parameter in the memory limiter configuration for the node collector.
  # it is the hard limit after which a force garbage collection will be performed.
  # if not set, it will be 50Mi below the memory limit.
  # memoryLimiterLimitMiB: 450

  # this parameter sets the "spike_limit_mib" parameter in the memory limiter configuration for the node collector.
  # note that this is not the processor soft limit, but the diff in Mib between the hard limit and the soft limit.
  # if not set, this will be set to 20% of the hard limit (so the soft limit will be 80% of the hard limit).
  # memoryLimiterSpikeLimitMiB: 90

  # the GOMEMLIMIT environment variable value for the node collector daemonset.
  # this is when go runtime will start garbage collection.
  # if not specified, it will be set to 80% of the hard limit of the memory limiter.
  # goMemLimitMiB: 360

  # this configuration is used for logs collection where '/var/log' in a k8s node is a symlink
  # to some other directory (for example, '/mnt/var/log')
  k8sNodeLogsDirectory: ''


  otlpExporterConfiguration:
    # EnableDataCompression is a feature that allows you to enable data compression before sending data to the Gateway collector.
    # It is disabled by default and can be enabled by setting the enabled flag to true.
    enableDataCompression: false
    # Time to wait per individual attempt to send data to a backend
    timeout: 5s
    retryOnFailure:
      # Whether to retry on failure, by default it is enabled.
      enabled: true
      # Time to wait after the first failure before retrying; ignored if `enabled` is `false`.
      initialInterval: 5s
      # Is the upper bound on backoff; ignored if `enabled` is `false`.
      maxInterval: 30s
      # Is the maximum amount of time spent trying to send a batch; ignored if `enabled` is `false`.
      # If set to 0, the retry will continue indefinitely until the data is sent successfully.
      maxElapsedTime: 300s


autoscaler:
  # Uncomment to override the global nodeSelector (values.nodeSelector) for this component
  # nodeSelector:
  #   kubernetes.io/os: linux
  tolerations: []
  affinity: {}
  resources:
    requests:
      cpu: 10m
      memory: 64Mi
    limits:
      cpu: 500m
      memory: 512Mi
  # Priority class name. Set to use your existing cluster priority classes.
  # priorityClassName: ''

scheduler:
  # Uncomment to override the global nodeSelector (values.nodeSelector) for this component
  # nodeSelector:
  #   kubernetes.io/os: linux
  tolerations: []
  affinity: {}
  resources:
    requests:
      cpu: 10m
      memory: 64Mi
    limits:
      cpu: 500m
      memory: 512Mi
  # Priority class name. Set to use your existing cluster priority classes.
  # priorityClassName: ''

ui:
  # Uncomment to override the global nodeSelector (values.nodeSelector) for this component
  # nodeSelector:
  #   kubernetes.io/os: linux
  tolerations: []
  affinity: {}
  resources:
    requests:
      cpu: 10m
      memory: 64Mi
    limits:
      cpu: 500m
      memory: 512Mi
  # Priority class name. Set to use your existing cluster priority classes.
  # priorityClassName: ''

  # uiMode: 'default' or 'readonly'
  #  - This flag controls whether the UI should be in read-only mode.
  #  - Setting this to "readonly" will disable the ability to create, update, or delete objects in the UI.
  #  - If not set, the UI will be in default mode.
  uiMode: 'default'
  # uiPaginationLimit:
  #  - This flag controls the number of items to fetch per paginated-batch in the UI.
  #  - If not set, the UI will fetch 100 items per paginated-batch.
  uiPaginationLimit: 0
  # uiRemoteUrl:
  #  - This flag sets the URL of the remote UI (e.g. https://my-odigos-ui.com).
  #  - If not set, the UI will default to the local UI.
  #  - This is useful when you are hosting the Odigos UI on a custom/remote URL, and require OIDC authentication.
  uiRemoteUrl: ''
  # oidcTenantUrl:
  #  - This flag sets the URL of the OIDC tenant (e.g. https://my-oidc-tenant.com).
  #  - If not set, the UI will not process OIDC authentication.
  oidcTenantUrl: ''
  # oidcClientId:
  #  - This flag sets the client ID of the OIDC application.
  #  - If not set, the UI will not process OIDC authentication.
  oidcClientId: ''
  # oidcClientSecret:
  #  - This flag sets the client secret of the OIDC application.
  #  - If not set, the UI will not process OIDC authentication.
  oidcClientSecret: ''
  centralBackendURL: ''

instrumentor:
  # which mount method to use for odigos agent directory
  # k8s-virtual-device: default method using a virtual device
  # k8s-host-path: alternative which uses hostPath volume (recommended if supported, requires hostPath volume to be enabled in the cluster)
  # k8s-init-container: alternative which uses an init container to copy the agent files to the shared volume
  mountMethod: ''
  # checkDeviceHealthBeforeInjection is relevant only when mountMethod is k8s-virtual-device.
  # before injecting odigos agent into a new pod, it will check that all odiglet "deviceplugin"
  # containers are not in crash loop backoff.
  # this is to avoid adding a device (as resource request on a container)
  # where an odiglet might not be able to provide the device on the node and fail k8s scheduling for instrumented pods on all nodes.
  checkDeviceHealthBeforeInjection: false
  # Resource configuration for the init container that is injected into user pods
  # when using the k8s-init-container mount method.
  # The init container is responsible for copying the instrumentation agents to the shared volume.
  agentsInitContainerResources:
    requests:
      cpu: 300m
      memory: 300Mi
    limits:
      cpu: 300m
      memory: 300Mi
  # Uncomment to override the global nodeSelector (values.nodeSelector) for this component
  # nodeSelector:
  #   kubernetes.io/os: linux
  tolerations: []
  affinity: {}
  resources:
    requests:
      cpu: 10m
      memory: 64Mi
    limits:
      cpu: 500m
      memory: 512Mi
  # Priority class name. Set to use your existing cluster priority classes.
  # priorityClassName: ''
  # how to add the required environment variables for instrumentation to a container
  # loader: only try using the odigos loader which requires setting the LD_PRELOAD env var in the container manifest.
  # pod-manifest: add the environment variables to the container manifest.
  # loader-fallback-to-pod-manifest: try using the odigos loader first, and if it fails, fallback to adding the environment variables to the container manifest.
  agentEnvVarsInjectionMethod: ''

  # the timeout in seconds for the pods webhook.
  # default is 10 seconds and it is recommended to keep it as is unless you are experiencing issues with the webhook.
  # value must be 30 seconds max (inforced by kubernetes)
  # a shorter timeout will relieve API pressure, but may result in more pods failing to instrument
  # podsWebhookTimeoutSeconds: 25

odiglet:
  odiglet:
    livenessProbe:
      httpGet:
        path: /healthz
        # Prior to Kubernetes v1.26, Odigos uses host networking.
        # In some environments, different ports may already be in use on the host (e.g., due to other daemons or networking constraints).
        # Use the following values to configure the readiness and liveness probe ports to avoid conflicts.
        port: 55683
      initialDelaySeconds: 15
      periodSeconds: 20
      timeoutSeconds: 10
    readinessProbe:
      httpGet:
        path: /readyz
        port: 55683
      periodSeconds: 10
    # capabilities to add to the odiglet container when running as unPrivileged - this will be ignored when running as privileged.
    capabilities:
      # SYS_ADMIN required when running in unprivileged mode if one of the following is true:
      #  1. kernel version is older than 5.8 (In >= 5.8 BPF and PERMON were added)
      #  2. kernel.perf_event_paranoid sysctl is set to 2 or higher
      - SYS_ADMIN
      - BPF
      - PERFMON
      - SYS_PTRACE
      - DAC_READ_SEARCH
      # required for mmap of perf buffers
      - IPC_LOCK
      # required only for kernels < 5.11.
      # used for setting rlimit for BPF maps
      - SYS_RESOURCE
    # apparmorProfile for the odiglet container when running as unPrivileged.
    # this will be ignored when running as privileged.
    appArmorProfile:
      type: "Unconfined"
  # traceIdSuffix is a unique, 1 byte hex constant identifier for timestamp based trace id generation.
  # supported only in odigos pro (not available in community tier)
  # traceIdSuffix: 'AA'
  dataCollection:
    # capabilities to add to the data-collection container when running as un privileged - this will be ignored when running as privileged.
    capabilities:
      # SYS_ADMIN required when running in unprivileged mode if one of the following is true:
      #  1. kernel version is older than 5.8 (In >= 5.8 BPF and PERMON were added)
      #  2. kernel.perf_event_paranoid sysctl is set to 2 or higher
      - SYS_ADMIN
      - BPF
      - PERFMON
      - IPC_LOCK
  # Uncomment to override the global nodeSelector (values.nodeSelector) for this component
  # nodeSelector:
  #   kubernetes.io/os: linux
  tolerations:
    ## This toleration with 'Exists' operator and no key/effect specified
    ## will match ALL taints, allowing pods to be scheduled on any node
    ## regardless of its taints (including master/control-plane nodes)
    - operator: Exists
  affinity: {}
  # Priority class name. Set to empty string to disable.
  priorityClassName: 'system-node-critical'
  # Resource configuration for the odiglet daemonset
  # resources:
  #   requests:
  #     cpu: 10m
  #     memory: 64Mi
  #   limits:
  #     cpu: 500m
  #     memory: 512Mi
  deviceplugin:
    resources:
      requests:
        cpu: 40m
        memory: 200Mi
      limits:
        cpu: 100m
        memory: 300Mi

  # noHostNetwork can be set to true to avoid using hostNetwork in the odiglet daemonset.
  # for k8s versions prior to v1.26, hostNetwork is required for OpAmp to work correctly and for some of the OTel agents.
  # for k8s v1.26 and later, hostNetwork is not required and this flag is a no-op.
  noHostNetwork: false

  ## Odiglet init container resources, the init container is responsible for copying the instrumentation agents to the host.
  ## There is a tradeoff of using more resources for the init container, and the time it takes to copy the instrumentation agents to the host.
  initContainerResources:
    requests:
      cpu: 200m
      memory: 200Mi
    limits:
      cpu: 200m
      memory: 200Mi

  # in some environments, such as Rancher installations, the container runtime Unix socket is not located in a standard path.
  # In these cases, you should mount the correct socket location (e.g., /var/lib/rancher/rke2/agent/containerd/containerd.sock)
  # into the Odiglet to ensure it can access the container runtime unix socket.
  customContainerRuntimeSocketPath: ''

  # run the odiglet container without privileged containers.
  # when set to true, odiglet will use the set of capabilities required for eBPF operations.
  # by default, odiglet runs as a privileged container.
  unPrivileged: false

  # noHostPathMounts can be set to true to avoid using hostPath mounts in the odiglet daemonset.
  # When set to true, instrumentor.mountMethod must be set to "k8s-init-container", since that is the only mount method
  # that does not rely on host mounts to pass the required agents files to instrumented pods.
  # by default, odiglet will rely on hostPath mounts in /var/odigos
  noHostPathMounts: false

  # noHostPid can be set to true to avoid using hostPID in the odiglet daemonset.
  # when set to true, odiglet will mount /proc from the host to be able scan running processes and instrument them.
  # when noHostPid and noHostPathMounts are set to true the /proc host mount must be allowed.
  # setting this to true (i.e avoiding hostPid) may limit some eBPF capabilities, depending on the instrumented workloads.
  # by default, odiglet will use hostPID to be able to scan running processes and instrument them.
  noHostPid: false

  # When the code-attributes InstrumentationRule is enabled, you can choose to disable collecting code attributes for Go instrumentation.
  # Collecting code attributes in Go is resource-intensive and may affect odiglet performance in environments with many Go workloads.
  # Set this to true to turn off code attribute recording for Go instrumentation.
  disableGoCodeAttributes: false

centralProxy:
  # Central backend URL where this proxy will forward data
  centralBackendURL: ''
  resources:
    requests:
      cpu: 100m
      memory: 64Mi
    limits:
      cpu: 500m
      memory: 256Mi

  # TLS Configuration
  tls:
    # Skip TLS certificate verification (for testing/self-signed certificates)
    skipVerify: false

    # Secret name containing CA certificate (key: 'ca.crt')
    caSecretName: ''

    # Secret name containing client certificate and key for mTLS (keys: 'tls.crt', 'tls.key')
    clientCertSecretName: ''

  # Uncomment to override the global nodeSelector (values.nodeSelector) for this component
  # nodeSelector:
  #   kubernetes.io/os: linux
  tolerations: []
  affinity: {}
  # Priority class name. Set to use your existing cluster priority classes.
  # priorityClassName: ''

# Pod Security Policy
psp:
  enabled: false

telemetry:
  enabled: true

openshift:
  # Controls whether to use OpenShift-specific settings and images.
  enabled: false

  # Controls whether to use Red Hat certified image tags (-certified suffix).
  # By default, this is unset and will inherit the value of openshift.enabled.
  # Set to false to explicitly disable certified images even when openshift.enabled is true.
  # Set to true to explicitly enable certified images (requires openshift.enabled to also be true).
  # Note that certifiedImageTags must be true (either by default or explicitly set) if pulling from the default Red Hat registry
  # (registry.connect.redhat.com) which is used when openshift.enabled is true.
  # Setting this to false is useful if you are hosting images in your own registry (with imagePrefix set) but
  # still deploying on OpenShift, which requires other settings that are applied by openshift.enabled for OpenShift compatibility.
  #certifiedImageTags: false

gke:
  enabled: false

# List of profile names (array). Example (YAML): profiles: [PROFILE_NAME] | (CLI): --set profiles={PROFILE_NAME}
profiles: []

# Global NodeSelector to apply to all Odigos components by default.
# Individual components can override this by uncommenting their specific nodeSelector configuration.
# Note: Odigos will only be able to instrument workloads on the same nodes.
nodeSelector:
  kubernetes.io/os: linux

# Karpenter settings, before changing to true please modify the karpenter-node-template.yaml file
# to add the odigos-agent startupTaints configuration.
# https://docs.odigos.io/setup/odigos-with-karpenter
karpenter:
  enabled: false

# Refer to the official Kubernetes documentation for structure and field details:
# https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/
#
# Example: Odigos components should be evenly spread across zones.
# No need to set labelSelector manually — the Odigos Helm chart will apply it automatically.
# topologySpreadConstraints:
#   - maxSkew: 1
#     topologyKey: "topology.kubernetes.io/zone"
#     whenUnsatisfiable: "ScheduleAnyway"
topologySpreadConstraints: []

# Auto rollback settings
# The auto‐rollback feature provides a stability window to test instrumented apps.
# After an application is instrumented, a grace period begins during which we allow the app (and its dependencies) to stabilize and start working.
# Once the grace period has passed and we are within the stability window, we can decide to uninstrument a crashing application.
autoRollback:
  disabled: false
  graceTime: 5m
  stabilityWindowTime: 1h

rollout:
# Odigos automatically triggers a one-time rollout for workloads when instrumenting or uninstrumenting, to apply changes.
# If workload restarts are sensitive, this setting can be used to disable the automatic rollout.
# When disabled, users are responsible for manually triggering rollouts after adding or removing sources.
# Any new pods created after enabling or disabling the agent (via manual rollout, autoscaling, etc.)
# will still have the agent injected, regardless of this setting.
# When set to true, all additional configurations related to automated rollouts or rollbacks are ignored.
  automaticRolloutDisabled: false

# Pod Disruption Budgets (PDBs) help ensure high availability during voluntary disruptions like node drains or upgrades.
# When enabled, Odigos will deploy PDBs for its components based on their importance:
# - Critical components (e.g., instrumentor) will be protected with stricter disruption limits.
# - Non-critical components will use more relaxed budgets to allow operational flexibility.
# This reflects Odigos' recommended defaults for maintaining observability continuity without blocking routine maintenance.
# PDBs are disabled by default and can be enabled in production environments where stability during disruptions is important.
pdb:
  enabled: false

# Setting for allowing Odigos to run concurrently with other agents
allowConcurrentAgents:
  enabled: false

# Enable support for ClickHouse JSON column type when storing Odigos data.
# When set to true, Odigos will use a new schema with JSON-typed columns (requires ClickHouse v25.3+).
# If set to false, the default schema using Map-type columns will be used instead.
clickhouseDestinationJsonType:
  enabled: false

# controls the wasp settings
wasp:
  enabled: false

# configuration for metrics sources (where odigos collects metrics from)
# only relevant when a metrics destination is enabled
metricsSources:
  hostMetrics:
    ## uncomment the next line to disable host metrics collection globally
    #disabled: false

    ## set time interval for host metrics scraping
    ## format is duration string (15s, 1m, etc)
    # interval: '10s'

  kubeletStats:
    ## uncomment the next line to disable kubelet stats collection globally
    #disabled: false

    ## set time interval for kubelet stats scraping
    ## format is duration string (15s, 1m, etc)
    # interval: '10s'

  spanMetrics:
    # uncomment the next line to disable span metrics collection globally
    #disabled: false

    ## set time interval for span metrics flushing
    ## format is duration string (15s, 1m, etc)
    ## default is 60s
    # interval: '60s'

    ## set additional dimensions for span metrics
    ## format is a list of strings
    # additionalDimensions: ['some.attribute']

    ## uncomment the next line to disable histogram metrics collection (while still recording non-histogram span metrics)
    # histogramDisabled: true

    ## set explicit histogram buckets for span metrics
    ## format is duration string (1us, 2ms, 3s, 4m, 5h, 6d, etc)
    # explicitHistogramBuckets: ['2ms', '4ms', '6ms', '8ms', '10ms', '50ms', '100ms', '200ms', '400ms', '800ms', '1s', '1400ms', '2s', '5s', '10s', '15s']

    ## set if process level dimensions will be included in span metrics
    ## by default, process level metrics are not included
    ## when set to true - timeseries will be created for each process in a container
    ## when unset or set to false - timeseries will aggregate all processes into a single value per series
    # includedProcessInDimensions: true

    ## set resource attributes to exclude from the span metrics
    # excludedResourceAttributes: ['process.runtime.name', 'process.runtime.version']

    ## Advanced configuration - avoid using unless you know what you are doing.
    ## This list controls which resource attributes are included in the metric stream identity.
    ## These attributes are used to determines how span metrics are grouped.
    # resourceMetricsKeyAttributes: ['service.name', 'k8s.pod.name']

  odigosOwnMetrics:

    ## set the interval at which odigos will scrape metrics from itself.
    ## format: duration string (15s, 1m, etc).
    ## default is 10s.
    # scrapeInterval: '10s'

  agentMetrics:

    ## uncomment the next section to enable computing and reporting
    ## span metrics directly in agents that support it.
    ## the configuration for agent span metrics is the same as the
    ## span metrics collector settings.
    ## agents have different capabilities and support different configuration options.
    # spanMetrics:
    #   enabled: true

    runtimeMetrics:
      java:
        # Global enable/disable for all JVM metrics
        # disabled: true

        # Individual metric configuration - each metric can be enabled/disabled
        # metrics:
        #   # Class loading metrics
        #   - name: jvm.gc.duration
        #     disabled: true
        #   - name: jvm.memory.used
        #     disabled: true

# Enable automatic Go library offsets updates.
# See https://docs.odigos.io/pipeline/golang/ebpf#go-auto-offsets for more details.
# cron schedule for automatic Go offsets updates (e.g. "0 0 * * *" for daily at midnight). Set to empty string to disable.
# Custom Offsets support is only available in Odigos pro tier.
goAutoOffsetsCron: ''
# mode for automatic Go offsets updates. Options include direct (pull from cloud server), image (pull from local image) and off (disabled).
# Custom Offsets support is only available in Odigos pro tier.
goAutoOffsetsMode: 'off'

# experimental configuration for own telemetry of odigos on itself
ownTelemetry:
  # configuration for the victoriametrics instance that is shipped with odigos for own telemetry
  metricsStore:
    # set to true to disable the odigos victoriametrics own metrics store
    disabled: true
